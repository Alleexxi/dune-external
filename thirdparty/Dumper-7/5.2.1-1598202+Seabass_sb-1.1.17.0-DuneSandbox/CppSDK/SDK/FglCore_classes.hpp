#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FglCore

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "FglCore_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class FglCore.FglComponentBlueprintAccessBase
// 0x0000 (0x0030 - 0x0030)
class UFglComponentBlueprintAccessBase : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FglComponentBlueprintAccessBase">();
	}
	static class UFglComponentBlueprintAccessBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFglComponentBlueprintAccessBase>();
	}
};
static_assert(alignof(UFglComponentBlueprintAccessBase) == 0x000008, "Wrong alignment on UFglComponentBlueprintAccessBase");
static_assert(sizeof(UFglComponentBlueprintAccessBase) == 0x000030, "Wrong size on UFglComponentBlueprintAccessBase");

// Class FglCore.OwnerComponent_BlueprintAcessLibrary
// 0x0000 (0x0030 - 0x0030)
class UOwnerComponent_BlueprintAcessLibrary final : public UFglComponentBlueprintAccessBase
{
public:
	static EFglBlueprintResult FglAssignOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId, const struct FOwnerComponent& InComponent);
	static EFglBlueprintResult FglGetOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId, struct FOwnerComponent* OutOwnerComponent);
	static EFglBlueprintResult FglHasOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId);
	static EFglBlueprintResult FglSetOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId, const struct FOwnerComponent& InComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwnerComponent_BlueprintAcessLibrary">();
	}
	static class UOwnerComponent_BlueprintAcessLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwnerComponent_BlueprintAcessLibrary>();
	}
};
static_assert(alignof(UOwnerComponent_BlueprintAcessLibrary) == 0x000008, "Wrong alignment on UOwnerComponent_BlueprintAcessLibrary");
static_assert(sizeof(UOwnerComponent_BlueprintAcessLibrary) == 0x000030, "Wrong size on UOwnerComponent_BlueprintAcessLibrary");

// Class FglCore.ChildOwnerComponent_BlueprintAcessLibrary
// 0x0000 (0x0030 - 0x0030)
class UChildOwnerComponent_BlueprintAcessLibrary final : public UFglComponentBlueprintAccessBase
{
public:
	static EFglBlueprintResult FglAssignChildOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId, const struct FChildOwnerComponent& InComponent);
	static EFglBlueprintResult FglGetChildOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId, struct FChildOwnerComponent* OutChildOwnerComponent);
	static EFglBlueprintResult FglHasChildOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId);
	static EFglBlueprintResult FglSetChildOwnerComponent(const class UObject* WorldContextObject, const struct FEntityId& InEntityId, const struct FChildOwnerComponent& InComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChildOwnerComponent_BlueprintAcessLibrary">();
	}
	static class UChildOwnerComponent_BlueprintAcessLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChildOwnerComponent_BlueprintAcessLibrary>();
	}
};
static_assert(alignof(UChildOwnerComponent_BlueprintAcessLibrary) == 0x000008, "Wrong alignment on UChildOwnerComponent_BlueprintAcessLibrary");
static_assert(sizeof(UChildOwnerComponent_BlueprintAcessLibrary) == 0x000030, "Wrong size on UChildOwnerComponent_BlueprintAcessLibrary");

// Class FglCore.BlueprintProcessor
// 0x0108 (0x0138 - 0x0030)
class UBlueprintProcessor final : public UObject
{
public:
	bool                                          bRegisterOnServer;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegisterOnClient;                                 // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFglTickGroup                                 TickGroup;                                         // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFglSchedulerType                             SchedulerType;                                     // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFglProcessorReference>         ClientPrerequisites;                               // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFglProcessorReference>         ServerPrerequisites;                               // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFglProcessorReference>         ListenServerPrerequisites;                         // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFglProcessorReference>         ClientInjectDependencies;                          // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFglProcessorReference>         ServerInjectDependencies;                          // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFglProcessorReference>         ListenServerInjectDependencies;                    // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bForceGameThread;                                  // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeContextDescriptor              ContextDescriptor;                                 // 0x00A0(0x0010)(Edit, NativeAccessSpecifierPublic)
	float                                         TickRate;                                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x84];                                      // 0x00B4(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessorFunction(const int32 ThreadIndex, const struct FRuntimeImmediateContext& Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintProcessor">();
	}
	static class UBlueprintProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintProcessor>();
	}
};
static_assert(alignof(UBlueprintProcessor) == 0x000008, "Wrong alignment on UBlueprintProcessor");
static_assert(sizeof(UBlueprintProcessor) == 0x000138, "Wrong size on UBlueprintProcessor");
static_assert(offsetof(UBlueprintProcessor, bRegisterOnServer) == 0x000030, "Member 'UBlueprintProcessor::bRegisterOnServer' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, bRegisterOnClient) == 0x000031, "Member 'UBlueprintProcessor::bRegisterOnClient' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, TickGroup) == 0x000032, "Member 'UBlueprintProcessor::TickGroup' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, SchedulerType) == 0x000033, "Member 'UBlueprintProcessor::SchedulerType' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, ClientPrerequisites) == 0x000038, "Member 'UBlueprintProcessor::ClientPrerequisites' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, ServerPrerequisites) == 0x000048, "Member 'UBlueprintProcessor::ServerPrerequisites' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, ListenServerPrerequisites) == 0x000058, "Member 'UBlueprintProcessor::ListenServerPrerequisites' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, ClientInjectDependencies) == 0x000068, "Member 'UBlueprintProcessor::ClientInjectDependencies' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, ServerInjectDependencies) == 0x000078, "Member 'UBlueprintProcessor::ServerInjectDependencies' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, ListenServerInjectDependencies) == 0x000088, "Member 'UBlueprintProcessor::ListenServerInjectDependencies' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, bForceGameThread) == 0x000098, "Member 'UBlueprintProcessor::bForceGameThread' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, ContextDescriptor) == 0x0000A0, "Member 'UBlueprintProcessor::ContextDescriptor' has a wrong offset!");
static_assert(offsetof(UBlueprintProcessor, TickRate) == 0x0000B0, "Member 'UBlueprintProcessor::TickRate' has a wrong offset!");

// Class FglCore.FglEngineSettings
// 0x0020 (0x0050 - 0x0030)
class UFglEngineSettings final : public UObject
{
public:
	TArray<TSoftClassPtr<class UClass>>           BlueprintProcessors;                               // 0x0030(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FFglProcessorReference>         DisabledProcessors;                                // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FglEngineSettings">();
	}
	static class UFglEngineSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFglEngineSettings>();
	}
};
static_assert(alignof(UFglEngineSettings) == 0x000008, "Wrong alignment on UFglEngineSettings");
static_assert(sizeof(UFglEngineSettings) == 0x000050, "Wrong size on UFglEngineSettings");
static_assert(offsetof(UFglEngineSettings, BlueprintProcessors) == 0x000030, "Member 'UFglEngineSettings::BlueprintProcessors' has a wrong offset!");
static_assert(offsetof(UFglEngineSettings, DisabledProcessors) == 0x000040, "Member 'UFglEngineSettings::DisabledProcessors' has a wrong offset!");

// Class FglCore.FGLWorldSubsystem
// 0x00B8 (0x00F0 - 0x0038)
class UFGLWorldSubsystem final : public UWorldSubsystem
{
public:
	class AGameplayScheduler*                     m_Scheduler;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x88];                                      // 0x0040(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorDestructionEntry>         m_ActorsMarkedForDestruction;                      // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FGLWorldSubsystem">();
	}
	static class UFGLWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFGLWorldSubsystem>();
	}
};
static_assert(alignof(UFGLWorldSubsystem) == 0x000008, "Wrong alignment on UFGLWorldSubsystem");
static_assert(sizeof(UFGLWorldSubsystem) == 0x0000F0, "Wrong size on UFGLWorldSubsystem");
static_assert(offsetof(UFGLWorldSubsystem, m_Scheduler) == 0x000038, "Member 'UFGLWorldSubsystem::m_Scheduler' has a wrong offset!");
static_assert(offsetof(UFGLWorldSubsystem, m_ActorsMarkedForDestruction) == 0x0000C8, "Member 'UFGLWorldSubsystem::m_ActorsMarkedForDestruction' has a wrong offset!");

// Class FglCore.GameplayScheduler
// 0x0060 (0x03B0 - 0x0350)
class AGameplayScheduler : public AActor
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTickGroupScheduler*            PrePhysics;                                        // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTickGroupScheduler*            DuringPhysics;                                     // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTickGroupScheduler*            PostPhysics;                                       // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTickGroupScheduler*            PostUpdateWork;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTickGroupScheduler*            LastDemotable;                                     // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFGLWorldSubsystem*                     m_FGLSubsystem;                                    // 0x0380(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x28];                                     // 0x0388(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayScheduler">();
	}
	static class AGameplayScheduler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayScheduler>();
	}
};
static_assert(alignof(AGameplayScheduler) == 0x000008, "Wrong alignment on AGameplayScheduler");
static_assert(sizeof(AGameplayScheduler) == 0x0003B0, "Wrong size on AGameplayScheduler");
static_assert(offsetof(AGameplayScheduler, PrePhysics) == 0x000358, "Member 'AGameplayScheduler::PrePhysics' has a wrong offset!");
static_assert(offsetof(AGameplayScheduler, DuringPhysics) == 0x000360, "Member 'AGameplayScheduler::DuringPhysics' has a wrong offset!");
static_assert(offsetof(AGameplayScheduler, PostPhysics) == 0x000368, "Member 'AGameplayScheduler::PostPhysics' has a wrong offset!");
static_assert(offsetof(AGameplayScheduler, PostUpdateWork) == 0x000370, "Member 'AGameplayScheduler::PostUpdateWork' has a wrong offset!");
static_assert(offsetof(AGameplayScheduler, LastDemotable) == 0x000378, "Member 'AGameplayScheduler::LastDemotable' has a wrong offset!");
static_assert(offsetof(AGameplayScheduler, m_FGLSubsystem) == 0x000380, "Member 'AGameplayScheduler::m_FGLSubsystem' has a wrong offset!");

// Class FglCore.GameplayTickGroupScheduler
// 0x0018 (0x0140 - 0x0128)
class UGameplayTickGroupScheduler final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float DeltaTime)> OnFGLTickCompleted;                              // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGameplayScheduler*                     Scheduler;                                         // 0x0138(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTickGroupScheduler">();
	}
	static class UGameplayTickGroupScheduler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTickGroupScheduler>();
	}
};
static_assert(alignof(UGameplayTickGroupScheduler) == 0x000008, "Wrong alignment on UGameplayTickGroupScheduler");
static_assert(sizeof(UGameplayTickGroupScheduler) == 0x000140, "Wrong size on UGameplayTickGroupScheduler");
static_assert(offsetof(UGameplayTickGroupScheduler, OnFGLTickCompleted) == 0x000128, "Member 'UGameplayTickGroupScheduler::OnFGLTickCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTickGroupScheduler, Scheduler) == 0x000138, "Member 'UGameplayTickGroupScheduler::Scheduler' has a wrong offset!");

// Class FglCore.FglBlueprintAccessLibrary
// 0x0000 (0x0030 - 0x0030)
class UFglBlueprintAccessLibrary : public UBlueprintFunctionLibrary
{
public:
	static struct FRuntimeImmediateContext CreateAndLockContext(class UObject* WorldContextObject, const TArray<struct FRuntimeAccessor>& Accessors);
	static struct FEntityId CreateEntityId(const class UObject* WorldContextObject);
	static struct FRuntimeView CreateRuntimeView(struct FRuntimeImmediateContext& Context, const TArray<struct FRuntimeViewFilter>& Filters, struct FRuntimeViewIterator* Iterator);
	static void FreeRuntimeView(struct FRuntimeView& View);
	static void GetComponent(struct FRuntimeImmediateContext& Context, const struct FEntityId& EntityId, const struct FRuntimeAccessor& ComponentAccessor, int32* Value);
	static TSet<struct FEntityId> GetEntitiesWithComponent(class UObject* WorldContextObject, class FName ComponentName);
	static struct FEntityId GetEntityID(const class UObject* InFglEntity);
	static struct FEntityId GetFGLSingletonId_Blueprint(const class UObject* WorldContextObject);
	static class UGameplayTickGroupScheduler* GetTickGroupSchedulerFor(const class UObject* WorldContextObject, ETickingGroup TickGroup);
	static bool HasComponents(struct FRuntimeImmediateContext& Context, const struct FEntityId& EntityId, const TArray<struct FRuntimeAccessor>& Accessors);
	static bool IsValid(const struct FEntityId& InFglEntity);
	static void SetComponent(struct FRuntimeImmediateContext& Context, const struct FEntityId& EntityId, const struct FRuntimeAccessor& ComponentAccessor, int32& Value);
	static void UnlockContext(struct FRuntimeImmediateContext& Context);
	static void ViewIteratorAdvance(struct FRuntimeViewIterator& Iterator);
	static void ViewIteratorGetComponent(struct FRuntimeViewIterator& Iterator, int32 GetterIndex, int32* Value);
	static struct FEntityId ViewIteratorGetEntityId(struct FRuntimeViewIterator& Iterator);
	static bool ViewIteratorIsValid(struct FRuntimeViewIterator& Iterator);
	static void ViewIteratorSetComponent(struct FRuntimeViewIterator& Iterator, int32 GetterIndex, int32& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FglBlueprintAccessLibrary">();
	}
	static class UFglBlueprintAccessLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFglBlueprintAccessLibrary>();
	}
};
static_assert(alignof(UFglBlueprintAccessLibrary) == 0x000008, "Wrong alignment on UFglBlueprintAccessLibrary");
static_assert(sizeof(UFglBlueprintAccessLibrary) == 0x000030, "Wrong size on UFglBlueprintAccessLibrary");

}


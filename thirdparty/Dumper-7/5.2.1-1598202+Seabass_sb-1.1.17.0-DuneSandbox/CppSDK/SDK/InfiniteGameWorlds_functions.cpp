#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InfiniteGameWorlds

#include "Basic.hpp"

#include "InfiniteGameWorlds_classes.hpp"
#include "InfiniteGameWorlds_parameters.hpp"


namespace SDK
{

// Function InfiniteGameWorlds.UniverseTimeComponent.OnRep_FarmTime
// (Final, Native, Private)

void UUniverseTimeComponent::OnRep_FarmTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UniverseTimeComponent", "OnRep_FarmTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sCheatManager.ReceiveEndPlay
// (Event, Public, BlueprintEvent)

void US2sCheatManager::ReceiveEndPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sCheatManager", "ReceiveEndPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InfiniteGameWorlds.S2sCheatManager.ReceiveInitCheatManager
// (Event, Public, BlueprintEvent)

void US2sCheatManager::ReceiveInitCheatManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sCheatManager", "ReceiveInitCheatManager");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InfiniteGameWorlds.S2sCheatManager.SetSoftBorderEnabled
// (Final, Exec, Native, Public)
// Parameters:
// const bool                              Enabled                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void US2sCheatManager::SetSoftBorderEnabled(const bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sCheatManager", "SetSoftBorderEnabled");

	Params::S2sCheatManager_SetSoftBorderEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sCheatManager.SetSoftBorderMargin
// (Final, Exec, Native, Public)
// Parameters:
// const float                             Margin                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void US2sCheatManager::SetSoftBorderMargin(const float Margin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sCheatManager", "SetSoftBorderMargin");

	Params::S2sCheatManager_SetSoftBorderMargin Parms{};

	Parms.Margin = Margin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sCheatManager.PrintActorFindSystemState
// (Final, Exec, Native, Public, Const)

void US2sCheatManager::PrintActorFindSystemState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sCheatManager", "PrintActorFindSystemState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sCheatManager.PrintActorPersistenceOwnership
// (Final, Exec, Native, Public, Const)

void US2sCheatManager::PrintActorPersistenceOwnership() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sCheatManager", "PrintActorPersistenceOwnership");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.ServerMapData.OnRep_PlayerPositions
// (Final, Native, Protected)

void UServerMapData::OnRep_PlayerPositions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerMapData", "OnRep_PlayerPositions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.ActorDebugInfo.GetActorGlobalID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FActorGlobalID                   ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActorGlobalID UActorDebugInfo::GetActorGlobalID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorDebugInfo", "GetActorGlobalID");

	Params::ActorDebugInfo_GetActorGlobalID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.ActorDebugInfo.GetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UActorDebugInfo::GetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorDebugInfo", "GetLocation");

	Params::ActorDebugInfo_GetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.S2sController.ClientAuthorityTransferConfirmed
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// uint32                                  ActorNetGuid                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActorStatePacket&         StatePacket                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AS2sController::ClientAuthorityTransferConfirmed(uint32 ActorNetGuid, const struct FActorStatePacket& StatePacket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientAuthorityTransferConfirmed");

	Params::S2sController_ClientAuthorityTransferConfirmed Parms{};

	Parms.ActorNetGuid = ActorNetGuid;
	Parms.StatePacket = std::move(StatePacket);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientEndPCAuthorityTransfer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ClientEndPCAuthorityTransfer(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientEndPCAuthorityTransfer");

	Params::S2sController_ClientEndPCAuthorityTransfer Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientFlushAuthorityTransfer
// (Net, NetReliable, Native, Event, Public, NetClient)

void AS2sController::ClientFlushAuthorityTransfer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientFlushAuthorityTransfer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientNotifyActorsToLoad
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<struct FUniqueID>&         PersistenceIDs                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AS2sController::ClientNotifyActorsToLoad(const TArray<struct FUniqueID>& PersistenceIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientNotifyActorsToLoad");

	Params::S2sController_ClientNotifyActorsToLoad Parms{};

	Parms.PersistenceIDs = std::move(PersistenceIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientOnAuthorityTransferRejected
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ClientOnAuthorityTransferRejected(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientOnAuthorityTransferRejected");

	Params::S2sController_ClientOnAuthorityTransferRejected Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientOnProxyAuthorityTransferStart
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuthorityTransferParams&  TransferParams                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AS2sController::ClientOnProxyAuthorityTransferStart(class AActor* Actor, const struct FAuthorityTransferParams& TransferParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientOnProxyAuthorityTransferStart");

	Params::S2sController_ClientOnProxyAuthorityTransferStart Parms{};

	Parms.Actor = Actor;
	Parms.TransferParams = std::move(TransferParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientReplicateIgwObject
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class FName                       ObjectName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UIgwObject>           Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ClientReplicateIgwObject(const class FName ObjectName, TSubclassOf<class UIgwObject> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientReplicateIgwObject");

	Params::S2sController_ClientReplicateIgwObject Parms{};

	Parms.ObjectName = ObjectName;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientSetControllerPawn
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FUniqueNetIdRepl&          UniqueNetId                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ClientSetControllerPawn(const struct FUniqueNetIdRepl& UniqueNetId, class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientSetControllerPawn");

	Params::S2sController_ClientSetControllerPawn Parms{};

	Parms.UniqueNetId = std::move(UniqueNetId);
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ClientStartPCAuthorityTransfer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpectator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ClientStartPCAuthorityTransfer(class APlayerController* PC, bool bSpectator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ClientStartPCAuthorityTransfer");

	Params::S2sController_ClientStartPCAuthorityTransfer Parms{};

	Parms.PC = PC;
	Parms.bSpectator = bSpectator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.CloseS2S
// (Exec, Native, Public)
// Parameters:
// const class FString&                    Connection                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::CloseS2S(const class FString& Connection, int32 Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "CloseS2S");

	Params::S2sController_CloseS2S Parms{};

	Parms.Connection = std::move(Connection);
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.EnableCheats
// (Exec, Native, Public)

void AS2sController::EnableCheats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "EnableCheats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_ElectionData
// (Final, Native, Private)

void AS2sController::OnRep_ElectionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_ElectionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_FarmSessionID
// (Final, Native, Private)

void AS2sController::OnRep_FarmSessionID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_FarmSessionID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_FarmSize
// (Final, Native, Private)

void AS2sController::OnRep_FarmSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_FarmSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_LoadedLevels
// (Final, Native, Private)

void AS2sController::OnRep_LoadedLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_LoadedLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_LocalAddress
// (Final, Native, Private)

void AS2sController::OnRep_LocalAddress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_LocalAddress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_MapElectionData
// (Final, Native, Private)

void AS2sController::OnRep_MapElectionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_MapElectionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_MapName
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FSoftObjectPath&           OldMapName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::OnRep_MapName(const struct FSoftObjectPath& OldMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_MapName");

	Params::S2sController_OnRep_MapName Parms{};

	Parms.OldMapName = std::move(OldMapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_PartitionDefinition
// (Final, Native, Private)

void AS2sController::OnRep_PartitionDefinition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_PartitionDefinition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_PeerServers
// (Final, Native, Private)

void AS2sController::OnRep_PeerServers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_PeerServers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_PlayerDebugMap
// (Final, Native, Private)

void AS2sController::OnRep_PlayerDebugMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_PlayerDebugMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_ServerBoundaries
// (Final, Native, Private)

void AS2sController::OnRep_ServerBoundaries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_ServerBoundaries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_ServerID
// (Final, Native, Private)

void AS2sController::OnRep_ServerID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_ServerID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_ServerIndices
// (Final, Native, Private)

void AS2sController::OnRep_ServerIndices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_ServerIndices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_ServerState
// (Final, Native, Private)

void AS2sController::OnRep_ServerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_ServerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_UniqueNetIdMap
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FUniqueNetIdGUIDs&         OldFUniqueNetIdGUIDs                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AS2sController::OnRep_UniqueNetIdMap(const struct FUniqueNetIdGUIDs& OldFUniqueNetIdGUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_UniqueNetIdMap");

	Params::S2sController_OnRep_UniqueNetIdMap Parms{};

	Parms.OldFUniqueNetIdGUIDs = std::move(OldFUniqueNetIdGUIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_WorldCompositionShift
// (Final, Native, Private)

void AS2sController::OnRep_WorldCompositionShift()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_WorldCompositionShift");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.OnRep_WorldOffset
// (Final, Native, Private)

void AS2sController::OnRep_WorldOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "OnRep_WorldOffset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.PerfCapture
// (Exec, Native, Public)
// Parameters:
// int32                                   NumSeconds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::PerfCapture(int32 NumSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "PerfCapture");

	Params::S2sController_PerfCapture Parms{};

	Parms.NumSeconds = NumSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.PingServers
// (Final, Native, Private)

void AS2sController::PingServers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "PingServers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ServerFailAuthorityTransfer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TArray<uint32>&                   ActorNetGuids                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AS2sController::ServerFailAuthorityTransfer(const TArray<uint32>& ActorNetGuids)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ServerFailAuthorityTransfer");

	Params::S2sController_ServerFailAuthorityTransfer Parms{};

	Parms.ActorNetGuids = std::move(ActorNetGuids);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ServerGrabActorAuthority
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ServerGrabActorAuthority(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ServerGrabActorAuthority");

	Params::S2sController_ServerGrabActorAuthority Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ServerInitiateTeleportTo
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DestLocation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  DestRotation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIsATest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ServerInitiateTeleportTo(class AActor* Actor, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bIsATest, bool bNoCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ServerInitiateTeleportTo");

	Params::S2sController_ServerInitiateTeleportTo Parms{};

	Parms.Actor = Actor;
	Parms.DestLocation = std::move(DestLocation);
	Parms.DestRotation = std::move(DestRotation);
	Parms.bIsATest = bIsATest;
	Parms.bNoCheck = bNoCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ServerRequestPlayerAuthorityTransfer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class APlayerController*>& RelevantPlayers                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AS2sController::ServerRequestPlayerAuthorityTransfer(class APlayerController* PC, const TArray<class APlayerController*>& RelevantPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ServerRequestPlayerAuthorityTransfer");

	Params::S2sController_ServerRequestPlayerAuthorityTransfer Parms{};

	Parms.PC = PC;
	Parms.RelevantPlayers = std::move(RelevantPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ServerSetControllerActive
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpectator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ServerSetControllerActive(class APlayerController* PC, bool bActive, bool bSpectator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ServerSetControllerActive");

	Params::S2sController_ServerSetControllerActive Parms{};

	Parms.PC = PC;
	Parms.bActive = bActive;
	Parms.bSpectator = bSpectator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ServerStartAuthorityTransfer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuthorityTransferParams&  TransferParams                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AS2sController::ServerStartAuthorityTransfer(class AActor* Actor, const struct FAuthorityTransferParams& TransferParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ServerStartAuthorityTransfer");

	Params::S2sController_ServerStartAuthorityTransfer Parms{};

	Parms.Actor = Actor;
	Parms.TransferParams = std::move(TransferParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.S2sController.ServerExecRPC
// (Net, NetReliable, Native, Event, Public, NetServer, Const)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AS2sController::ServerExecRPC(const class FString& Msg) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("S2sController", "ServerExecRPC");

	Params::S2sController_ServerExecRPC Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.ActorFindSystemComponent.OnRep_ActorDataMap
// (Final, Native, Private)

void UActorFindSystemComponent::OnRep_ActorDataMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorFindSystemComponent", "OnRep_ActorDataMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwDebugComponent.OnRep_Actors
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FActorDebugMap&            OldActors                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UIgwDebugComponent::OnRep_Actors(const struct FActorDebugMap& OldActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwDebugComponent", "OnRep_Actors");

	Params::IgwDebugComponent_OnRep_Actors Parms{};

	Parms.OldActors = std::move(OldActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwDebugWidget.GetPawnOrSpectator
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UIgwDebugWidget::GetPawnOrSpectator(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugWidget", "GetPawnOrSpectator");

	Params::IgwDebugWidget_GetPawnOrSpectator Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugWidget.GetMapComboVisibility
// (Final, Native, Protected)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UIgwDebugWidget::GetMapComboVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwDebugWidget", "GetMapComboVisibility");

	Params::IgwDebugWidget_GetMapComboVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugWidget.OnMapChanged
// (Final, Native, Protected)
// Parameters:
// const class FString&                    SelectedItem                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESelectInfo                             SelectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwDebugWidget::OnMapChanged(const class FString& SelectedItem, ESelectInfo SelectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwDebugWidget", "OnMapChanged");

	Params::IgwDebugWidget_OnMapChanged Parms{};

	Parms.SelectedItem = std::move(SelectedItem);
	Parms.SelectionType = SelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerGridView.HasServerData
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIgwServerGridView::HasServerData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "HasServerData");

	Params::IgwServerGridView_HasServerData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerGridView.MouseToWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGeometry&                 Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FPointerEvent&             PointerEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UIgwServerGridView::MouseToWorld(const struct FGeometry& Geometry, const struct FPointerEvent& PointerEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "MouseToWorld");

	Params::IgwServerGridView_MouseToWorld Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.PointerEvent = std::move(PointerEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerGridView.PositionToWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGeometry&                 Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UIgwServerGridView::PositionToWorld(const struct FGeometry& Geometry, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "PositionToWorld");

	Params::IgwServerGridView_PositionToWorld Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerGridView.Rebuild
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UIgwServerGridView::Rebuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "Rebuild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerGridView.ScrollGrid
// (Final, BlueprintCosmetic, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerGridView::ScrollGrid(const struct FVector2D& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "ScrollGrid");

	Params::IgwServerGridView_ScrollGrid Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerGridView.WorldToLocal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UIgwServerGridView::WorldToLocal(const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "WorldToLocal");

	Params::IgwServerGridView_WorldToLocal Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerGridView.ZoomIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerGridView::ZoomIn(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "ZoomIn");

	Params::IgwServerGridView_ZoomIn Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerGridView.ZoomOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerGridView::ZoomOut(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "ZoomOut");

	Params::IgwServerGridView_ZoomOut Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerGridView.DrawPawns
// (Final, BlueprintCosmetic, Native, Protected, HasOutParams, BlueprintCallable, Const)
// Parameters:
// struct FPaintContext&                   Context                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UIgwServerGridView::DrawPawns(struct FPaintContext& Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "DrawPawns");

	Params::IgwServerGridView_DrawPawns Parms{};

	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Context = std::move(Parms.Context);
}


// Function InfiniteGameWorlds.IgwServerGridView.GetCurrentMap
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UIgwServerGridView::GetCurrentMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "GetCurrentMap");

	Params::IgwServerGridView_GetCurrentMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerGridView.GetZoomLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIgwServerGridView::GetZoomLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerGridView", "GetZoomLevel");

	Params::IgwServerGridView_GetZoomLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerItem.ChangeTextFontSize
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UTextBlock*                       Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BaseSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerItem::ChangeTextFontSize(class UTextBlock* Widget, int32 BaseSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerItem", "ChangeTextFontSize");

	Params::IgwServerItem_ChangeTextFontSize Parms{};

	Parms.Widget = Widget;
	Parms.BaseSize = BaseSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerItem.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 NewSize                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerItem::SetSize(const struct FVector2D& NewSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerItem", "SetSize");

	Params::IgwServerItem_SetSize Parms{};

	Parms.NewSize = std::move(NewSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerItem.GetServerIdentifier
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText*                            OutServerIdentifier                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void UIgwServerItem::GetServerIdentifier(class FText* OutServerIdentifier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerItem", "GetServerIdentifier");

	Params::IgwServerItem_GetServerIdentifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutServerIdentifier != nullptr)
		*OutServerIdentifier = std::move(Parms.OutServerIdentifier);
}


// Function InfiniteGameWorlds.IgwServerItem.GetServerIdText
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText*                            OutServerId                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// const int32                             MaxLength                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerItem::GetServerIdText(class FText* OutServerId, const int32 MaxLength) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerItem", "GetServerIdText");

	Params::IgwServerItem_GetServerIdText Parms{};

	Parms.MaxLength = MaxLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutServerId != nullptr)
		*OutServerId = std::move(Parms.OutServerId);
}


// Function InfiniteGameWorlds.IgwServerItem.GetZoomLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIgwServerItem::GetZoomLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerItem", "GetZoomLevel");

	Params::IgwServerItem_GetZoomLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.CheckArtificialBorder
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   GlobalLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CellSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIgwDebugFunctionLibrary::CheckArtificialBorder(const struct FVector& GlobalLocation, float Radius, int32 CellSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "CheckArtificialBorder");

	Params::IgwDebugFunctionLibrary_CheckArtificialBorder Parms{};

	Parms.GlobalLocation = std::move(GlobalLocation);
	Parms.Radius = Radius;
	Parms.CellSize = CellSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetActiveWorldBoundaries
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox2D UIgwDebugFunctionLibrary::GetActiveWorldBoundaries(const class UObject* WorldContext, const struct FSoftObjectPath& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetActiveWorldBoundaries");

	Params::IgwDebugFunctionLibrary_GetActiveWorldBoundaries Parms{};

	Parms.WorldContext = WorldContext;
	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetConnectedServers
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  MainServerIndex                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueID*                       MainPartitionId                                        (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          MainServerAddress                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<struct FServerID>*                 CurrentServers                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UIgwDebugFunctionLibrary::GetConnectedServers(const class UObject* WorldContext, int32* MainServerIndex, struct FUniqueID* MainPartitionId, class FString* MainServerAddress, TSet<struct FServerID>* CurrentServers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetConnectedServers");

	Params::IgwDebugFunctionLibrary_GetConnectedServers Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MainServerIndex != nullptr)
		*MainServerIndex = Parms.MainServerIndex;

	if (MainPartitionId != nullptr)
		*MainPartitionId = std::move(Parms.MainPartitionId);

	if (MainServerAddress != nullptr)
		*MainServerAddress = std::move(Parms.MainServerAddress);

	if (CurrentServers != nullptr)
		*CurrentServers = std::move(Parms.CurrentServers);
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetDimensionIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetDimensionIndex(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetDimensionIndex");

	Params::IgwDebugFunctionLibrary_GetDimensionIndex Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetFarmActorInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActorGlobalID&            GID                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorDebugInfo*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorDebugInfo* UIgwDebugFunctionLibrary::GetFarmActorInfo(const class UObject* WorldContext, const struct FActorGlobalID& GID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetFarmActorInfo");

	Params::IgwDebugFunctionLibrary_GetFarmActorInfo Parms{};

	Parms.WorldContext = WorldContext;
	Parms.GID = std::move(GID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetFarmActorList
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActorGlobalID>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActorGlobalID> UIgwDebugFunctionLibrary::GetFarmActorList(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetFarmActorList");

	Params::IgwDebugFunctionLibrary_GetFarmActorList Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetFarmMaps
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> UIgwDebugFunctionLibrary::GetFarmMaps(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetFarmMaps");

	Params::IgwDebugFunctionLibrary_GetFarmMaps Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetFarmNumActors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetFarmNumActors(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetFarmNumActors");

	Params::IgwDebugFunctionLibrary_GetFarmNumActors Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetHumanReadableServerTraffic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          InBytesStr                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutBytesStr                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwDebugFunctionLibrary::GetHumanReadableServerTraffic(const class UObject* WorldContext, const struct FServerID& ServerID, class FString* InBytesStr, class FString* OutBytesStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetHumanReadableServerTraffic");

	Params::IgwDebugFunctionLibrary_GetHumanReadableServerTraffic Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InBytesStr != nullptr)
		*InBytesStr = std::move(Parms.InBytesStr);

	if (OutBytesStr != nullptr)
		*OutBytesStr = std::move(Parms.OutBytesStr);
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetIGWDebugLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIGWDebugLevel                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EIGWDebugLevel UIgwDebugFunctionLibrary::GetIGWDebugLevel(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetIGWDebugLevel");

	Params::IgwDebugFunctionLibrary_GetIGWDebugLevel Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetNumConnectedServers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetNumConnectedServers(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetNumConnectedServers");

	Params::IgwDebugFunctionLibrary_GetNumConnectedServers Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetNumStandByServers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetNumStandByServers(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetNumStandByServers");

	Params::IgwDebugFunctionLibrary_GetNumStandByServers Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetPlayersConnectedToServer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetPlayersConnectedToServer(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetPlayersConnectedToServer");

	Params::IgwDebugFunctionLibrary_GetPlayersConnectedToServer Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetPlayersInServer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetPlayersInServer(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetPlayersInServer");

	Params::IgwDebugFunctionLibrary_GetPlayersInServer Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetS2SReplicatedActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetS2SReplicatedActors(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetS2SReplicatedActors");

	Params::IgwDebugFunctionLibrary_GetS2SReplicatedActors Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetS2SState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  NumOut                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  NumIn                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwDebugFunctionLibrary::GetS2SState(const class UObject* WorldContext, const struct FServerID& ServerID, int32* NumOut, int32* NumIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetS2SState");

	Params::IgwDebugFunctionLibrary_GetS2SState Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NumOut != nullptr)
		*NumOut = Parms.NumOut;

	if (NumIn != nullptr)
		*NumIn = Parms.NumIn;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerBoundaries
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox2D UIgwDebugFunctionLibrary::GetServerBoundaries(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerBoundaries");

	Params::IgwDebugFunctionLibrary_GetServerBoundaries Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerCPU
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIgwDebugFunctionLibrary::GetServerCPU(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerCPU");

	Params::IgwDebugFunctionLibrary_GetServerCPU Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerFps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIgwDebugFunctionLibrary::GetServerFps(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerFps");

	Params::IgwDebugFunctionLibrary_GetServerFps Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerIDs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeStandBy                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FServerID>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FServerID> UIgwDebugFunctionLibrary::GetServerIDs(const class UObject* WorldContext, bool bIncludeStandBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerIDs");

	Params::IgwDebugFunctionLibrary_GetServerIDs Parms{};

	Parms.WorldContext = WorldContext;
	Parms.bIncludeStandBy = bIncludeStandBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwDebugFunctionLibrary::GetServerIndex(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerIndex");

	Params::IgwDebugFunctionLibrary_GetServerIndex Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerLevels
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UIgwDebugFunctionLibrary::GetServerLevels(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerLevels");

	Params::IgwDebugFunctionLibrary_GetServerLevels Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerMainAddress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddressWithPort                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UIgwDebugFunctionLibrary::GetServerMainAddress(const class UObject* WorldContext, bool AddressWithPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerMainAddress");

	Params::IgwDebugFunctionLibrary_GetServerMainAddress Parms{};

	Parms.WorldContext = WorldContext;
	Parms.AddressWithPort = AddressWithPort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerPartitionDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartitionDefinition             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPartitionDefinition UIgwDebugFunctionLibrary::GetServerPartitionDefinition(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerPartitionDefinition");

	Params::IgwDebugFunctionLibrary_GetServerPartitionDefinition Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerTraffic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  InBytes                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutBytes                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwDebugFunctionLibrary::GetServerTraffic(const class UObject* WorldContext, const struct FServerID& ServerID, int32* InBytes, int32* OutBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerTraffic");

	Params::IgwDebugFunctionLibrary_GetServerTraffic Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InBytes != nullptr)
		*InBytes = Parms.InBytes;

	if (OutBytes != nullptr)
		*OutBytes = Parms.OutBytes;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetServerWorldOffset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UIgwDebugFunctionLibrary::GetServerWorldOffset(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetServerWorldOffset");

	Params::IgwDebugFunctionLibrary_GetServerWorldOffset Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetWorldBoundaries
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox2D UIgwDebugFunctionLibrary::GetWorldBoundaries(const class UObject* WorldContext, const struct FSoftObjectPath& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetWorldBoundaries");

	Params::IgwDebugFunctionLibrary_GetWorldBoundaries Parms{};

	Parms.WorldContext = WorldContext;
	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwDebugFunctionLibrary.GetWorldSize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSoftObjectPath&           MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UIgwDebugFunctionLibrary::GetWorldSize(const class UObject* WorldContext, const struct FSoftObjectPath& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwDebugFunctionLibrary", "GetWorldSize");

	Params::IgwDebugFunctionLibrary_GetWorldSize Parms{};

	Parms.WorldContext = WorldContext;
	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.Conv_PartitionDefinitionToInt64
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FPartitionDefinition&      Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UIgwFunctionLibrary::Conv_PartitionDefinitionToInt64(const struct FPartitionDefinition& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "Conv_PartitionDefinitionToInt64");

	Params::IgwFunctionLibrary_Conv_PartitionDefinitionToInt64 Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.Conv_PartitionDefinitionToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FPartitionDefinition&      Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UIgwFunctionLibrary::Conv_PartitionDefinitionToString(const struct FPartitionDefinition& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "Conv_PartitionDefinitionToString");

	Params::IgwFunctionLibrary_Conv_PartitionDefinitionToString Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetActorComponentFromIgwActorComponentPointer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FIgwActorComponentPointer& Ptr                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UIgwFunctionLibrary::GetActorComponentFromIgwActorComponentPointer(const struct FIgwActorComponentPointer& Ptr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetActorComponentFromIgwActorComponentPointer");

	Params::IgwFunctionLibrary_GetActorComponentFromIgwActorComponentPointer Parms{};

	Parms.Ptr = std::move(Ptr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetActorFromIgwActorPointer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FIgwActorPointer&          Ptr                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UIgwFunctionLibrary::GetActorFromIgwActorPointer(const struct FIgwActorPointer& Ptr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetActorFromIgwActorPointer");

	Params::IgwFunctionLibrary_GetActorFromIgwActorPointer Parms{};

	Parms.Ptr = std::move(Ptr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetActorServerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FServerID                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FServerID UIgwFunctionLibrary::GetActorServerID(const class UObject* WorldContext, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetActorServerID");

	Params::IgwFunctionLibrary_GetActorServerID Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetActorServerIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIgwFunctionLibrary::GetActorServerIndex(const class UObject* WorldContext, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetActorServerIndex");

	Params::IgwFunctionLibrary_GetActorServerIndex Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetC2SState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutLatency                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          OutLastError                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwFunctionLibrary::GetC2SState(const class UObject* WorldContext, const struct FServerID& ServerID, int32* OutLatency, class FString* OutLastError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetC2SState");

	Params::IgwFunctionLibrary_GetC2SState Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLatency != nullptr)
		*OutLatency = Parms.OutLatency;

	if (OutLastError != nullptr)
		*OutLastError = std::move(Parms.OutLastError);
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetClientControllerForActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AS2sController*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AS2sController* UIgwFunctionLibrary::GetClientControllerForActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetClientControllerForActor");

	Params::IgwFunctionLibrary_GetClientControllerForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetCurrentServerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FServerID                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FServerID UIgwFunctionLibrary::GetCurrentServerID(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetCurrentServerID");

	Params::IgwFunctionLibrary_GetCurrentServerID Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetPlayerAbsoluteLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UIgwFunctionLibrary::GetPlayerAbsoluteLocation(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetPlayerAbsoluteLocation");

	Params::IgwFunctionLibrary_GetPlayerAbsoluteLocation Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetServerColor
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateColor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateColor UIgwFunctionLibrary::GetServerColor(const class UObject* WorldContext, const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetServerColor");

	Params::IgwFunctionLibrary_GetServerColor Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetServerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FServerID                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FServerID UIgwFunctionLibrary::GetServerID(const class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetServerID");

	Params::IgwFunctionLibrary_GetServerID Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.GetServerIDFromLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutIsOwnServer                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FServerID                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FServerID UIgwFunctionLibrary::GetServerIDFromLocation(const class UObject* WorldContext, const struct FVector& LocalLocation, bool* bOutIsOwnServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "GetServerIDFromLocation");

	Params::IgwFunctionLibrary_GetServerIDFromLocation Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LocalLocation = std::move(LocalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutIsOwnServer != nullptr)
		*bOutIsOwnServer = Parms.bOutIsOwnServer;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.IsActorWithinServerBoundaries
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIgwFunctionLibrary::IsActorWithinServerBoundaries(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "IsActorWithinServerBoundaries");

	Params::IgwFunctionLibrary_IsActorWithinServerBoundaries Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.IsLocationWithinServerBoundaries
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContext                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIgwFunctionLibrary::IsLocationWithinServerBoundaries(const class UObject* WorldContext, const struct FVector& LocalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "IsLocationWithinServerBoundaries");

	Params::IgwFunctionLibrary_IsLocationWithinServerBoundaries Parms{};

	Parms.WorldContext = WorldContext;
	Parms.LocalLocation = std::move(LocalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.MakeActorGlobalID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActorGlobalID                   ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActorGlobalID UIgwFunctionLibrary::MakeActorGlobalID(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "MakeActorGlobalID");

	Params::IgwFunctionLibrary_MakeActorGlobalID Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.MakeIgwActorComponentPointer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UActorComponent*                  Ptr                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIgwActorComponentPointer        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FIgwActorComponentPointer UIgwFunctionLibrary::MakeIgwActorComponentPointer(class UActorComponent* Ptr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "MakeIgwActorComponentPointer");

	Params::IgwFunctionLibrary_MakeIgwActorComponentPointer Parms{};

	Parms.Ptr = Ptr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwFunctionLibrary.MakeIgwActorPointer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Ptr                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIgwActorPointer                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FIgwActorPointer UIgwFunctionLibrary::MakeIgwActorPointer(class AActor* Ptr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IgwFunctionLibrary", "MakeIgwActorPointer");

	Params::IgwFunctionLibrary_MakeIgwActorPointer Parms{};

	Parms.Ptr = Ptr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwLevelScriptActor.ReceiveLevelGainsAuthority
// (Event, Public, BlueprintEvent)

void AIgwLevelScriptActor::ReceiveLevelGainsAuthority()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwLevelScriptActor", "ReceiveLevelGainsAuthority");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InfiniteGameWorlds.IgwLevelScriptActor.ReceiveLevelLosesAuthority
// (Event, Public, BlueprintEvent)

void AIgwLevelScriptActor::ReceiveLevelLosesAuthority()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwLevelScriptActor", "ReceiveLevelLosesAuthority");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InfiniteGameWorlds.IgwObject.ClientFlushAuthorityTransfer
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FActorStatePacket&         StatePacket                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UIgwObject::ClientFlushAuthorityTransfer(const struct FActorStatePacket& StatePacket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwObject", "ClientFlushAuthorityTransfer");

	Params::IgwObject_ClientFlushAuthorityTransfer Parms{};

	Parms.StatePacket = std::move(StatePacket);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwObject.ClientForceReplication
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UIgwObject::ClientForceReplication()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwObject", "ClientForceReplication");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwObject.MulticastTransferringTo
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwObject::MulticastTransferringTo(const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwObject", "MulticastTransferringTo");

	Params::IgwObject_MulticastTransferringTo Parms{};

	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwObject.OnRep_Servers
// (Final, Native, Protected)

void UIgwObject::OnRep_Servers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwObject", "OnRep_Servers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwObject.ServerAddServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwObject::ServerAddServer(const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwObject", "ServerAddServer");

	Params::IgwObject_ServerAddServer Parms{};

	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwObject.ServerRemoveServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FServerID&                 ServerID                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwObject::ServerRemoveServer(const struct FServerID& ServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwObject", "ServerRemoveServer");

	Params::IgwObject_ServerRemoveServer Parms{};

	Parms.ServerID = std::move(ServerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.Disconnected
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UIgwServerConnectionComponent::Disconnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "Disconnected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.GetServers
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UIgwServerConnectionComponent::GetServers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "GetServers");

	Params::IgwServerConnectionComponent_GetServers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.GetWorldOffset
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UIgwServerConnectionComponent::GetWorldOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "GetWorldOffset");

	Params::IgwServerConnectionComponent_GetWorldOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.OnRep_CurrentWorldOffset
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   OldOffset                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerConnectionComponent::OnRep_CurrentWorldOffset(const struct FVector& OldOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "OnRep_CurrentWorldOffset");

	Params::IgwServerConnectionComponent_OnRep_CurrentWorldOffset Parms{};

	Parms.OldOffset = std::move(OldOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.OnRep_ServerCPU
// (Final, Native, Public)

void UIgwServerConnectionComponent::OnRep_ServerCPU()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "OnRep_ServerCPU");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.OnRep_ServerFPS
// (Final, Native, Public)

void UIgwServerConnectionComponent::OnRep_ServerFPS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "OnRep_ServerFPS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.OnRep_ServerGridLevelMap
// (Final, Native, Private)

void UIgwServerConnectionComponent::OnRep_ServerGridLevelMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "OnRep_ServerGridLevelMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.OnRep_Servers
// (Final, Native, Private)

void UIgwServerConnectionComponent::OnRep_Servers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "OnRep_Servers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.IgwServerConnectionComponent.ServerSetDebugLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIgwServerConnectionComponent::ServerSetDebugLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IgwServerConnectionComponent", "ServerSetDebugLevel");

	Params::IgwServerConnectionComponent_ServerSetDebugLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function InfiniteGameWorlds.ServerDebugInfo.OnRep_ServerDebugData
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FServerDebugData&          OldData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UServerDebugInfo::OnRep_ServerDebugData(const struct FServerDebugData& OldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerDebugInfo", "OnRep_ServerDebugData");

	Params::ServerDebugInfo_OnRep_ServerDebugData Parms{};

	Parms.OldData = std::move(OldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}


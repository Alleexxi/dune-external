#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mercuna

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Mercuna_structs.hpp"
#include "PhysicsCore_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class Mercuna.MercunaOctreeClampToNavigableProxy
// 0x0048 (0x0080 - 0x0038)
class UMercunaOctreeClampToNavigableProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FVector& ClampedPosition)> OnSuccess;                 // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& ClampedPosition)> OnFailure;                 // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaOctreeClampToNavigableProxy* ClampToNavigable(class UObject* WorldContextObject_0, const struct FVector& position, float NavigationRadius, float SearchRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaOctreeClampToNavigableProxy">();
	}
	static class UMercunaOctreeClampToNavigableProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaOctreeClampToNavigableProxy>();
	}
};
static_assert(alignof(UMercunaOctreeClampToNavigableProxy) == 0x000008, "Wrong alignment on UMercunaOctreeClampToNavigableProxy");
static_assert(sizeof(UMercunaOctreeClampToNavigableProxy) == 0x000080, "Wrong size on UMercunaOctreeClampToNavigableProxy");
static_assert(offsetof(UMercunaOctreeClampToNavigableProxy, OnSuccess) == 0x000038, "Member 'UMercunaOctreeClampToNavigableProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeClampToNavigableProxy, OnFailure) == 0x000048, "Member 'UMercunaOctreeClampToNavigableProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeClampToNavigableProxy, WorldContextObject) == 0x000058, "Member 'UMercunaOctreeClampToNavigableProxy::WorldContextObject' has a wrong offset!");

// Class Mercuna.MercunaBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UMercunaBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearDebugActor();
	static void MercunaFlushLog();
	static void MercunaLog(const class FString& Message);
	static void SetDebugActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaBlueprintLibrary">();
	}
	static class UMercunaBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaBlueprintLibrary>();
	}
};
static_assert(alignof(UMercunaBlueprintLibrary) == 0x000008, "Wrong alignment on UMercunaBlueprintLibrary");
static_assert(sizeof(UMercunaBlueprintLibrary) == 0x000030, "Wrong size on UMercunaBlueprintLibrary");

// Class Mercuna.MercunaNavModifierVolume
// 0x0048 (0x0398 - 0x0350)
class AMercunaNavModifierVolume final : public AActor
{
public:
	TSoftObjectPtr<class AMercunaNavGraph>        NavGraph;                                          // 0x0350(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnabled;                                          // 0x0388(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostMultiplier;                                    // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMercunaNavUsageTypes                  UsageTypes;                                        // 0x0390(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToGraph(class AMercunaNavGraph* NavGraph_0);
	void RemoveFromGraph();
	void SetCostMultiplier(float NewCostMultiplier);
	void SetEnabled(bool Enabled);
	void SetSize(const struct FVector& Size);
	void SetUsageTypes(const struct FMercunaNavUsageTypes& NewUsageTypes);

	struct FVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavModifierVolume">();
	}
	static class AMercunaNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavModifierVolume>();
	}
};
static_assert(alignof(AMercunaNavModifierVolume) == 0x000008, "Wrong alignment on AMercunaNavModifierVolume");
static_assert(sizeof(AMercunaNavModifierVolume) == 0x000398, "Wrong size on AMercunaNavModifierVolume");
static_assert(offsetof(AMercunaNavModifierVolume, NavGraph) == 0x000350, "Member 'AMercunaNavModifierVolume::NavGraph' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, VolumeComponent) == 0x000380, "Member 'AMercunaNavModifierVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, bEnabled) == 0x000388, "Member 'AMercunaNavModifierVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, CostMultiplier) == 0x00038C, "Member 'AMercunaNavModifierVolume::CostMultiplier' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, UsageTypes) == 0x000390, "Member 'AMercunaNavModifierVolume::UsageTypes' has a wrong offset!");

// Class Mercuna.MercunaNavigationComponent
// 0x0108 (0x0230 - 0x0128)
class alignas(0x10) UMercunaNavigationComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FAIRequestID& RequestID, const EMercunaMoveResult Result)> OnMoveCompleted; // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x4C];                                     // 0x0138(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	EMercunaAvoidanceMode                         AvoidanceMode;                                     // 0x0184(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaContextualSteeringActorParameters DefaultContextSteeringParameters;               // 0x0188(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AActor>, struct FMercunaContextualSteeringActorParameters> ContextSteeringParameters; // 0x0198(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          DynamicAvoidance;                                  // 0x01E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvoidanceWeightMultiplier;                         // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMercunaPawnUsageFlags                 UsageFlags;                                        // 0x01F0(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x30];                                     // 0x01F8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            CurrentController;                                 // 0x0228(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavigationComponent">();
	}
	static class UMercunaNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavigationComponent>();
	}
};
static_assert(alignof(UMercunaNavigationComponent) == 0x000010, "Wrong alignment on UMercunaNavigationComponent");
static_assert(sizeof(UMercunaNavigationComponent) == 0x000230, "Wrong size on UMercunaNavigationComponent");
static_assert(offsetof(UMercunaNavigationComponent, OnMoveCompleted) == 0x000128, "Member 'UMercunaNavigationComponent::OnMoveCompleted' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, AvoidanceMode) == 0x000184, "Member 'UMercunaNavigationComponent::AvoidanceMode' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, DefaultContextSteeringParameters) == 0x000188, "Member 'UMercunaNavigationComponent::DefaultContextSteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, ContextSteeringParameters) == 0x000198, "Member 'UMercunaNavigationComponent::ContextSteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, DynamicAvoidance) == 0x0001E8, "Member 'UMercunaNavigationComponent::DynamicAvoidance' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, AvoidanceWeightMultiplier) == 0x0001EC, "Member 'UMercunaNavigationComponent::AvoidanceWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, UsageFlags) == 0x0001F0, "Member 'UMercunaNavigationComponent::UsageFlags' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, CurrentController) == 0x000228, "Member 'UMercunaNavigationComponent::CurrentController' has a wrong offset!");

// Class Mercuna.MercunaNavGraph
// 0x0190 (0x04E0 - 0x0350)
class AMercunaNavGraph : public AActor
{
public:
	float                                         CellSize;                                          // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             GeometryCollisionChannel;                          // 0x0354(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverSave;                                        // 0x0355(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNavGraphMerging;                             // 0x0356(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePartitionOfNavData;                        // 0x0357(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             GenerationBoxesPerChunk;                           // 0x0358(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0xC];                                      // 0x0364(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBuildAsSublevel;                                  // 0x0370(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingChunks;                                      // 0x0371(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsRebuild;                                     // 0x0372(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_373[0xD];                                      // 0x0373(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BuildTransform;                                    // 0x0380(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0xF8];                                     // 0x03E0(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMerNavGraphRenderingComponent*         MerNavGraphRenderingComponent;                     // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SaveToFile(const class FString& Filename) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavGraph">();
	}
	static class AMercunaNavGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavGraph>();
	}
};
static_assert(alignof(AMercunaNavGraph) == 0x000010, "Wrong alignment on AMercunaNavGraph");
static_assert(sizeof(AMercunaNavGraph) == 0x0004E0, "Wrong size on AMercunaNavGraph");
static_assert(offsetof(AMercunaNavGraph, CellSize) == 0x000350, "Member 'AMercunaNavGraph::CellSize' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, GeometryCollisionChannel) == 0x000354, "Member 'AMercunaNavGraph::GeometryCollisionChannel' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bNeverSave) == 0x000355, "Member 'AMercunaNavGraph::bNeverSave' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bAllowNavGraphMerging) == 0x000356, "Member 'AMercunaNavGraph::bAllowNavGraphMerging' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bDisablePartitionOfNavData) == 0x000357, "Member 'AMercunaNavGraph::bDisablePartitionOfNavData' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, GenerationBoxesPerChunk) == 0x000358, "Member 'AMercunaNavGraph::GenerationBoxesPerChunk' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bBuildAsSublevel) == 0x000370, "Member 'AMercunaNavGraph::bBuildAsSublevel' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bUsingChunks) == 0x000371, "Member 'AMercunaNavGraph::bUsingChunks' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bNeedsRebuild) == 0x000372, "Member 'AMercunaNavGraph::bNeedsRebuild' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, BuildTransform) == 0x000380, "Member 'AMercunaNavGraph::BuildTransform' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, MerNavGraphRenderingComponent) == 0x0004D8, "Member 'AMercunaNavGraph::MerNavGraphRenderingComponent' has a wrong offset!");

// Class Mercuna.MercunaNavOctree
// 0x0090 (0x0570 - 0x04E0)
class AMercunaNavOctree final : public AMercunaNavGraph
{
public:
	int32                                         MinPawnRadius;                                     // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPawnRadius;                                     // 0x04E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictToSurfaces;                               // 0x04E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordOctreeDeltas;                               // 0x04E9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EA[0x6];                                      // 0x04EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Success)>  OnBuildLowResReady;                                // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success)>  OnBuildComplete;                                   // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* Volume, bool Success)> OnRebuildComplete;      // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* Volume, bool Success)> OnRebuildLowResReady;   // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadComplete;                                    // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnShortRangeLoadComplete;                          // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBox& Bounds)> OnChunkAdded;                          // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	EMerOctreeDebugDrawMode                       DebugDrawMode;                                     // 0x0560(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_561[0xF];                                      // 0x0561(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Build(const TArray<struct FVector>& PriorityPositions);
	void ClampToNavigable(const struct FVector& position, float NavigationRadius, float SearchRadius, struct FVector* ClampedPosition, bool* Result);
	class UMercunaPath* FindPathToActor(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, class AActor* GoalActor, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty);
	class UMercunaPath* FindPathToLocation(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& End, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty);
	class UMercunaPath* FindPathToLocations(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const TArray<struct FVector>& Destinations, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty);
	class UMercunaSmoothPath* FindSmoothPathToLocation(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& End, float NavigationRadius, float MaxSpeed, float MaxAcceleration, bool AllowPartial, float MaxPathLength);
	class UMercunaSmoothPath* FindSmoothPathToLocations(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const TArray<struct FVector>& Destinations, float NavigationRadius, float MaxSpeed, float MaxAcceleration, bool AllowPartial, float MaxPathLength);
	void IsNavigable(const struct FVector& position, float NavigationRadius, bool* Result);
	void IsNavigableMulti(const TArray<struct FVector>& Positions, float NavigationRadius, TArray<bool>* Results);
	bool IsReachable(const struct FVector& Start, const struct FVector& End, float NavigationRadius, float MaxPathLength);
	void IsReachableLatent(const struct FVector& Start, const TArray<struct FVector>& EndPos, float NavigationRadius, TArray<bool>* Result, TArray<struct FVector>* ClampedPos, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, bool AccuratePathLength, float StartSearchRadius, float EndSearchRadius);
	void Raycast(const struct FVector& Start, const struct FVector& End, float NavigationRadius, struct FVector* HitPosition, bool* RayHit);
	void RebuildChanges(bool StagedBuild, bool RemoveUnseeded);
	void RebuildVolume(const class AActor* Volume, bool StagedBuild, bool RemoveUnseeded);
	void RebuildVolumes(const TArray<struct FBox>& Volumes, bool bStagedBuild, bool bRemoveUnseeded, bool bMergeVolumes);
	void SetNavigationRotation(const struct FRotator& Rotation);

	bool IsBuilding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavOctree">();
	}
	static class AMercunaNavOctree* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavOctree>();
	}
};
static_assert(alignof(AMercunaNavOctree) == 0x000010, "Wrong alignment on AMercunaNavOctree");
static_assert(sizeof(AMercunaNavOctree) == 0x000570, "Wrong size on AMercunaNavOctree");
static_assert(offsetof(AMercunaNavOctree, MinPawnRadius) == 0x0004E0, "Member 'AMercunaNavOctree::MinPawnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, MaxPawnRadius) == 0x0004E4, "Member 'AMercunaNavOctree::MaxPawnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, bRestrictToSurfaces) == 0x0004E8, "Member 'AMercunaNavOctree::bRestrictToSurfaces' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, bRecordOctreeDeltas) == 0x0004E9, "Member 'AMercunaNavOctree::bRecordOctreeDeltas' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnBuildLowResReady) == 0x0004F0, "Member 'AMercunaNavOctree::OnBuildLowResReady' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnBuildComplete) == 0x000500, "Member 'AMercunaNavOctree::OnBuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnRebuildComplete) == 0x000510, "Member 'AMercunaNavOctree::OnRebuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnRebuildLowResReady) == 0x000520, "Member 'AMercunaNavOctree::OnRebuildLowResReady' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnLoadComplete) == 0x000530, "Member 'AMercunaNavOctree::OnLoadComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnShortRangeLoadComplete) == 0x000540, "Member 'AMercunaNavOctree::OnShortRangeLoadComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnChunkAdded) == 0x000550, "Member 'AMercunaNavOctree::OnChunkAdded' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, DebugDrawMode) == 0x000560, "Member 'AMercunaNavOctree::DebugDrawMode' has a wrong offset!");

// Class Mercuna.Mercuna2DNavigationComponent
// 0x00A0 (0x02D0 - 0x0230)
#pragma pack(push, 0x1)
class alignas(0x10) UMercuna2DNavigationComponent : public UMercunaNavigationComponent
{
public:
	TMulticastInlineDelegate<void(const struct FVector& StartPosition, const struct FVector& EndPosition, const struct FVector& SuggestedLaunchVelocity)> OnJumpStarted; // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UActorComponent*                        MovementComponent;                                 // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x80];                                     // 0x0248(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna2DNavigationComponent">();
	}
	static class UMercuna2DNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna2DNavigationComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMercuna2DNavigationComponent) == 0x000010, "Wrong alignment on UMercuna2DNavigationComponent");
static_assert(sizeof(UMercuna2DNavigationComponent) == 0x0002D0, "Wrong size on UMercuna2DNavigationComponent");
static_assert(offsetof(UMercuna2DNavigationComponent, OnJumpStarted) == 0x000230, "Member 'UMercuna2DNavigationComponent::OnJumpStarted' has a wrong offset!");
static_assert(offsetof(UMercuna2DNavigationComponent, MovementComponent) == 0x000240, "Member 'UMercuna2DNavigationComponent::MovementComponent' has a wrong offset!");

// Class Mercuna.MercunaVolumeComponent
// 0x0060 (0x0690 - 0x0630)
#pragma pack(push, 0x1)
class alignas(0x10) UMercunaVolumeComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_630[0x40];                                     // 0x0630(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Size;                                              // 0x0670(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaVolumeComponent">();
	}
	static class UMercunaVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaVolumeComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMercunaVolumeComponent) == 0x000010, "Wrong alignment on UMercunaVolumeComponent");
static_assert(sizeof(UMercunaVolumeComponent) == 0x000690, "Wrong size on UMercunaVolumeComponent");
static_assert(offsetof(UMercunaVolumeComponent, Size) == 0x000670, "Member 'UMercunaVolumeComponent::Size' has a wrong offset!");

// Class Mercuna.MercunaNavModifierComponent
// 0x0010 (0x06A0 - 0x0690)
#pragma pack(push, 0x1)
class alignas(0x10) UMercunaNavModifierComponent : public UMercunaVolumeComponent
{
public:
	bool                                          bEnabled;                                          // 0x0688(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_689[0x3];                                      // 0x0689(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaModifier                       Modifier;                                          // 0x068C(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCostMultiplier(float NewCostMultiplier);
	void SetEnabled(bool Enabled);
	void SetSize(const struct FVector& NewSize);
	void SetUsageTypes(const struct FMercunaNavUsageTypes& NewUsageTypes);

	struct FVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavModifierComponent">();
	}
	static class UMercunaNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavModifierComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMercunaNavModifierComponent) == 0x000010, "Wrong alignment on UMercunaNavModifierComponent");
static_assert(sizeof(UMercunaNavModifierComponent) == 0x0006A0, "Wrong size on UMercunaNavModifierComponent");
static_assert(offsetof(UMercunaNavModifierComponent, bEnabled) == 0x000688, "Member 'UMercunaNavModifierComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UMercunaNavModifierComponent, Modifier) == 0x00068C, "Member 'UMercunaNavModifierComponent::Modifier' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeModifierComponent
// 0x0030 (0x06D0 - 0x06A0)
class UMercunaNavOctreeModifierComponent final : public UMercunaNavModifierComponent
{
public:
	TSoftObjectPtr<class AMercunaNavOctree>       NavOctree;                                         // 0x0698(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x8];                                      // 0x06C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToOctree(class AMercunaNavOctree* NewNavOctree);
	void RemoveFromOctree();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavOctreeModifierComponent">();
	}
	static class UMercunaNavOctreeModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavOctreeModifierComponent>();
	}
};
static_assert(alignof(UMercunaNavOctreeModifierComponent) == 0x000010, "Wrong alignment on UMercunaNavOctreeModifierComponent");
static_assert(sizeof(UMercunaNavOctreeModifierComponent) == 0x0006D0, "Wrong size on UMercunaNavOctreeModifierComponent");
static_assert(offsetof(UMercunaNavOctreeModifierComponent, NavOctree) == 0x000698, "Member 'UMercunaNavOctreeModifierComponent::NavOctree' has a wrong offset!");

// Class Mercuna.Mercuna3DNavigationComponent
// 0x0080 (0x02B0 - 0x0230)
class UMercuna3DNavigationComponent final : public UMercunaNavigationComponent
{
public:
	struct FMercuna3DNavigationConfiguration      configuration;                                     // 0x0230(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavOctree*                      NavOctree;                                         // 0x0250(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticRadius;                                  // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationRadius;                                  // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Pathfinding;                                       // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x4F];                                     // 0x0261(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDestinationLocation(const struct FVector& NextDestination);
	void CancelLookAt();
	void CancelMovement();
	void ClearAvoidanceExclusions();
	void Configure(const struct FMercuna3DNavigationConfiguration& NewConfiguration);
	void ConfigureMovement(bool bUsePathfinding, EMercunaAvoidanceMode NewAvoidanceMode);
	void GetPathInfo(bool* Valid, float* DistanceToEnd);
	float GetRemainingPathLength();
	void InvalidateContextualSteeringParams();
	void InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor);
	void IsReachable(const struct FVector& Point, bool* Success, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void LookAlongAcceleration(float MaxPitch);
	void LookAt(class AActor* Actor, float MaxPitch);
	void LookInDirection(const struct FVector& Direction, float MaxPitch);
	void MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath);
	void MoveToLocation(const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath);
	void MoveToLocations(const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath);
	bool OverrideSpeedMultiplier(const float NewSpeedMultiplier);
	void PauseNavigation();
	void ResumeNavigation();
	void SetAvoidanceAgainst(class AActor* Actor, bool Enable);
	void SetNavOctree(class AMercunaNavOctree* NavOctree_0);
	void SetNavOctreeToBest();
	void SetUsageFlags(const struct FMercunaPawnUsageFlags& NewUsageFlags);
	void Stop();
	void TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset);

	class AMercunaNavOctree* GetNavOctree() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna3DNavigationComponent">();
	}
	static class UMercuna3DNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna3DNavigationComponent>();
	}
};
static_assert(alignof(UMercuna3DNavigationComponent) == 0x000010, "Wrong alignment on UMercuna3DNavigationComponent");
static_assert(sizeof(UMercuna3DNavigationComponent) == 0x0002B0, "Wrong size on UMercuna3DNavigationComponent");
static_assert(offsetof(UMercuna3DNavigationComponent, configuration) == 0x000230, "Member 'UMercuna3DNavigationComponent::configuration' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, NavOctree) == 0x000250, "Member 'UMercuna3DNavigationComponent::NavOctree' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, bAutomaticRadius) == 0x000258, "Member 'UMercuna3DNavigationComponent::bAutomaticRadius' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, NavigationRadius) == 0x00025C, "Member 'UMercuna3DNavigationComponent::NavigationRadius' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, Pathfinding) == 0x000260, "Member 'UMercuna3DNavigationComponent::Pathfinding' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeModifierVolume
// 0x0008 (0x0358 - 0x0350)
class AMercunaNavOctreeModifierVolume final : public AActor
{
public:
	class UMercunaNavOctreeModifierComponent*     VolumeComponent;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddToOctree(class AMercunaNavOctree* NavOctree);
	void RemoveFromOctree();
	void SetCostMultiplier(float NewCostMultiplier);
	void SetEnabled(bool Enabled);
	void SetSize(const struct FVector& Size);
	void SetUsageTypes(const struct FMercunaNavUsageTypes& NewUsageTypes);

	struct FVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavOctreeModifierVolume">();
	}
	static class AMercunaNavOctreeModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavOctreeModifierVolume>();
	}
};
static_assert(alignof(AMercunaNavOctreeModifierVolume) == 0x000008, "Wrong alignment on AMercunaNavOctreeModifierVolume");
static_assert(sizeof(AMercunaNavOctreeModifierVolume) == 0x000358, "Wrong size on AMercunaNavOctreeModifierVolume");
static_assert(offsetof(AMercunaNavOctreeModifierVolume, VolumeComponent) == 0x000350, "Member 'AMercunaNavOctreeModifierVolume::VolumeComponent' has a wrong offset!");

// Class Mercuna.Mercuna3DMoveToProxy
// 0x0070 (0x00A8 - 0x0038)
class UMercuna3DMoveToProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnSuccess;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x48];                                      // 0x0060(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercuna3DMoveToProxy* MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath);
	static class UMercuna3DMoveToProxy* MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath);
	static class UMercuna3DMoveToProxy* MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna3DMoveToProxy">();
	}
	static class UMercuna3DMoveToProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna3DMoveToProxy>();
	}
};
static_assert(alignof(UMercuna3DMoveToProxy) == 0x000008, "Wrong alignment on UMercuna3DMoveToProxy");
static_assert(sizeof(UMercuna3DMoveToProxy) == 0x0000A8, "Wrong size on UMercuna3DMoveToProxy");
static_assert(offsetof(UMercuna3DMoveToProxy, OnSuccess) == 0x000038, "Member 'UMercuna3DMoveToProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercuna3DMoveToProxy, OnFailure) == 0x000048, "Member 'UMercuna3DMoveToProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercuna3DMoveToProxy, Pawn) == 0x000058, "Member 'UMercuna3DMoveToProxy::Pawn' has a wrong offset!");

// Class Mercuna.BTDecorator_Mercuna3D_Reachable
// 0x0058 (0x00C8 - 0x0070)
class UBTDecorator_Mercuna3D_Reachable final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 Source;                                            // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 Destination;                                       // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MaxPathLength;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Mercuna3D_Reachable">();
	}
	static class UBTDecorator_Mercuna3D_Reachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Mercuna3D_Reachable>();
	}
};
static_assert(alignof(UBTDecorator_Mercuna3D_Reachable) == 0x000008, "Wrong alignment on UBTDecorator_Mercuna3D_Reachable");
static_assert(sizeof(UBTDecorator_Mercuna3D_Reachable) == 0x0000C8, "Wrong size on UBTDecorator_Mercuna3D_Reachable");
static_assert(offsetof(UBTDecorator_Mercuna3D_Reachable, Source) == 0x000070, "Member 'UBTDecorator_Mercuna3D_Reachable::Source' has a wrong offset!");
static_assert(offsetof(UBTDecorator_Mercuna3D_Reachable, Destination) == 0x000098, "Member 'UBTDecorator_Mercuna3D_Reachable::Destination' has a wrong offset!");
static_assert(offsetof(UBTDecorator_Mercuna3D_Reachable, MaxPathLength) == 0x0000C0, "Member 'UBTDecorator_Mercuna3D_Reachable::MaxPathLength' has a wrong offset!");

// Class Mercuna.MercunaNavTestingActor
// 0x0078 (0x03C8 - 0x0350)
class AMercunaNavTestingActor : public AActor
{
public:
	uint8                                         bSearchStart : 1;                                  // 0x0350(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaPawnUsageFlags                 UsageFlags;                                        // 0x0354(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPath;                                 // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bContinuouslyRepath : 1;                           // 0x0364(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRaycast : 1;                                      // 0x0364(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutomaticRepath;                                  // 0x0368(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PathStatus;                                        // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPathExist : 1;                                    // 0x0380(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathIsPartial : 1;                                // 0x0380(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathIsOutOfNodes : 1;                             // 0x0380(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathLength;                                        // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathSections;                                      // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathFindTime;                                      // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathNodesUsed;                                     // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathFindRepeats;                                   // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayAverageTime;                               // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMercunaPath*                           Path;                                              // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMercunaNavGraph*                       NavGraph;                                          // 0x03B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNavGraphBuildComplete(bool Success);
	void OnPathUpdate(EMercunaPathEvent PathEvent);
	void PathfindLatent(bool* Result, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool bAllowPartial);
	void Repath();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavTestingActor">();
	}
	static class AMercunaNavTestingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavTestingActor>();
	}
};
static_assert(alignof(AMercunaNavTestingActor) == 0x000008, "Wrong alignment on AMercunaNavTestingActor");
static_assert(sizeof(AMercunaNavTestingActor) == 0x0003C8, "Wrong size on AMercunaNavTestingActor");
static_assert(offsetof(AMercunaNavTestingActor, UsageFlags) == 0x000354, "Member 'AMercunaNavTestingActor::UsageFlags' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, MaxPathLength) == 0x00035C, "Member 'AMercunaNavTestingActor::MaxPathLength' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, bAllowPartialPath) == 0x000360, "Member 'AMercunaNavTestingActor::bAllowPartialPath' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, bAutomaticRepath) == 0x000368, "Member 'AMercunaNavTestingActor::bAutomaticRepath' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathStatus) == 0x000370, "Member 'AMercunaNavTestingActor::PathStatus' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathLength) == 0x000384, "Member 'AMercunaNavTestingActor::PathLength' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathSections) == 0x000388, "Member 'AMercunaNavTestingActor::PathSections' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathFindTime) == 0x00038C, "Member 'AMercunaNavTestingActor::PathFindTime' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathNodesUsed) == 0x000390, "Member 'AMercunaNavTestingActor::PathNodesUsed' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathFindRepeats) == 0x000394, "Member 'AMercunaNavTestingActor::PathFindRepeats' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, bDisplayAverageTime) == 0x000398, "Member 'AMercunaNavTestingActor::bDisplayAverageTime' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, SphereComponent) == 0x0003A0, "Member 'AMercunaNavTestingActor::SphereComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, Path) == 0x0003A8, "Member 'AMercunaNavTestingActor::Path' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, NavGraph) == 0x0003B0, "Member 'AMercunaNavTestingActor::NavGraph' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeTestingActor
// 0x0028 (0x03F0 - 0x03C8)
class AMercunaNavOctreeTestingActor final : public AMercunaNavTestingActor
{
public:
	class AMercunaNavOctreeTestingActor*          OtherActor;                                        // 0x03C8(0x0008)(Edit, ZeroConstructor, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightChangePenalty;                               // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPathUpdated;                                     // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavOctreeTestingActor">();
	}
	static class AMercunaNavOctreeTestingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavOctreeTestingActor>();
	}
};
static_assert(alignof(AMercunaNavOctreeTestingActor) == 0x000008, "Wrong alignment on AMercunaNavOctreeTestingActor");
static_assert(sizeof(AMercunaNavOctreeTestingActor) == 0x0003F0, "Wrong size on AMercunaNavOctreeTestingActor");
static_assert(offsetof(AMercunaNavOctreeTestingActor, OtherActor) == 0x0003C8, "Member 'AMercunaNavOctreeTestingActor::OtherActor' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, Radius) == 0x0003D0, "Member 'AMercunaNavOctreeTestingActor::Radius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, HeightChangePenalty) == 0x0003D4, "Member 'AMercunaNavOctreeTestingActor::HeightChangePenalty' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, MaxSpeed) == 0x0003D8, "Member 'AMercunaNavOctreeTestingActor::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, MaxAcceleration) == 0x0003DC, "Member 'AMercunaNavOctreeTestingActor::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, OnPathUpdated) == 0x0003E0, "Member 'AMercunaNavOctreeTestingActor::OnPathUpdated' has a wrong offset!");

// Class Mercuna.Mercuna3DTrackActorProxy
// 0x0048 (0x0080 - 0x0038)
class UMercuna3DTrackActorProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercuna3DTrackActorProxy* TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna3DTrackActorProxy">();
	}
	static class UMercuna3DTrackActorProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna3DTrackActorProxy>();
	}
};
static_assert(alignof(UMercuna3DTrackActorProxy) == 0x000008, "Wrong alignment on UMercuna3DTrackActorProxy");
static_assert(sizeof(UMercuna3DTrackActorProxy) == 0x000080, "Wrong size on UMercuna3DTrackActorProxy");
static_assert(offsetof(UMercuna3DTrackActorProxy, OnFailure) == 0x000038, "Member 'UMercuna3DTrackActorProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercuna3DTrackActorProxy, Pawn) == 0x000048, "Member 'UMercuna3DTrackActorProxy::Pawn' has a wrong offset!");

// Class Mercuna.MercunaObstacleComponent
// 0x0030 (0x0390 - 0x0360)
class UMercunaObstacleComponent final : public USceneComponent
{
public:
	bool                                          bAutomatic;                                        // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaObstacleType                          Type;                                              // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_362[0x2];                                      // 0x0362(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x0368(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderRadius;                                    // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderHeight;                                    // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaObstacleMovementType                  MovementType;                                      // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaObstacleReaction                      DefaultReaction;                                   // 0x0389(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCutOutWhenStationary;                             // 0x038A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38B[0x1];                                      // 0x038B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StationaryThresholdTime;                           // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCharacterMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void UpdateMovementType(const EMercunaObstacleMovementType& NewMovementType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaObstacleComponent">();
	}
	static class UMercunaObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaObstacleComponent>();
	}
};
static_assert(alignof(UMercunaObstacleComponent) == 0x000010, "Wrong alignment on UMercunaObstacleComponent");
static_assert(sizeof(UMercunaObstacleComponent) == 0x000390, "Wrong size on UMercunaObstacleComponent");
static_assert(offsetof(UMercunaObstacleComponent, bAutomatic) == 0x000360, "Member 'UMercunaObstacleComponent::bAutomatic' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, Type) == 0x000361, "Member 'UMercunaObstacleComponent::Type' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, SphereRadius) == 0x000364, "Member 'UMercunaObstacleComponent::SphereRadius' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, BoxSize) == 0x000368, "Member 'UMercunaObstacleComponent::BoxSize' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, CylinderRadius) == 0x000380, "Member 'UMercunaObstacleComponent::CylinderRadius' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, CylinderHeight) == 0x000384, "Member 'UMercunaObstacleComponent::CylinderHeight' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, MovementType) == 0x000388, "Member 'UMercunaObstacleComponent::MovementType' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, DefaultReaction) == 0x000389, "Member 'UMercunaObstacleComponent::DefaultReaction' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, bCutOutWhenStationary) == 0x00038A, "Member 'UMercunaObstacleComponent::bCutOutWhenStationary' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, StationaryThresholdTime) == 0x00038C, "Member 'UMercunaObstacleComponent::StationaryThresholdTime' has a wrong offset!");

// Class Mercuna.Mercuna3DTask_MoveTo
// 0x0098 (0x0110 - 0x0078)
class UMercuna3DTask_MoveTo final : public UAITask
{
public:
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EMercunaMoveResult Result, class AAIController* AIController)> OnMoveFinished; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x78];                                      // 0x0098(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercuna3DTask_MoveTo* MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna3DTask_MoveTo">();
	}
	static class UMercuna3DTask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna3DTask_MoveTo>();
	}
};
static_assert(alignof(UMercuna3DTask_MoveTo) == 0x000008, "Wrong alignment on UMercuna3DTask_MoveTo");
static_assert(sizeof(UMercuna3DTask_MoveTo) == 0x000110, "Wrong size on UMercuna3DTask_MoveTo");
static_assert(offsetof(UMercuna3DTask_MoveTo, OnRequestFailed) == 0x000078, "Member 'UMercuna3DTask_MoveTo::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UMercuna3DTask_MoveTo, OnMoveFinished) == 0x000088, "Member 'UMercuna3DTask_MoveTo::OnMoveFinished' has a wrong offset!");

// Class Mercuna.BTTask_Mercuna3D_MoveTo
// 0x0010 (0x00B0 - 0x00A0)
class UBTTask_Mercuna3D_MoveTo final : public UBTTask_BlackboardBase
{
public:
	float                                         Speed;                                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bObserveBlackboardValue : 1;                       // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialPath : 1;                             // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvoidTargetActor : 1;                             // 0x00A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Mercuna3D_MoveTo">();
	}
	static class UBTTask_Mercuna3D_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Mercuna3D_MoveTo>();
	}
};
static_assert(alignof(UBTTask_Mercuna3D_MoveTo) == 0x000008, "Wrong alignment on UBTTask_Mercuna3D_MoveTo");
static_assert(sizeof(UBTTask_Mercuna3D_MoveTo) == 0x0000B0, "Wrong size on UBTTask_Mercuna3D_MoveTo");
static_assert(offsetof(UBTTask_Mercuna3D_MoveTo, Speed) == 0x0000A0, "Member 'UBTTask_Mercuna3D_MoveTo::Speed' has a wrong offset!");
static_assert(offsetof(UBTTask_Mercuna3D_MoveTo, EndDistance) == 0x0000A4, "Member 'UBTTask_Mercuna3D_MoveTo::EndDistance' has a wrong offset!");

// Class Mercuna.BTTask_MercunaGround_MoveTo
// 0x0010 (0x00B0 - 0x00A0)
class UBTTask_MercunaGround_MoveTo : public UBTTask_BlackboardBase
{
public:
	float                                         Speed;                                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bObserveBlackboardValue : 1;                       // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialPath : 1;                             // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvoidTargetActor : 1;                             // 0x00A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MercunaGround_MoveTo">();
	}
	static class UBTTask_MercunaGround_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MercunaGround_MoveTo>();
	}
};
static_assert(alignof(UBTTask_MercunaGround_MoveTo) == 0x000008, "Wrong alignment on UBTTask_MercunaGround_MoveTo");
static_assert(sizeof(UBTTask_MercunaGround_MoveTo) == 0x0000B0, "Wrong size on UBTTask_MercunaGround_MoveTo");
static_assert(offsetof(UBTTask_MercunaGround_MoveTo, Speed) == 0x0000A0, "Member 'UBTTask_MercunaGround_MoveTo::Speed' has a wrong offset!");
static_assert(offsetof(UBTTask_MercunaGround_MoveTo, EndDistance) == 0x0000A4, "Member 'UBTTask_MercunaGround_MoveTo::EndDistance' has a wrong offset!");

// Class Mercuna.Mercuna2DQueryGenerator
// 0x0010 (0x0068 - 0x0058)
class UMercuna2DQueryGenerator : public UEnvQueryGenerator
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna2DQueryGenerator">();
	}
	static class UMercuna2DQueryGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna2DQueryGenerator>();
	}
};
static_assert(alignof(UMercuna2DQueryGenerator) == 0x000008, "Wrong alignment on UMercuna2DQueryGenerator");
static_assert(sizeof(UMercuna2DQueryGenerator) == 0x000068, "Wrong size on UMercuna2DQueryGenerator");
static_assert(offsetof(UMercuna2DQueryGenerator, AgentClass) == 0x000058, "Member 'UMercuna2DQueryGenerator::AgentClass' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_2DRandom
// 0x0078 (0x00E0 - 0x0068)
class UEnvQueryGenerator_Mercuna_2DRandom : public UMercuna2DQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              MaxDistance;                                       // 0x0068(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfPoints;                                    // 0x00A0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Centre;                                            // 0x00D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_2DRandom">();
	}
	static class UEnvQueryGenerator_Mercuna_2DRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_2DRandom>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_2DRandom) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_2DRandom");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_2DRandom) == 0x0000E0, "Wrong size on UEnvQueryGenerator_Mercuna_2DRandom");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DRandom, MaxDistance) == 0x000068, "Member 'UEnvQueryGenerator_Mercuna_2DRandom::MaxDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DRandom, NumberOfPoints) == 0x0000A0, "Member 'UEnvQueryGenerator_Mercuna_2DRandom::NumberOfPoints' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DRandom, Centre) == 0x0000D8, "Member 'UEnvQueryGenerator_Mercuna_2DRandom::Centre' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_2DNavGrid
// 0x00E8 (0x0150 - 0x0068)
class UEnvQueryGenerator_Mercuna_2DNavGrid : public UMercuna2DQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              MaxDistance;                                       // 0x0068(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               MaxDistanceIsPathDistance;                         // 0x00A0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x00D8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Centre;                                            // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               AlignPointsToCenter;                               // 0x0118(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_2DNavGrid">();
	}
	static class UEnvQueryGenerator_Mercuna_2DNavGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_2DNavGrid>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_2DNavGrid) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_2DNavGrid");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_2DNavGrid) == 0x000150, "Wrong size on UEnvQueryGenerator_Mercuna_2DNavGrid");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, MaxDistance) == 0x000068, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::MaxDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, MaxDistanceIsPathDistance) == 0x0000A0, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::MaxDistanceIsPathDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, SpaceBetween) == 0x0000D8, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, Centre) == 0x000110, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::Centre' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, AlignPointsToCenter) == 0x000118, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::AlignPointsToCenter' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_Sphere
// 0x00F0 (0x0148 - 0x0058)
class UEnvQueryGenerator_Mercuna_Sphere final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfShells;                                    // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                PointsPerShell;                                    // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EMercunaPointDistribution                     Distribution;                                      // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x0140(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_Sphere">();
	}
	static class UEnvQueryGenerator_Mercuna_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_Sphere>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_Sphere) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_Sphere");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_Sphere) == 0x000148, "Wrong size on UEnvQueryGenerator_Mercuna_Sphere");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, InnerRadius) == 0x000058, "Member 'UEnvQueryGenerator_Mercuna_Sphere::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, OuterRadius) == 0x000090, "Member 'UEnvQueryGenerator_Mercuna_Sphere::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, NumberOfShells) == 0x0000C8, "Member 'UEnvQueryGenerator_Mercuna_Sphere::NumberOfShells' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, PointsPerShell) == 0x000100, "Member 'UEnvQueryGenerator_Mercuna_Sphere::PointsPerShell' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, Distribution) == 0x000138, "Member 'UEnvQueryGenerator_Mercuna_Sphere::Distribution' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, Center) == 0x000140, "Member 'UEnvQueryGenerator_Mercuna_Sphere::Center' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_3DRing
// 0x0190 (0x01E8 - 0x0058)
class UEnvQueryGenerator_Mercuna_3DRing final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0058(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x0090(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfRings;                                     // 0x00C8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                PointsPerRing;                                     // 0x0100(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MinHeight;                                         // 0x0138(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxHeight;                                         // 0x0170(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfLayers;                                    // 0x01A8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x01E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_3DRing">();
	}
	static class UEnvQueryGenerator_Mercuna_3DRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_3DRing>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_3DRing) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_3DRing");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_3DRing) == 0x0001E8, "Wrong size on UEnvQueryGenerator_Mercuna_3DRing");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, InnerRadius) == 0x000058, "Member 'UEnvQueryGenerator_Mercuna_3DRing::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, OuterRadius) == 0x000090, "Member 'UEnvQueryGenerator_Mercuna_3DRing::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, NumberOfRings) == 0x0000C8, "Member 'UEnvQueryGenerator_Mercuna_3DRing::NumberOfRings' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, PointsPerRing) == 0x000100, "Member 'UEnvQueryGenerator_Mercuna_3DRing::PointsPerRing' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, MinHeight) == 0x000138, "Member 'UEnvQueryGenerator_Mercuna_3DRing::MinHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, MaxHeight) == 0x000170, "Member 'UEnvQueryGenerator_Mercuna_3DRing::MaxHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, NumberOfLayers) == 0x0001A8, "Member 'UEnvQueryGenerator_Mercuna_3DRing::NumberOfLayers' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, Center) == 0x0001E0, "Member 'UEnvQueryGenerator_Mercuna_3DRing::Center' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_GroundRandom
// 0x0008 (0x00E8 - 0x00E0)
class UEnvQueryGenerator_Mercuna_GroundRandom final : public UEnvQueryGenerator_Mercuna_2DRandom
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_GroundRandom">();
	}
	static class UEnvQueryGenerator_Mercuna_GroundRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_GroundRandom>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_GroundRandom) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_GroundRandom");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_GroundRandom) == 0x0000E8, "Wrong size on UEnvQueryGenerator_Mercuna_GroundRandom");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_GroundRandom, FollowNavLinks) == 0x0000E0, "Member 'UEnvQueryGenerator_Mercuna_GroundRandom::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_GroundNavGrid
// 0x0008 (0x0158 - 0x0150)
class UEnvQueryGenerator_Mercuna_GroundNavGrid final : public UEnvQueryGenerator_Mercuna_2DNavGrid
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_GroundNavGrid">();
	}
	static class UEnvQueryGenerator_Mercuna_GroundNavGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_GroundNavGrid>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_GroundNavGrid) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_GroundNavGrid");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_GroundNavGrid) == 0x000158, "Wrong size on UEnvQueryGenerator_Mercuna_GroundNavGrid");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_GroundNavGrid, FollowNavLinks) == 0x000150, "Member 'UEnvQueryGenerator_Mercuna_GroundNavGrid::FollowNavLinks' has a wrong offset!");

// Class Mercuna.Mercuna2DQueryTest
// 0x0008 (0x0278 - 0x0270)
class UMercuna2DQueryTest : public UEnvQueryTest
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna2DQueryTest">();
	}
	static class UMercuna2DQueryTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna2DQueryTest>();
	}
};
static_assert(alignof(UMercuna2DQueryTest) == 0x000008, "Wrong alignment on UMercuna2DQueryTest");
static_assert(sizeof(UMercuna2DQueryTest) == 0x000278, "Wrong size on UMercuna2DQueryTest");

// Class Mercuna.EnvQueryTest_Mercuna2D_Navigable
// 0x0008 (0x0280 - 0x0278)
class UEnvQueryTest_Mercuna2D_Navigable : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_Navigable">();
	}
	static class UEnvQueryTest_Mercuna2D_Navigable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_Navigable>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_Navigable) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_Navigable");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_Navigable) == 0x000280, "Wrong size on UEnvQueryTest_Mercuna2D_Navigable");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Navigable, AgentClass) == 0x000278, "Member 'UEnvQueryTest_Mercuna2D_Navigable::AgentClass' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_Reachable
// 0x0080 (0x02F8 - 0x0278)
class UEnvQueryTest_Mercuna2D_Reachable : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPathLength;                                     // 0x0280(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ClampDistance;                                     // 0x02B8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_Reachable">();
	}
	static class UEnvQueryTest_Mercuna2D_Reachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_Reachable) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_Reachable");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_Reachable) == 0x0002F8, "Wrong size on UEnvQueryTest_Mercuna2D_Reachable");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, AgentClass) == 0x000278, "Member 'UEnvQueryTest_Mercuna2D_Reachable::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, MaxPathLength) == 0x000280, "Member 'UEnvQueryTest_Mercuna2D_Reachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, ClampDistance) == 0x0002B8, "Member 'UEnvQueryTest_Mercuna2D_Reachable::ClampDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, Context) == 0x0002F0, "Member 'UEnvQueryTest_Mercuna2D_Reachable::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_PathLength
// 0x0080 (0x02F8 - 0x0278)
class UEnvQueryTest_Mercuna2D_PathLength : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPathDistance;                                   // 0x0280(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ClampDistance;                                     // 0x02B8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_PathLength">();
	}
	static class UEnvQueryTest_Mercuna2D_PathLength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_PathLength>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_PathLength) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_PathLength");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_PathLength) == 0x0002F8, "Wrong size on UEnvQueryTest_Mercuna2D_PathLength");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, AgentClass) == 0x000278, "Member 'UEnvQueryTest_Mercuna2D_PathLength::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, MaxPathDistance) == 0x000280, "Member 'UEnvQueryTest_Mercuna2D_PathLength::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, ClampDistance) == 0x0002B8, "Member 'UEnvQueryTest_Mercuna2D_PathLength::ClampDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, Context) == 0x0002F0, "Member 'UEnvQueryTest_Mercuna2D_PathLength::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_NavRaycast
// 0x0010 (0x0288 - 0x0278)
class UEnvQueryTest_Mercuna2D_NavRaycast : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_NavRaycast">();
	}
	static class UEnvQueryTest_Mercuna2D_NavRaycast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_NavRaycast) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_NavRaycast");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_NavRaycast) == 0x000288, "Wrong size on UEnvQueryTest_Mercuna2D_NavRaycast");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_NavRaycast, AgentClass) == 0x000278, "Member 'UEnvQueryTest_Mercuna2D_NavRaycast::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_NavRaycast, Context) == 0x000280, "Member 'UEnvQueryTest_Mercuna2D_NavRaycast::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_Project
// 0x0048 (0x02C0 - 0x0278)
class UEnvQueryTest_Mercuna2D_Project : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxProjectionDistance;                             // 0x0280(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EMercunaProjectionType                        ProjectionType;                                    // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_Project">();
	}
	static class UEnvQueryTest_Mercuna2D_Project* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_Project>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_Project) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_Project");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_Project) == 0x0002C0, "Wrong size on UEnvQueryTest_Mercuna2D_Project");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Project, AgentClass) == 0x000278, "Member 'UEnvQueryTest_Mercuna2D_Project::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Project, MaxProjectionDistance) == 0x000280, "Member 'UEnvQueryTest_Mercuna2D_Project::MaxProjectionDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Project, ProjectionType) == 0x0002B8, "Member 'UEnvQueryTest_Mercuna2D_Project::ProjectionType' has a wrong offset!");

// Class Mercuna.Mercuna3DQueryTest
// 0x0000 (0x0270 - 0x0270)
class UMercuna3DQueryTest : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mercuna3DQueryTest">();
	}
	static class UMercuna3DQueryTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercuna3DQueryTest>();
	}
};
static_assert(alignof(UMercuna3DQueryTest) == 0x000008, "Wrong alignment on UMercuna3DQueryTest");
static_assert(sizeof(UMercuna3DQueryTest) == 0x000270, "Wrong size on UMercuna3DQueryTest");

// Class Mercuna.EnvQueryTest_Mercuna3D_NavigableVolume
// 0x0000 (0x0270 - 0x0270)
class UEnvQueryTest_Mercuna3D_NavigableVolume final : public UMercuna3DQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_NavigableVolume">();
	}
	static class UEnvQueryTest_Mercuna3D_NavigableVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_NavigableVolume>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_NavigableVolume) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_NavigableVolume");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_NavigableVolume) == 0x000270, "Wrong size on UEnvQueryTest_Mercuna3D_NavigableVolume");

// Class Mercuna.EnvQueryTest_Mercuna3D_Reachable
// 0x0040 (0x02B0 - 0x0270)
class UEnvQueryTest_Mercuna3D_Reachable final : public UMercuna3DQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxPathLength;                                     // 0x0270(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_Reachable">();
	}
	static class UEnvQueryTest_Mercuna3D_Reachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_Reachable) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_Reachable");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_Reachable) == 0x0002B0, "Wrong size on UEnvQueryTest_Mercuna3D_Reachable");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_Reachable, MaxPathLength) == 0x000270, "Member 'UEnvQueryTest_Mercuna3D_Reachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_Reachable, Context) == 0x0002A8, "Member 'UEnvQueryTest_Mercuna3D_Reachable::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna3D_NavRaycast
// 0x0008 (0x0278 - 0x0270)
class UEnvQueryTest_Mercuna3D_NavRaycast final : public UMercuna3DQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_NavRaycast">();
	}
	static class UEnvQueryTest_Mercuna3D_NavRaycast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_NavRaycast) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_NavRaycast");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_NavRaycast) == 0x000278, "Wrong size on UEnvQueryTest_Mercuna3D_NavRaycast");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_NavRaycast, Context) == 0x000270, "Member 'UEnvQueryTest_Mercuna3D_NavRaycast::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna3D_Project
// 0x0038 (0x02A8 - 0x0270)
class UEnvQueryTest_Mercuna3D_Project final : public UMercuna3DQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxSearchRadius;                                   // 0x0270(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_Project">();
	}
	static class UEnvQueryTest_Mercuna3D_Project* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_Project>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_Project) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_Project");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_Project) == 0x0002A8, "Wrong size on UEnvQueryTest_Mercuna3D_Project");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_Project, MaxSearchRadius) == 0x000270, "Member 'UEnvQueryTest_Mercuna3D_Project::MaxSearchRadius' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaGround_Navigable
// 0x0000 (0x0280 - 0x0280)
class UEnvQueryTest_MercunaGround_Navigable final : public UEnvQueryTest_Mercuna2D_Navigable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_Navigable">();
	}
	static class UEnvQueryTest_MercunaGround_Navigable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_Navigable>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_Navigable) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_Navigable");
static_assert(sizeof(UEnvQueryTest_MercunaGround_Navigable) == 0x000280, "Wrong size on UEnvQueryTest_MercunaGround_Navigable");

// Class Mercuna.EnvQueryTest_MercunaGround_Reachable
// 0x0008 (0x0300 - 0x02F8)
class UEnvQueryTest_MercunaGround_Reachable final : public UEnvQueryTest_Mercuna2D_Reachable
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_Reachable">();
	}
	static class UEnvQueryTest_MercunaGround_Reachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_Reachable) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_Reachable");
static_assert(sizeof(UEnvQueryTest_MercunaGround_Reachable) == 0x000300, "Wrong size on UEnvQueryTest_MercunaGround_Reachable");
static_assert(offsetof(UEnvQueryTest_MercunaGround_Reachable, FollowNavLinks) == 0x0002F8, "Member 'UEnvQueryTest_MercunaGround_Reachable::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaGround_PathLength
// 0x0008 (0x0300 - 0x02F8)
class UEnvQueryTest_MercunaGround_PathLength final : public UEnvQueryTest_Mercuna2D_PathLength
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_PathLength">();
	}
	static class UEnvQueryTest_MercunaGround_PathLength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_PathLength>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_PathLength) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_PathLength");
static_assert(sizeof(UEnvQueryTest_MercunaGround_PathLength) == 0x000300, "Wrong size on UEnvQueryTest_MercunaGround_PathLength");
static_assert(offsetof(UEnvQueryTest_MercunaGround_PathLength, FollowNavLinks) == 0x0002F8, "Member 'UEnvQueryTest_MercunaGround_PathLength::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaGround_NavRaycast
// 0x0000 (0x0288 - 0x0288)
class UEnvQueryTest_MercunaGround_NavRaycast final : public UEnvQueryTest_Mercuna2D_NavRaycast
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_NavRaycast">();
	}
	static class UEnvQueryTest_MercunaGround_NavRaycast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_NavRaycast) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_NavRaycast");
static_assert(sizeof(UEnvQueryTest_MercunaGround_NavRaycast) == 0x000288, "Wrong size on UEnvQueryTest_MercunaGround_NavRaycast");

// Class Mercuna.EnvQueryTest_MercunaGround_Project
// 0x0000 (0x02C0 - 0x02C0)
class UEnvQueryTest_MercunaGround_Project final : public UEnvQueryTest_Mercuna2D_Project
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_Project">();
	}
	static class UEnvQueryTest_MercunaGround_Project* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_Project>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_Project) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_Project");
static_assert(sizeof(UEnvQueryTest_MercunaGround_Project) == 0x0002C0, "Wrong size on UEnvQueryTest_MercunaGround_Project");

// Class Mercuna.MercunaGroundMoveToProxy
// 0x0090 (0x00C8 - 0x0038)
class UMercunaGroundMoveToProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnSuccess;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x68];                                      // 0x0060(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaGroundMoveToProxy* MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath);
	static class UMercunaGroundMoveToProxy* MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection);
	static class UMercunaGroundMoveToProxy* MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaGroundMoveToProxy">();
	}
	static class UMercunaGroundMoveToProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaGroundMoveToProxy>();
	}
};
static_assert(alignof(UMercunaGroundMoveToProxy) == 0x000008, "Wrong alignment on UMercunaGroundMoveToProxy");
static_assert(sizeof(UMercunaGroundMoveToProxy) == 0x0000C8, "Wrong size on UMercunaGroundMoveToProxy");
static_assert(offsetof(UMercunaGroundMoveToProxy, OnSuccess) == 0x000038, "Member 'UMercunaGroundMoveToProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercunaGroundMoveToProxy, OnFailure) == 0x000048, "Member 'UMercunaGroundMoveToProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaGroundMoveToProxy, Pawn) == 0x000058, "Member 'UMercunaGroundMoveToProxy::Pawn' has a wrong offset!");

// Class Mercuna.MercunaGroundTrackActorProxy
// 0x0048 (0x0080 - 0x0038)
class UMercunaGroundTrackActorProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaGroundTrackActorProxy* TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaGroundTrackActorProxy">();
	}
	static class UMercunaGroundTrackActorProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaGroundTrackActorProxy>();
	}
};
static_assert(alignof(UMercunaGroundTrackActorProxy) == 0x000008, "Wrong alignment on UMercunaGroundTrackActorProxy");
static_assert(sizeof(UMercunaGroundTrackActorProxy) == 0x000080, "Wrong size on UMercunaGroundTrackActorProxy");
static_assert(offsetof(UMercunaGroundTrackActorProxy, OnFailure) == 0x000038, "Member 'UMercunaGroundTrackActorProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaGroundTrackActorProxy, Pawn) == 0x000048, "Member 'UMercunaGroundTrackActorProxy::Pawn' has a wrong offset!");

// Class Mercuna.MercunaGroundNavigationComponent
// 0x0060 (0x0330 - 0x02D0)
class UMercunaGroundNavigationComponent final : public UMercuna2DNavigationComponent
{
public:
	class AMercunaNavGroundGrid*                  NavGrid;                                           // 0x02C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMercunaGroundAgentType                AgentType;                                         // 0x02D0(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticSteeringParameters;                      // 0x02DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaGroundNavigationSteeringParameters SteeringParameters;                            // 0x02E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSetCharacterControllerRotation;                   // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaGroundNavigationConfiguration  configuration;                                     // 0x0304(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDestinationLocation(const struct FVector& NextDestination, bool bSmoothTransition);
	void CancelMovement();
	void ClearAvoidanceExclusions();
	void Configure(const struct FMercunaGroundNavigationConfiguration& NewConfiguration);
	void ConfigureMovement(EMercunaAvoidanceMode NewAvoidanceMode);
	void ConfigureSteering(const struct FMercunaGroundNavigationSteeringParameters& NewSteering);
	struct FVector GetLookDirection();
	void GetPathInfo(bool* Valid, float* DistanceToEnd);
	float GetRemainingPathLength();
	void InvalidateContextualSteeringParams();
	void InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor);
	void MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath);
	void MoveToLocation(const struct FVector& Destination, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath);
	void MoveToLocations(const TArray<struct FVector>& Destinations, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath);
	void NavLinkComplete();
	bool OverrideSpeedMultiplier(const float NewSpeedMultiplier);
	void PauseNavigation();
	void ResumeNavigation();
	void SetAgentType(const struct FMercunaGroundAgentType& NewAgentType);
	void SetAvoidanceAgainst(class AActor* Actor, bool Enable);
	void SetNavGrid(class AMercunaNavGroundGrid* NavGrid_0);
	void SetNavGridToBest();
	void SetUsageFlags(const struct FMercunaPawnUsageFlags& NewUsageFlags);
	void Stop();
	void TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath);
	void UpdateDynamicSteeringParams(const struct FMercunaGroundNavigationDynamicSteeringParameters& NewDynamicSteeringParams);

	struct FMercunaGroundNavigationConfiguration GetConfiguration() const;
	struct FMercunaGroundNavigationDynamicSteeringParameters GetDynamicSteeringParameters() const;
	struct FVector GetLastInputVector() const;
	class AMercunaNavGroundGrid* GetNavGrid() const;
	void GetNextNavLink(bool* bNextNavLinkFound, float* DistanceToNextNavLink, float* TimeToNextNavLink, struct FVector* TraversalStart, struct FVector* TraversalEnd, bool* bIsAutoGenerated, class AMercunaNavLink** NavLink, struct FMercunaAutoNavLink* AutoGeneratedNavLink, float MaxLookAhead) const;
	struct FMercunaGroundNavigationSteeringParameters GetSteeringParameters() const;
	EMerNavigationTrajectory GetTrajectory(struct FTrajectorySampleRange* TrajectorySampleRange, float LookAhead, int32 SampleRate, bool ReturnAbsoluteTimes) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaGroundNavigationComponent">();
	}
	static class UMercunaGroundNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaGroundNavigationComponent>();
	}
};
static_assert(alignof(UMercunaGroundNavigationComponent) == 0x000010, "Wrong alignment on UMercunaGroundNavigationComponent");
static_assert(sizeof(UMercunaGroundNavigationComponent) == 0x000330, "Wrong size on UMercunaGroundNavigationComponent");
static_assert(offsetof(UMercunaGroundNavigationComponent, NavGrid) == 0x0002C8, "Member 'UMercunaGroundNavigationComponent::NavGrid' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, AgentType) == 0x0002D0, "Member 'UMercunaGroundNavigationComponent::AgentType' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, bAutomaticSteeringParameters) == 0x0002DC, "Member 'UMercunaGroundNavigationComponent::bAutomaticSteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, SteeringParameters) == 0x0002E0, "Member 'UMercunaGroundNavigationComponent::SteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, bSetCharacterControllerRotation) == 0x000300, "Member 'UMercunaGroundNavigationComponent::bSetCharacterControllerRotation' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, configuration) == 0x000304, "Member 'UMercunaGroundNavigationComponent::configuration' has a wrong offset!");

// Class Mercuna.MercunaGroundNavInvokerComponent
// 0x00C0 (0x01E8 - 0x0128)
class UMercunaGroundNavInvokerComponent final : public UActorComponent
{
public:
	bool                                          bAutomatic;                                        // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGroundGrid*                  NavGrid;                                           // 0x0130(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaSupportedAgentTypes            AgentTypes;                                        // 0x0138(0x00A8)(Edit, NativeAccessSpecifierPublic)
	float                                         GenerationRadius;                                  // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemovalRadius;                                     // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaGroundNavInvokerComponent">();
	}
	static class UMercunaGroundNavInvokerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaGroundNavInvokerComponent>();
	}
};
static_assert(alignof(UMercunaGroundNavInvokerComponent) == 0x000008, "Wrong alignment on UMercunaGroundNavInvokerComponent");
static_assert(sizeof(UMercunaGroundNavInvokerComponent) == 0x0001E8, "Wrong size on UMercunaGroundNavInvokerComponent");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, bAutomatic) == 0x000128, "Member 'UMercunaGroundNavInvokerComponent::bAutomatic' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, NavGrid) == 0x000130, "Member 'UMercunaGroundNavInvokerComponent::NavGrid' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, AgentTypes) == 0x000138, "Member 'UMercunaGroundNavInvokerComponent::AgentTypes' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, GenerationRadius) == 0x0001E0, "Member 'UMercunaGroundNavInvokerComponent::GenerationRadius' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, RemovalRadius) == 0x0001E4, "Member 'UMercunaGroundNavInvokerComponent::RemovalRadius' has a wrong offset!");

// Class Mercuna.MercunaGroundTask_MoveTo
// 0x00A8 (0x0120 - 0x0078)
class UMercunaGroundTask_MoveTo : public UAITask
{
public:
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EMercunaMoveResult Result, class AAIController* AIController)> OnMoveFinished; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x88];                                      // 0x0098(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaGroundTask_MoveTo* MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic);

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaGroundTask_MoveTo">();
	}
	static class UMercunaGroundTask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaGroundTask_MoveTo>();
	}
};
static_assert(alignof(UMercunaGroundTask_MoveTo) == 0x000008, "Wrong alignment on UMercunaGroundTask_MoveTo");
static_assert(sizeof(UMercunaGroundTask_MoveTo) == 0x000120, "Wrong size on UMercunaGroundTask_MoveTo");
static_assert(offsetof(UMercunaGroundTask_MoveTo, OnRequestFailed) == 0x000078, "Member 'UMercunaGroundTask_MoveTo::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UMercunaGroundTask_MoveTo, OnMoveFinished) == 0x000088, "Member 'UMercunaGroundTask_MoveTo::OnMoveFinished' has a wrong offset!");

// Class Mercuna.MercunaNavExclusionVolume
// 0x0020 (0x0370 - 0x0350)
class AMercunaNavExclusionVolume final : public AActor
{
public:
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyToAllNavGraphs;                              // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGraph*                       NavGraph;                                          // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMercunaNavigationExclusionType               ExclusionType;                                     // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToAllGraphs();
	void AddToGraph(class AMercunaNavGraph* NavGraph_0);
	void RemoveFromGraphs();
	void SetSize(const struct FVector& Size);

	struct FVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavExclusionVolume">();
	}
	static class AMercunaNavExclusionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavExclusionVolume>();
	}
};
static_assert(alignof(AMercunaNavExclusionVolume) == 0x000008, "Wrong alignment on AMercunaNavExclusionVolume");
static_assert(sizeof(AMercunaNavExclusionVolume) == 0x000370, "Wrong size on AMercunaNavExclusionVolume");
static_assert(offsetof(AMercunaNavExclusionVolume, VolumeComponent) == 0x000350, "Member 'AMercunaNavExclusionVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavExclusionVolume, bApplyToAllNavGraphs) == 0x000358, "Member 'AMercunaNavExclusionVolume::bApplyToAllNavGraphs' has a wrong offset!");
static_assert(offsetof(AMercunaNavExclusionVolume, NavGraph) == 0x000360, "Member 'AMercunaNavExclusionVolume::NavGraph' has a wrong offset!");
static_assert(offsetof(AMercunaNavExclusionVolume, ExclusionType) == 0x000368, "Member 'AMercunaNavExclusionVolume::ExclusionType' has a wrong offset!");

// Class Mercuna.MercunaNavGraph2D
// 0x0190 (0x0670 - 0x04E0)
class AMercunaNavGraph2D : public AMercunaNavGraph
{
public:
	bool                                          bUsePhysicalMaterials;                             // 0x04E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPhysicalMaterial*>              PhysicalMaterialPriorities;                        // 0x04E8(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success)>  OnBuildComplete;                                   // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* Volume, bool Success)> OnRebuildComplete;      // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadComplete;                                    // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBox& Bounds)> OnChunkAdded;                          // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	struct FMercunaSupportedAgentTypes            SupportedAgentTypes;                               // 0x0538(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	bool                                          bUseNavSeeds;                                      // 0x05E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMerGridDebugDrawMode                         DebugDrawMode;                                     // 0x05E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMerGridDebugDrawSubmode                      DebugDrawSubmode;                                  // 0x05E2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E3[0x1];                                      // 0x05E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaAgentType                      DebugDrawAgentType;                                // 0x05E4(0x000C)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class AMercunaNavLink>> NavLinks;                                          // 0x05F0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint32                                        NextMaterialId;                                    // 0x0600(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPhysicalMaterial*, uint32>        SurfaceMaterials;                                  // 0x0608(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FVector                                NavLinkBorder;                                     // 0x0658(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavGraph2D">();
	}
	static class AMercunaNavGraph2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavGraph2D>();
	}
};
static_assert(alignof(AMercunaNavGraph2D) == 0x000010, "Wrong alignment on AMercunaNavGraph2D");
static_assert(sizeof(AMercunaNavGraph2D) == 0x000670, "Wrong size on AMercunaNavGraph2D");
static_assert(offsetof(AMercunaNavGraph2D, bUsePhysicalMaterials) == 0x0004E0, "Member 'AMercunaNavGraph2D::bUsePhysicalMaterials' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, PhysicalMaterialPriorities) == 0x0004E8, "Member 'AMercunaNavGraph2D::PhysicalMaterialPriorities' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnBuildComplete) == 0x0004F8, "Member 'AMercunaNavGraph2D::OnBuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnRebuildComplete) == 0x000508, "Member 'AMercunaNavGraph2D::OnRebuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnLoadComplete) == 0x000518, "Member 'AMercunaNavGraph2D::OnLoadComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnChunkAdded) == 0x000528, "Member 'AMercunaNavGraph2D::OnChunkAdded' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, SupportedAgentTypes) == 0x000538, "Member 'AMercunaNavGraph2D::SupportedAgentTypes' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, bUseNavSeeds) == 0x0005E0, "Member 'AMercunaNavGraph2D::bUseNavSeeds' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, DebugDrawMode) == 0x0005E1, "Member 'AMercunaNavGraph2D::DebugDrawMode' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, DebugDrawSubmode) == 0x0005E2, "Member 'AMercunaNavGraph2D::DebugDrawSubmode' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, DebugDrawAgentType) == 0x0005E4, "Member 'AMercunaNavGraph2D::DebugDrawAgentType' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, NavLinks) == 0x0005F0, "Member 'AMercunaNavGraph2D::NavLinks' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, NextMaterialId) == 0x000600, "Member 'AMercunaNavGraph2D::NextMaterialId' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, SurfaceMaterials) == 0x000608, "Member 'AMercunaNavGraph2D::SurfaceMaterials' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, NavLinkBorder) == 0x000658, "Member 'AMercunaNavGraph2D::NavLinkBorder' has a wrong offset!");

// Class Mercuna.MercunaNavGridModifierComponent
// 0x0090 (0x0730 - 0x06A0)
class UMercunaNavGridModifierComponent final : public UMercunaNavModifierComponent
{
public:
	TSoftObjectPtr<class AMercunaNavGraph2D>      NavGrid;                                           // 0x0698(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMercunaModifierVolumeShape                   Shape;                                             // 0x06C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C9[0x7];                                      // 0x06C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      PrismVertices;                                     // 0x06D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FMercunaAgentType, struct FMercunaModifier> PerAgentTypeModifiers;                   // 0x06E0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void AddToGrid(class AMercunaNavGraph2D* NewNavGrid);
	void OverrideCostMultiplier(const struct FMercunaAgentType& AgentType, float NewCostMultiplier);
	void OverrideUsageTypes(const struct FMercunaAgentType& AgentType, const struct FMercunaNavUsageTypes& NewUsageTypes);
	void RemoveFromGrid();
	void SetPrismVertices(const TArray<struct FVector2D>& NewVertices);
	void SetShape(EMercunaModifierVolumeShape NewShape);

	EMercunaModifierVolumeShape GetShape() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavGridModifierComponent">();
	}
	static class UMercunaNavGridModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavGridModifierComponent>();
	}
};
static_assert(alignof(UMercunaNavGridModifierComponent) == 0x000010, "Wrong alignment on UMercunaNavGridModifierComponent");
static_assert(sizeof(UMercunaNavGridModifierComponent) == 0x000730, "Wrong size on UMercunaNavGridModifierComponent");
static_assert(offsetof(UMercunaNavGridModifierComponent, NavGrid) == 0x000698, "Member 'UMercunaNavGridModifierComponent::NavGrid' has a wrong offset!");
static_assert(offsetof(UMercunaNavGridModifierComponent, Shape) == 0x0006C8, "Member 'UMercunaNavGridModifierComponent::Shape' has a wrong offset!");
static_assert(offsetof(UMercunaNavGridModifierComponent, PrismVertices) == 0x0006D0, "Member 'UMercunaNavGridModifierComponent::PrismVertices' has a wrong offset!");
static_assert(offsetof(UMercunaNavGridModifierComponent, PerAgentTypeModifiers) == 0x0006E0, "Member 'UMercunaNavGridModifierComponent::PerAgentTypeModifiers' has a wrong offset!");

// Class Mercuna.MercunaNavGridModifierVolume
// 0x0008 (0x0358 - 0x0350)
class AMercunaNavGridModifierVolume final : public AActor
{
public:
	class UMercunaNavGridModifierComponent*       VolumeComponent;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddToGrid(class AMercunaNavGraph2D* NavGrid);
	void OverrideCostMultiplier(const struct FMercunaAgentType& AgentType, float NewCostMultiplier);
	void OverrideUsageTypes(const struct FMercunaAgentType& AgentType, const struct FMercunaNavUsageTypes& NewUsageTypes);
	void RemoveFromGrid();
	void SetCostMultiplier(float NewCostMultiplier);
	void SetEnabled(bool Enabled);
	void SetPrismVertices(const TArray<struct FVector2D>& NewVertices);
	void SetShape(EMercunaModifierVolumeShape NewShape);
	void SetSize(const struct FVector& Size);
	void SetUsageTypes(const struct FMercunaNavUsageTypes& NewUsageTypes);

	EMercunaModifierVolumeShape GetShape() const;
	struct FVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavGridModifierVolume">();
	}
	static class AMercunaNavGridModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavGridModifierVolume>();
	}
};
static_assert(alignof(AMercunaNavGridModifierVolume) == 0x000008, "Wrong alignment on AMercunaNavGridModifierVolume");
static_assert(sizeof(AMercunaNavGridModifierVolume) == 0x000358, "Wrong size on AMercunaNavGridModifierVolume");
static_assert(offsetof(AMercunaNavGridModifierVolume, VolumeComponent) == 0x000350, "Member 'AMercunaNavGridModifierVolume::VolumeComponent' has a wrong offset!");

// Class Mercuna.MercunaNavGridTestingActor
// 0x0070 (0x0438 - 0x03C8)
class AMercunaNavGridTestingActor final : public AMercunaNavTestingActor
{
public:
	struct FMercunaAgentType                      AgentType;                                         // 0x03C8(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGridTestingActor*            OtherActor;                                        // 0x03D8(0x0008)(Edit, ZeroConstructor, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AMercunaNavGraph2D>      NavGrid;                                           // 0x03E0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTurnRadius;                                     // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopePenalty;                                      // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEndDirection;                                  // 0x0424(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPathUpdated;                                     // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavGridTestingActor">();
	}
	static class AMercunaNavGridTestingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavGridTestingActor>();
	}
};
static_assert(alignof(AMercunaNavGridTestingActor) == 0x000008, "Wrong alignment on AMercunaNavGridTestingActor");
static_assert(sizeof(AMercunaNavGridTestingActor) == 0x000438, "Wrong size on AMercunaNavGridTestingActor");
static_assert(offsetof(AMercunaNavGridTestingActor, AgentType) == 0x0003C8, "Member 'AMercunaNavGridTestingActor::AgentType' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, OtherActor) == 0x0003D8, "Member 'AMercunaNavGridTestingActor::OtherActor' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, NavGrid) == 0x0003E0, "Member 'AMercunaNavGridTestingActor::NavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, MinTurnRadius) == 0x000410, "Member 'AMercunaNavGridTestingActor::MinTurnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, IdealTurnRadius) == 0x000414, "Member 'AMercunaNavGridTestingActor::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, MaxSpeed) == 0x000418, "Member 'AMercunaNavGridTestingActor::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, InitialSpeed) == 0x00041C, "Member 'AMercunaNavGridTestingActor::InitialSpeed' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, SlopePenalty) == 0x000420, "Member 'AMercunaNavGridTestingActor::SlopePenalty' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, bUseEndDirection) == 0x000424, "Member 'AMercunaNavGridTestingActor::bUseEndDirection' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, OnPathUpdated) == 0x000428, "Member 'AMercunaNavGridTestingActor::OnPathUpdated' has a wrong offset!");

// Class Mercuna.MercunaNavVolume
// 0x0018 (0x0368 - 0x0350)
class AMercunaNavVolume : public AActor
{
public:
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PreciseBoundaries;                                 // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGraph*                       NavGraphPtr;                                       // 0x0360(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetNavigationRotation(const struct FRotator& Rotation);
	void SetSize(const struct FVector& Size);

	struct FVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavVolume">();
	}
	static class AMercunaNavVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavVolume>();
	}
};
static_assert(alignof(AMercunaNavVolume) == 0x000008, "Wrong alignment on AMercunaNavVolume");
static_assert(sizeof(AMercunaNavVolume) == 0x000368, "Wrong size on AMercunaNavVolume");
static_assert(offsetof(AMercunaNavVolume, VolumeComponent) == 0x000350, "Member 'AMercunaNavVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavVolume, PreciseBoundaries) == 0x000358, "Member 'AMercunaNavVolume::PreciseBoundaries' has a wrong offset!");
static_assert(offsetof(AMercunaNavVolume, NavGraphPtr) == 0x000360, "Member 'AMercunaNavVolume::NavGraphPtr' has a wrong offset!");

// Class Mercuna.MercunaNavGridVolume
// 0x0030 (0x0398 - 0x0368)
class AMercunaNavGridVolume : public AMercunaNavVolume
{
public:
	TSoftObjectPtr<class AMercunaNavGraph2D>      NavGrid;                                           // 0x0368(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddToGrid(class AMercunaNavGraph2D* NavGrid_0);
	void RemoveFromGrid();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavGridVolume">();
	}
	static class AMercunaNavGridVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavGridVolume>();
	}
};
static_assert(alignof(AMercunaNavGridVolume) == 0x000008, "Wrong alignment on AMercunaNavGridVolume");
static_assert(sizeof(AMercunaNavGridVolume) == 0x000398, "Wrong size on AMercunaNavGridVolume");
static_assert(offsetof(AMercunaNavGridVolume, NavGrid) == 0x000368, "Member 'AMercunaNavGridVolume::NavGrid' has a wrong offset!");

// Class Mercuna.MercunaNavGroundGrid
// 0x0040 (0x06B0 - 0x0670)
class AMercunaNavGroundGrid : public AMercunaNavGraph2D
{
public:
	bool                                          bCutOutStationaryObstacles;                        // 0x0670(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateJumpLinks;                                // 0x0671(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCurbsDuringAutoJumpGeneration;              // 0x0672(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubCellRasterization;                             // 0x0673(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoughSurfacePerchFraction;                         // 0x0674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavInvokerUpdateFrequency;                         // 0x0678(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67C[0x4];                                      // 0x067C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMercunaNavInvoker>             NavInvokers;                                       // 0x0680(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMercunaNavInvokerVolume*>       NavInvokerVolumes;                                 // 0x0690(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A0[0x10];                                     // 0x06A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Build(const TArray<struct FVector>& PriorityPositions);
	void ClampToNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& position, float SearchRadius, float HeightRange, struct FVector* ClampedPosition, bool* Result, class AActor* Querier);
	void Create();
	void DisableAutoGenNavLinksByIdentifier(const TArray<struct FMercunaAutoNavLinkIdentifier>& Identifiers);
	void DisableAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume);
	void EnableAutoGenNavLinksByIdentifier(const TArray<struct FMercunaAutoNavLinkIdentifier>& Identifiers);
	void EnableAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume);
	class UMercunaPath* FindPathToLocation(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const struct FVector& End, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, float SlopePenalty);
	class UMercunaPath* FindPathToLocations(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const TArray<struct FVector>& Destinations, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, float SlopePenalty);
	class UMercunaSmoothPath* FindSmoothPathToLocation(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const struct FVector& End, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, float MaxSpeedReverse, bool AllowPartial, float MaxPathLength, float SlopePenalty);
	class UMercunaSmoothPath* FindSmoothPathToLocations(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const TArray<struct FVector>& Destinations, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, float MaxSpeedReverse, bool AllowPartial, float MaxPathLength, float SlopePenalty);
	void GetAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume, TArray<struct FMercunaAutoNavLink>* Results);
	void GetClosestNavMeshEdge(const struct FMercunaGroundAgentType& AgentType, const struct FVector& position, struct FMercunaNavMeshEdge* Result, struct FVector* ClosestPoint, bool* ClosestPointFound, const struct FMercunaPawnUsageFlags& UsageSpec, class AActor* QueryingActor, const float MaxDistance, EMercunaNavLinkQueryMode FollowNavLinks);
	void IsNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& position, bool* Result, const struct FMercunaPawnUsageFlags& UsageSpec);
	void IsNavigableMulti(const struct FMercunaGroundAgentType& AgentType, const TArray<struct FVector>& Positions, TArray<bool>* Results);
	bool IsReachable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Start, const struct FVector& End, float MaxPathLength, EMercunaNavLinkQueryMode FollowNavLinks);
	void IsReachableLatent(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Start, const TArray<struct FVector>& EndPos, TArray<bool>* Result, TArray<struct FVector>* ClampedPos, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, EMercunaNavLinkQueryMode FollowNavLinks, float StartSearchRadius, float EndSearchRadius);
	void NavMeshEdgesInRange(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Start, const float SearchRadius, TArray<struct FMercunaNavMeshEdge>* NavMeshEdges, const struct FMercunaPawnUsageFlags& UsageSpec, class AActor* QueryingActor);
	void ProjectToNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& position, EMercunaProjectionDirection Direction, struct FVector* ClampedPosition, bool* Result, float SearchHeight, class AActor* Querier);
	void RandomInRange(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Start, float MaxPathLength, EMercunaNavLinkQueryMode FollowNavLinks, int32 NumPoints, TArray<struct FVector>* Results);
	void Raycast(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Start, const struct FVector& End, struct FVector* HitPosition, bool* RayHit);
	void RebuildChanges();
	void RebuildVolume(const class AActor* Volume);
	void RebuildVolumes(const TArray<struct FBox>& Volumes, bool bMergeVolumes, bool bOnlyUnbuilt);
	void RegisterNavInvoker(class AActor* Actor, class FName AgentType, float GenerationRadius, float RemovalRadius);
	void UnregisterNavInvoker(class AActor* Actor);
	void UpdateAutoGenNavLinks(const TArray<struct FMercunaAutoNavLinkForUpdate>& LinksToUpdate);

	int32 GetNumBoxesBuilding() const;
	bool IsAnyWorkInProgress() const;
	bool IsBuilding() const;
	bool IsBuilt(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Pos) const;
	bool IsBuiltWithinBox(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Box) const;
	void SaveToObjFile(const struct FMercunaGroundAgentType& AgentType, bool bDrawPolyMesh) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavGroundGrid">();
	}
	static class AMercunaNavGroundGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavGroundGrid>();
	}
};
static_assert(alignof(AMercunaNavGroundGrid) == 0x000010, "Wrong alignment on AMercunaNavGroundGrid");
static_assert(sizeof(AMercunaNavGroundGrid) == 0x0006B0, "Wrong size on AMercunaNavGroundGrid");
static_assert(offsetof(AMercunaNavGroundGrid, bCutOutStationaryObstacles) == 0x000670, "Member 'AMercunaNavGroundGrid::bCutOutStationaryObstacles' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bGenerateJumpLinks) == 0x000671, "Member 'AMercunaNavGroundGrid::bGenerateJumpLinks' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bIgnoreCurbsDuringAutoJumpGeneration) == 0x000672, "Member 'AMercunaNavGroundGrid::bIgnoreCurbsDuringAutoJumpGeneration' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bSubCellRasterization) == 0x000673, "Member 'AMercunaNavGroundGrid::bSubCellRasterization' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, RoughSurfacePerchFraction) == 0x000674, "Member 'AMercunaNavGroundGrid::RoughSurfacePerchFraction' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, NavInvokerUpdateFrequency) == 0x000678, "Member 'AMercunaNavGroundGrid::NavInvokerUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, NavInvokers) == 0x000680, "Member 'AMercunaNavGroundGrid::NavInvokers' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, NavInvokerVolumes) == 0x000690, "Member 'AMercunaNavGroundGrid::NavInvokerVolumes' has a wrong offset!");

// Class Mercuna.MercunaNavigationSystem
// 0x0000 (0x0030 - 0x0030)
class UMercunaNavigationSystem final : public UNavigationSystemBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavigationSystem">();
	}
	static class UMercunaNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaNavigationSystem>();
	}
};
static_assert(alignof(UMercunaNavigationSystem) == 0x000008, "Wrong alignment on UMercunaNavigationSystem");
static_assert(sizeof(UMercunaNavigationSystem) == 0x000030, "Wrong size on UMercunaNavigationSystem");

// Class Mercuna.MercunaNavInvokerVolume
// 0x0018 (0x0368 - 0x0350)
class AMercunaNavInvokerVolume final : public AActor
{
public:
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMercunaNavGroundGrid*                  NavGrid;                                           // 0x0358(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMercunaInvokerVolumeType                     Type;                                              // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToGrid(class AMercunaNavGroundGrid* NavGrid_0);
	void SetSize(const struct FVector& Size);
	void SetType(const EMercunaInvokerVolumeType& Type_0);

	struct FVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavInvokerVolume">();
	}
	static class AMercunaNavInvokerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavInvokerVolume>();
	}
};
static_assert(alignof(AMercunaNavInvokerVolume) == 0x000008, "Wrong alignment on AMercunaNavInvokerVolume");
static_assert(sizeof(AMercunaNavInvokerVolume) == 0x000368, "Wrong size on AMercunaNavInvokerVolume");
static_assert(offsetof(AMercunaNavInvokerVolume, VolumeComponent) == 0x000350, "Member 'AMercunaNavInvokerVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavInvokerVolume, NavGrid) == 0x000358, "Member 'AMercunaNavInvokerVolume::NavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavInvokerVolume, Type) == 0x000360, "Member 'AMercunaNavInvokerVolume::Type' has a wrong offset!");

// Class Mercuna.MercunaNavLink
// 0x0220 (0x0570 - 0x0350)
class AMercunaNavLink : public AActor
{
public:
	struct FMercunaNavigationLink                 Link;                                              // 0x0350(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FMercunaSupportedAgentTypes            SupportedAgentTypes;                               // 0x0430(0x00A8)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAutoRotation;                                     // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class APawn* Pawn, EMercunaNavigationLinkDirection Direction, const struct FVector& Destination)> OnNavLinkStart; // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bApplyToAllNavGrids;                               // 0x04F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F1[0x7];                                      // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGraph2D*                     NavGrid;                                           // 0x04F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMercunaNavUsageTypes                  UsageTypes;                                        // 0x0500(0x0004)(Edit, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x0504(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInterGridLink;                                    // 0x0505(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_506[0x2];                                      // 0x0506(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AMercunaNavGraph2D>      LeftNavGrid;                                       // 0x0508(0x0030)(Edit, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AMercunaNavGraph2D>      RightNavGrid;                                      // 0x0538(0x0030)(Edit, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToAllGrids();
	void AddToNavGrid(class AMercunaNavGraph2D* NavGrid_0);
	void ReceiveNavLinkEnd(class APawn* Pawn);
	void ReceiveNavLinkStart(class APawn* Pawn, EMercunaNavigationLinkDirection Direction, const struct FVector& Destination);
	void SetEnabled(bool bEnabled_0);

	struct FVector GetLeftPosition() const;
	struct FRotator GetLeftRotation() const;
	struct FTransform GetLeftTransform() const;
	struct FVector GetRightPosition() const;
	struct FRotator GetRightRotation() const;
	struct FTransform GetRightTransform() const;
	bool InUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavLink">();
	}
	static class AMercunaNavLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavLink>();
	}
};
static_assert(alignof(AMercunaNavLink) == 0x000010, "Wrong alignment on AMercunaNavLink");
static_assert(sizeof(AMercunaNavLink) == 0x000570, "Wrong size on AMercunaNavLink");
static_assert(offsetof(AMercunaNavLink, Link) == 0x000350, "Member 'AMercunaNavLink::Link' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, SupportedAgentTypes) == 0x000430, "Member 'AMercunaNavLink::SupportedAgentTypes' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bAutoRotation) == 0x0004D8, "Member 'AMercunaNavLink::bAutoRotation' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, OnNavLinkStart) == 0x0004E0, "Member 'AMercunaNavLink::OnNavLinkStart' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bApplyToAllNavGrids) == 0x0004F0, "Member 'AMercunaNavLink::bApplyToAllNavGrids' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, NavGrid) == 0x0004F8, "Member 'AMercunaNavLink::NavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, UsageTypes) == 0x000500, "Member 'AMercunaNavLink::UsageTypes' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bEnabled) == 0x000504, "Member 'AMercunaNavLink::bEnabled' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bInterGridLink) == 0x000505, "Member 'AMercunaNavLink::bInterGridLink' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, LeftNavGrid) == 0x000508, "Member 'AMercunaNavLink::LeftNavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, RightNavGrid) == 0x000538, "Member 'AMercunaNavLink::RightNavGrid' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeVolume
// 0x0038 (0x03A0 - 0x0368)
class AMercunaNavOctreeVolume final : public AMercunaNavVolume
{
public:
	TSoftObjectPtr<class AMercunaNavOctree>       NavOctree;                                         // 0x0368(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMercunaLevelOfDetail                         LOD;                                               // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FullDetailBuild;                                   // 0x0399(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39A[0x6];                                      // 0x039A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToOctree(class AMercunaNavOctree* NavOctree_0);
	void RemoveFromOctree();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavOctreeVolume">();
	}
	static class AMercunaNavOctreeVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavOctreeVolume>();
	}
};
static_assert(alignof(AMercunaNavOctreeVolume) == 0x000008, "Wrong alignment on AMercunaNavOctreeVolume");
static_assert(sizeof(AMercunaNavOctreeVolume) == 0x0003A0, "Wrong size on AMercunaNavOctreeVolume");
static_assert(offsetof(AMercunaNavOctreeVolume, NavOctree) == 0x000368, "Member 'AMercunaNavOctreeVolume::NavOctree' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeVolume, LOD) == 0x000398, "Member 'AMercunaNavOctreeVolume::LOD' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeVolume, FullDetailBuild) == 0x000399, "Member 'AMercunaNavOctreeVolume::FullDetailBuild' has a wrong offset!");

// Class Mercuna.MercunaNavSeed
// 0x0000 (0x0350 - 0x0350)
class AMercunaNavSeed final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaNavSeed">();
	}
	static class AMercunaNavSeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMercunaNavSeed>();
	}
};
static_assert(alignof(AMercunaNavSeed) == 0x000008, "Wrong alignment on AMercunaNavSeed");
static_assert(sizeof(AMercunaNavSeed) == 0x000350, "Wrong size on AMercunaNavSeed");

// Class Mercuna.MercunaOctreeRaycastProxy
// 0x0060 (0x0098 - 0x0038)
class UMercunaOctreeRaycastProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FVector& HitPosition)> OnNoHit;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& HitPosition)> OnHit;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x38];                                      // 0x0060(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaOctreeRaycastProxy* NavigationRaycast(class UObject* WorldContextObject_0, const struct FVector& Start, const struct FVector& End, float NavigationRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaOctreeRaycastProxy">();
	}
	static class UMercunaOctreeRaycastProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaOctreeRaycastProxy>();
	}
};
static_assert(alignof(UMercunaOctreeRaycastProxy) == 0x000008, "Wrong alignment on UMercunaOctreeRaycastProxy");
static_assert(sizeof(UMercunaOctreeRaycastProxy) == 0x000098, "Wrong size on UMercunaOctreeRaycastProxy");
static_assert(offsetof(UMercunaOctreeRaycastProxy, OnNoHit) == 0x000038, "Member 'UMercunaOctreeRaycastProxy::OnNoHit' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeRaycastProxy, OnHit) == 0x000048, "Member 'UMercunaOctreeRaycastProxy::OnHit' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeRaycastProxy, WorldContextObject) == 0x000058, "Member 'UMercunaOctreeRaycastProxy::WorldContextObject' has a wrong offset!");

// Class Mercuna.MercunaPath
// 0x0018 (0x0048 - 0x0030)
class UMercunaPath : public UObject
{
public:
	TDelegate<void(EMercunaPathEvent PathEvent)>  PathUpdated;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Invalidate();

	void GetDebugInfo(int32* nodesUsed, bool* bOutOfNodes, float* queryTime) const;
	int32 GetNumPoints() const;
	float GetPathLength() const;
	struct FVector GetPoint(int32 I) const;
	class FString GetStatus() const;
	bool IsPartial() const;
	bool IsReady() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaPath">();
	}
	static class UMercunaPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaPath>();
	}
};
static_assert(alignof(UMercunaPath) == 0x000008, "Wrong alignment on UMercunaPath");
static_assert(sizeof(UMercunaPath) == 0x000048, "Wrong size on UMercunaPath");
static_assert(offsetof(UMercunaPath, PathUpdated) == 0x000030, "Member 'UMercunaPath::PathUpdated' has a wrong offset!");

// Class Mercuna.MercunaPhysicalMaterial
// 0x0008 (0x0090 - 0x0088)
class UMercunaPhysicalMaterial final : public UPhysicalMaterial
{
public:
	float                                         CostMultiplier;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaPhysicalMaterial">();
	}
	static class UMercunaPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaPhysicalMaterial>();
	}
};
static_assert(alignof(UMercunaPhysicalMaterial) == 0x000008, "Wrong alignment on UMercunaPhysicalMaterial");
static_assert(sizeof(UMercunaPhysicalMaterial) == 0x000090, "Wrong size on UMercunaPhysicalMaterial");
static_assert(offsetof(UMercunaPhysicalMaterial, CostMultiplier) == 0x000088, "Member 'UMercunaPhysicalMaterial::CostMultiplier' has a wrong offset!");

// Class Mercuna.MercunaSmoothPath
// 0x0000 (0x0048 - 0x0048)
class UMercunaSmoothPath final : public UMercunaPath
{
public:
	struct FVector GetPosition(const float Length) const;
	TArray<struct FSplinePoint> GetSplinePoints(const struct FTransform& RelativeTo) const;
	struct FVector GetTangent(const float Length) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MercunaSmoothPath">();
	}
	static class UMercunaSmoothPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMercunaSmoothPath>();
	}
};
static_assert(alignof(UMercunaSmoothPath) == 0x000008, "Wrong alignment on UMercunaSmoothPath");
static_assert(sizeof(UMercunaSmoothPath) == 0x000048, "Wrong size on UMercunaSmoothPath");

// Class Mercuna.MerEntitySubsystem
// 0x0058 (0x00A0 - 0x0048)
class UMerEntitySubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_48[0x58];                                      // 0x0048(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerEntitySubsystem">();
	}
	static class UMerEntitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerEntitySubsystem>();
	}
};
static_assert(alignof(UMerEntitySubsystem) == 0x000008, "Wrong alignment on UMerEntitySubsystem");
static_assert(sizeof(UMerEntitySubsystem) == 0x0000A0, "Wrong size on UMerEntitySubsystem");

// Class Mercuna.MerNavDataChunk
// 0x0110 (0x0460 - 0x0350)
class AMerNavDataChunk final : public AActor
{
public:
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AMercunaNavGraph>        NavGraph;                                          // 0x0360(0x0030)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMercunaNavGraph*                       NavGraphPtr;                                       // 0x0390(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UPhysicalMaterial*, uint32>        SurfaceMaterials;                                  // 0x0398(0x0050)(NativeAccessSpecifierPrivate)
	struct FBox                                   DataChunkBounds;                                   // 0x03E8(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FIntVector                             DataChunkCoords;                                   // 0x0420(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x14];                                     // 0x042C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativePosition;                                  // 0x0440(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CRC;                                               // 0x0458(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerNavDataChunk">();
	}
	static class AMerNavDataChunk* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMerNavDataChunk>();
	}
};
static_assert(alignof(AMerNavDataChunk) == 0x000008, "Wrong alignment on AMerNavDataChunk");
static_assert(sizeof(AMerNavDataChunk) == 0x000460, "Wrong size on AMerNavDataChunk");
static_assert(offsetof(AMerNavDataChunk, NavGraph) == 0x000360, "Member 'AMerNavDataChunk::NavGraph' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, NavGraphPtr) == 0x000390, "Member 'AMerNavDataChunk::NavGraphPtr' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, SurfaceMaterials) == 0x000398, "Member 'AMerNavDataChunk::SurfaceMaterials' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, DataChunkBounds) == 0x0003E8, "Member 'AMerNavDataChunk::DataChunkBounds' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, DataChunkCoords) == 0x000420, "Member 'AMerNavDataChunk::DataChunkCoords' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, RelativePosition) == 0x000440, "Member 'AMerNavDataChunk::RelativePosition' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, CRC) == 0x000458, "Member 'AMerNavDataChunk::CRC' has a wrong offset!");

// Class Mercuna.MerNavGraphRenderingComponent
// 0x0030 (0x0660 - 0x0630)
#pragma pack(push, 0x1)
class alignas(0x10) UMerNavGraphRenderingComponent : public UPrimitiveComponent
{
public:
	bool                                          bDrawChunkBounds;                                  // 0x0630(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_631[0x7];                                      // 0x0631(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0638(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x10];                                     // 0x0648(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerNavGraphRenderingComponent">();
	}
	static class UMerNavGraphRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerNavGraphRenderingComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMerNavGraphRenderingComponent) == 0x000010, "Wrong alignment on UMerNavGraphRenderingComponent");
static_assert(sizeof(UMerNavGraphRenderingComponent) == 0x000660, "Wrong size on UMerNavGraphRenderingComponent");
static_assert(offsetof(UMerNavGraphRenderingComponent, bDrawChunkBounds) == 0x000630, "Member 'UMerNavGraphRenderingComponent::bDrawChunkBounds' has a wrong offset!");
static_assert(offsetof(UMerNavGraphRenderingComponent, Materials) == 0x000638, "Member 'UMerNavGraphRenderingComponent::Materials' has a wrong offset!");

// Class Mercuna.MerNavGridRenderingComponent
// 0x0010 (0x0670 - 0x0660)
class UMerNavGridRenderingComponent final : public UMerNavGraphRenderingComponent
{
public:
	bool                                          bDrawPolygons;                                     // 0x0658(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawPolygonLabels;                                // 0x0659(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawGenerationBoxes;                              // 0x065A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawAutoJumpLinks;                                // 0x065B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DrawDistance;                                      // 0x065C(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x10];                                     // 0x0660(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerNavGridRenderingComponent">();
	}
	static class UMerNavGridRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerNavGridRenderingComponent>();
	}
};
static_assert(alignof(UMerNavGridRenderingComponent) == 0x000010, "Wrong alignment on UMerNavGridRenderingComponent");
static_assert(sizeof(UMerNavGridRenderingComponent) == 0x000670, "Wrong size on UMerNavGridRenderingComponent");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawPolygons) == 0x000658, "Member 'UMerNavGridRenderingComponent::bDrawPolygons' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawPolygonLabels) == 0x000659, "Member 'UMerNavGridRenderingComponent::bDrawPolygonLabels' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawGenerationBoxes) == 0x00065A, "Member 'UMerNavGridRenderingComponent::bDrawGenerationBoxes' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawAutoJumpLinks) == 0x00065B, "Member 'UMerNavGridRenderingComponent::bDrawAutoJumpLinks' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, DrawDistance) == 0x00065C, "Member 'UMerNavGridRenderingComponent::DrawDistance' has a wrong offset!");

// Class Mercuna.MerNavLinkRenderingComponent
// 0x0000 (0x0630 - 0x0630)
class UMerNavLinkRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerNavLinkRenderingComponent">();
	}
	static class UMerNavLinkRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerNavLinkRenderingComponent>();
	}
};
static_assert(alignof(UMerNavLinkRenderingComponent) == 0x000010, "Wrong alignment on UMerNavLinkRenderingComponent");
static_assert(sizeof(UMerNavLinkRenderingComponent) == 0x000630, "Wrong size on UMerNavLinkRenderingComponent");

// Class Mercuna.MerNavOctreeRenderingComponent
// 0x0010 (0x0670 - 0x0660)
class UMerNavOctreeRenderingComponent final : public UMerNavGraphRenderingComponent
{
public:
	int32                                         DrawDistance;                                      // 0x0658(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65C[0x14];                                     // 0x065C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerNavOctreeRenderingComponent">();
	}
	static class UMerNavOctreeRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerNavOctreeRenderingComponent>();
	}
};
static_assert(alignof(UMerNavOctreeRenderingComponent) == 0x000010, "Wrong alignment on UMerNavOctreeRenderingComponent");
static_assert(sizeof(UMerNavOctreeRenderingComponent) == 0x000670, "Wrong size on UMerNavOctreeRenderingComponent");
static_assert(offsetof(UMerNavOctreeRenderingComponent, DrawDistance) == 0x000658, "Member 'UMerNavOctreeRenderingComponent::DrawDistance' has a wrong offset!");

// Class Mercuna.MerSettings
// 0x00F8 (0x0128 - 0x0030)
class UMerSettings final : public UObject
{
public:
	float                                         DebugLengthScale;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowErrors;                                 // 0x0034(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ModifierUsageTypes;                                // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMercunaGroundAgentProperties> GroundAgentTypes;                        // 0x0048(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMercunaSurfaceAgentProperties> SurfaceAgentTypes;                      // 0x0098(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bAutoLinkNavVolumesWithGraphs;                     // 0x00E8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavGraphVolumeOrientation             AlignGraphAndVolumeOrientations;                   // 0x00E9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        GeometryCollectionTimePerFrame;                    // 0x00F0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SingleThreadedJobTimePerFrame;                     // 0x00F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStepForHeightClearance;                     // 0x00FC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnIfSubLevelNavGraphsNotBuiltInPersistentLevel; // 0x00FD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNavGraphMerging;                             // 0x00FE(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF[0x1];                                       // 0x00FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OctreeCellSize;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPawnRadius;                                     // 0x0104(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPawnRadius;                                     // 0x0108(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x1C];                                     // 0x010C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerSettings">();
	}
	static class UMerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerSettings>();
	}
};
static_assert(alignof(UMerSettings) == 0x000008, "Wrong alignment on UMerSettings");
static_assert(sizeof(UMerSettings) == 0x000128, "Wrong size on UMerSettings");
static_assert(offsetof(UMerSettings, DebugLengthScale) == 0x000030, "Member 'UMerSettings::DebugLengthScale' has a wrong offset!");
static_assert(offsetof(UMerSettings, bAlwaysShowErrors) == 0x000034, "Member 'UMerSettings::bAlwaysShowErrors' has a wrong offset!");
static_assert(offsetof(UMerSettings, ModifierUsageTypes) == 0x000038, "Member 'UMerSettings::ModifierUsageTypes' has a wrong offset!");
static_assert(offsetof(UMerSettings, GroundAgentTypes) == 0x000048, "Member 'UMerSettings::GroundAgentTypes' has a wrong offset!");
static_assert(offsetof(UMerSettings, SurfaceAgentTypes) == 0x000098, "Member 'UMerSettings::SurfaceAgentTypes' has a wrong offset!");
static_assert(offsetof(UMerSettings, bAutoLinkNavVolumesWithGraphs) == 0x0000E8, "Member 'UMerSettings::bAutoLinkNavVolumesWithGraphs' has a wrong offset!");
static_assert(offsetof(UMerSettings, AlignGraphAndVolumeOrientations) == 0x0000E9, "Member 'UMerSettings::AlignGraphAndVolumeOrientations' has a wrong offset!");
static_assert(offsetof(UMerSettings, GeometryCollectionTimePerFrame) == 0x0000F0, "Member 'UMerSettings::GeometryCollectionTimePerFrame' has a wrong offset!");
static_assert(offsetof(UMerSettings, SingleThreadedJobTimePerFrame) == 0x0000F8, "Member 'UMerSettings::SingleThreadedJobTimePerFrame' has a wrong offset!");
static_assert(offsetof(UMerSettings, bIgnoreStepForHeightClearance) == 0x0000FC, "Member 'UMerSettings::bIgnoreStepForHeightClearance' has a wrong offset!");
static_assert(offsetof(UMerSettings, bWarnIfSubLevelNavGraphsNotBuiltInPersistentLevel) == 0x0000FD, "Member 'UMerSettings::bWarnIfSubLevelNavGraphsNotBuiltInPersistentLevel' has a wrong offset!");
static_assert(offsetof(UMerSettings, bAllowNavGraphMerging) == 0x0000FE, "Member 'UMerSettings::bAllowNavGraphMerging' has a wrong offset!");
static_assert(offsetof(UMerSettings, OctreeCellSize) == 0x000100, "Member 'UMerSettings::OctreeCellSize' has a wrong offset!");
static_assert(offsetof(UMerSettings, MinPawnRadius) == 0x000104, "Member 'UMerSettings::MinPawnRadius' has a wrong offset!");
static_assert(offsetof(UMerSettings, MaxPawnRadius) == 0x000108, "Member 'UMerSettings::MaxPawnRadius' has a wrong offset!");

// Class Mercuna.MerEditorSettings
// 0x0078 (0x00A8 - 0x0030)
class UMerEditorSettings final : public UObject
{
public:
	bool                                          bEnableExtraLogging;                               // 0x0030(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlushMercunaLogFileOnWrite;                       // 0x0031(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMerOctreeEditorSettings               OctreeEditorSettings;                              // 0x0034(0x0030)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FMerGridEditorSettings                 GridEditorSettings;                                // 0x0064(0x0028)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x1C];                                      // 0x008C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MerEditorSettings">();
	}
	static class UMerEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMerEditorSettings>();
	}
};
static_assert(alignof(UMerEditorSettings) == 0x000008, "Wrong alignment on UMerEditorSettings");
static_assert(sizeof(UMerEditorSettings) == 0x0000A8, "Wrong size on UMerEditorSettings");
static_assert(offsetof(UMerEditorSettings, bEnableExtraLogging) == 0x000030, "Member 'UMerEditorSettings::bEnableExtraLogging' has a wrong offset!");
static_assert(offsetof(UMerEditorSettings, bFlushMercunaLogFileOnWrite) == 0x000031, "Member 'UMerEditorSettings::bFlushMercunaLogFileOnWrite' has a wrong offset!");
static_assert(offsetof(UMerEditorSettings, OctreeEditorSettings) == 0x000034, "Member 'UMerEditorSettings::OctreeEditorSettings' has a wrong offset!");
static_assert(offsetof(UMerEditorSettings, GridEditorSettings) == 0x000064, "Member 'UMerEditorSettings::GridEditorSettings' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LandscapeDisplacement

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "LandscapeDisplacement_structs.hpp"


namespace SDK
{

// Class LandscapeDisplacement.LandscapeDisplacementTaskParams
// 0x0070 (0x00A0 - 0x0030)
class ULandscapeDisplacementTaskParams final : public UObject
{
public:
	class ALandscapeDisplacementVolume*           DisplacementVolume;                                // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULandscapeDisplacementLayer*            LandscapeDisplacementLayer;                        // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x60];                                      // 0x0040(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeDisplacementTaskParams">();
	}
	static class ULandscapeDisplacementTaskParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeDisplacementTaskParams>();
	}
};
static_assert(alignof(ULandscapeDisplacementTaskParams) == 0x000008, "Wrong alignment on ULandscapeDisplacementTaskParams");
static_assert(sizeof(ULandscapeDisplacementTaskParams) == 0x0000A0, "Wrong size on ULandscapeDisplacementTaskParams");
static_assert(offsetof(ULandscapeDisplacementTaskParams, DisplacementVolume) == 0x000030, "Member 'ULandscapeDisplacementTaskParams::DisplacementVolume' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementTaskParams, LandscapeDisplacementLayer) == 0x000038, "Member 'ULandscapeDisplacementTaskParams::LandscapeDisplacementLayer' has a wrong offset!");

// Class LandscapeDisplacement.LandscapeDisplacementLayer
// 0x0100 (0x0130 - 0x0030)
class ULandscapeDisplacementLayer final : public UObject
{
public:
	class ULandscapeDisplacementMap*              m_pDisplacementMap1;                               // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULandscapeDisplacementMap*              m_pDisplacementMap2;                               // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULandscapeDisplacementMap*              m_pExternalDisplacementLayer;                      // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDisplacementPointData                 m_DynamicPoints;                                   // 0x0048(0x0030)(Protected, NativeAccessSpecifierProtected)
	float                                         m_DisplacementBlendFactor;                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_DisplacementAlpha;                               // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_DisplacementMap1Alpha;                           // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_DisplacementMap2Alpha;                           // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4f                              m_FlipbookRenderState;                             // 0x0090(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              m_FlipbookSpriteOffset;                            // 0x00A0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          m_bUseFlipBook;                                    // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             m_LayerTransform;                                  // 0x00C0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeDisplacementLayer">();
	}
	static class ULandscapeDisplacementLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeDisplacementLayer>();
	}
};
static_assert(alignof(ULandscapeDisplacementLayer) == 0x000010, "Wrong alignment on ULandscapeDisplacementLayer");
static_assert(sizeof(ULandscapeDisplacementLayer) == 0x000130, "Wrong size on ULandscapeDisplacementLayer");
static_assert(offsetof(ULandscapeDisplacementLayer, m_pDisplacementMap1) == 0x000030, "Member 'ULandscapeDisplacementLayer::m_pDisplacementMap1' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_pDisplacementMap2) == 0x000038, "Member 'ULandscapeDisplacementLayer::m_pDisplacementMap2' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_pExternalDisplacementLayer) == 0x000040, "Member 'ULandscapeDisplacementLayer::m_pExternalDisplacementLayer' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_DynamicPoints) == 0x000048, "Member 'ULandscapeDisplacementLayer::m_DynamicPoints' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_DisplacementBlendFactor) == 0x000078, "Member 'ULandscapeDisplacementLayer::m_DisplacementBlendFactor' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_DisplacementAlpha) == 0x00007C, "Member 'ULandscapeDisplacementLayer::m_DisplacementAlpha' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_DisplacementMap1Alpha) == 0x000080, "Member 'ULandscapeDisplacementLayer::m_DisplacementMap1Alpha' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_DisplacementMap2Alpha) == 0x000084, "Member 'ULandscapeDisplacementLayer::m_DisplacementMap2Alpha' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_FlipbookRenderState) == 0x000090, "Member 'ULandscapeDisplacementLayer::m_FlipbookRenderState' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_FlipbookSpriteOffset) == 0x0000A0, "Member 'ULandscapeDisplacementLayer::m_FlipbookSpriteOffset' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_bUseFlipBook) == 0x0000B0, "Member 'ULandscapeDisplacementLayer::m_bUseFlipBook' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementLayer, m_LayerTransform) == 0x0000C0, "Member 'ULandscapeDisplacementLayer::m_LayerTransform' has a wrong offset!");

// Class LandscapeDisplacement.LandscapeDisplacementMap
// 0x0040 (0x0070 - 0x0030)
class ULandscapeDisplacementMap final : public UObject
{
public:
	class UTexture2D*                             m_pDisplacementTexture;                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComponentSizeQuads;                                // 0x0038(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubsectionSizeQuads;                               // 0x003C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComponentNumSubsections;                           // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreCompacted;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         Pixels;                                            // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint16>                                PixelsU16;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint16                                        Min;                                               // 0x0068(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        Max;                                               // 0x006A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_bDataFromTextureAsset;                           // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeDisplacementMap">();
	}
	static class ULandscapeDisplacementMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeDisplacementMap>();
	}
};
static_assert(alignof(ULandscapeDisplacementMap) == 0x000008, "Wrong alignment on ULandscapeDisplacementMap");
static_assert(sizeof(ULandscapeDisplacementMap) == 0x000070, "Wrong size on ULandscapeDisplacementMap");
static_assert(offsetof(ULandscapeDisplacementMap, m_pDisplacementTexture) == 0x000030, "Member 'ULandscapeDisplacementMap::m_pDisplacementTexture' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, ComponentSizeQuads) == 0x000038, "Member 'ULandscapeDisplacementMap::ComponentSizeQuads' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, SubsectionSizeQuads) == 0x00003C, "Member 'ULandscapeDisplacementMap::SubsectionSizeQuads' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, ComponentNumSubsections) == 0x000040, "Member 'ULandscapeDisplacementMap::ComponentNumSubsections' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, bPreCompacted) == 0x000044, "Member 'ULandscapeDisplacementMap::bPreCompacted' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, Pixels) == 0x000048, "Member 'ULandscapeDisplacementMap::Pixels' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, PixelsU16) == 0x000058, "Member 'ULandscapeDisplacementMap::PixelsU16' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, Min) == 0x000068, "Member 'ULandscapeDisplacementMap::Min' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, Max) == 0x00006A, "Member 'ULandscapeDisplacementMap::Max' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementMap, m_bDataFromTextureAsset) == 0x00006C, "Member 'ULandscapeDisplacementMap::m_bDataFromTextureAsset' has a wrong offset!");

// Class LandscapeDisplacement.LandscapeDisplacementResetter
// 0x0178 (0x01A8 - 0x0030)
class ULandscapeDisplacementResetter final : public UObject
{
public:
	TSet<TWeakObjectPtr<class ULandscapeHeightfieldCollisionComponent>> CollisionComponentsToResetNextTime; // 0x0030(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TWeakObjectPtr<class ULandscapeHeightfieldCollisionComponent>> CollisionComponentsToResetThisTime; // 0x0080(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TWeakObjectPtr<class ULandscapeHeightfieldCollisionComponent>> CollisionComponentsToUpdateAccelerationStructure; // 0x00D0(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x88];                                     // 0x0120(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeDisplacementResetter">();
	}
	static class ULandscapeDisplacementResetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeDisplacementResetter>();
	}
};
static_assert(alignof(ULandscapeDisplacementResetter) == 0x000008, "Wrong alignment on ULandscapeDisplacementResetter");
static_assert(sizeof(ULandscapeDisplacementResetter) == 0x0001A8, "Wrong size on ULandscapeDisplacementResetter");
static_assert(offsetof(ULandscapeDisplacementResetter, CollisionComponentsToResetNextTime) == 0x000030, "Member 'ULandscapeDisplacementResetter::CollisionComponentsToResetNextTime' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementResetter, CollisionComponentsToResetThisTime) == 0x000080, "Member 'ULandscapeDisplacementResetter::CollisionComponentsToResetThisTime' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementResetter, CollisionComponentsToUpdateAccelerationStructure) == 0x0000D0, "Member 'ULandscapeDisplacementResetter::CollisionComponentsToUpdateAccelerationStructure' has a wrong offset!");

// Class LandscapeDisplacement.LandscapeDisplacementTaskParamsCache
// 0x0048 (0x0078 - 0x0030)
class ULandscapeDisplacementTaskParamsCache final : public UObject
{
public:
	TArray<class ULandscapeDisplacementTaskParams*> LandscapeDisplacementTaskParamsArray;            // 0x0030(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ULandscapeDisplacementTaskParams*> FreeLandscapeDisplacementTaskParamsArray;        // 0x0040(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeDisplacementTaskParamsCache">();
	}
	static class ULandscapeDisplacementTaskParamsCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeDisplacementTaskParamsCache>();
	}
};
static_assert(alignof(ULandscapeDisplacementTaskParamsCache) == 0x000008, "Wrong alignment on ULandscapeDisplacementTaskParamsCache");
static_assert(sizeof(ULandscapeDisplacementTaskParamsCache) == 0x000078, "Wrong size on ULandscapeDisplacementTaskParamsCache");
static_assert(offsetof(ULandscapeDisplacementTaskParamsCache, LandscapeDisplacementTaskParamsArray) == 0x000030, "Member 'ULandscapeDisplacementTaskParamsCache::LandscapeDisplacementTaskParamsArray' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementTaskParamsCache, FreeLandscapeDisplacementTaskParamsArray) == 0x000040, "Member 'ULandscapeDisplacementTaskParamsCache::FreeLandscapeDisplacementTaskParamsArray' has a wrong offset!");

// Class LandscapeDisplacement.LandscapeDisplacementVolume
// 0x04C0 (0x0810 - 0x0350)
class alignas(0x10) ALandscapeDisplacementVolume final : public AActor
{
public:
	bool                                          m_RenderDebugBounds;                               // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 m_BoundsColor;                                     // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0xB8];                                     // 0x0358(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULandscapeHeightfieldCollisionComponent*> m_OrderedCollisionComponents;             // 0x0410(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x40];                                     // 0x0420(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandscapeDisplacementResetter*         m_pResetter;                                       // 0x0460(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULandscapeDisplacementTaskParamsCache*  m_pTaskParamsCache;                                // 0x0468(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELandscapeDisplacementType                    m_DisplacementType;                                // 0x0470(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELandscapeDisplacementInstigatorType          m_DisplacementInstigatorType;                      // 0x0471(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_bSaveAsDynamicFormat;                            // 0x0472(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDisplacementBlendMode                        m_CompositeBlendMode;                              // 0x0473(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDisplacementLayerDesc>         m_DynamicLayers;                                   // 0x0478(0x0010)(Edit, ZeroConstructor, NonPIEDuplicateTransient, NativeAccessSpecifierPrivate)
	ELandscapeDisplacementMode                    m_DisplacementMode;                                // 0x0488(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandscapeDisplacementMap*              m_pDisplacementMap;                                // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALandscapeProxy*                        m_TargetLandscape;                                 // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_DisplacementAlpha;                               // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULandscapeDisplacementMap*              m_ExternalDisplacementLayer;                       // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_EnableLocalControl;                              // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          m_VelocitySystemSoftRef;                           // 0x04B8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_SVDisplacementSpeed;                             // 0x04E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_SVDisplacementAlpha;                             // 0x04EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_DisablePhysics;                                  // 0x04F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F1[0x7];                                      // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 m_ParticleVelocityMap;                             // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraSystem*                         m_ParticleSystem;                                  // 0x0500(0x0008)(ZeroConstructor, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      m_pNiagaraComponent;                               // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class ALandscapeProxy*>           m_TargetLandscapes;                                // 0x0510(0x0050)(NonPIEDuplicateTransient, NativeAccessSpecifierPrivate)
	bool                                          m_UpdateComponentHeightMaps;                       // 0x0560(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_GenerateNormals;                                 // 0x0561(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_PerformBlending;                                 // 0x0562(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_UpdateCollisionTexture;                          // 0x0563(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_UpdateCollision;                                 // 0x0564(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_565[0x3];                                      // 0x0565(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDisplacementComponent>         m_DisplacementComponents;                          // 0x0568(0x0010)(ZeroConstructor, ContainsInstancedReference, NonPIEDuplicateTransient, NativeAccessSpecifierPrivate)
	struct FIntPoint                              m_DisplacementSize;                                // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ULandscapeDisplacementLayer*>    m_DisplacementLayers;                              // 0x0580(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class ULandscapeHeightfieldCollisionComponent*> m_ActiveCollisionComponents;                // 0x0590(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ALandscapeDisplacementVolume*           m_LeftNeighbour;                                   // 0x05E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALandscapeDisplacementVolume*           m_TopNeighbour;                                    // 0x05E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UTexture2D*>                m_OriginalHeightMaps;                              // 0x05F0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<int32, class UTexture2D*>                m_CopiedHeightMaps;                                // 0x0640(0x0050)(NonPIEDuplicateTransient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0x180];                                    // 0x0690(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetLayerTransform(int32 layerIndex, struct FTransform* InTransform);
	void SetDisplacementAlpha(float DisplacementAlpha);
	bool SetDynamicDisplacementState(int32 layerIndex, const struct FDisplacementState& State);
	bool SetDynamicDisplacementStatePoints(int32 layerIndex, const struct FDisplacementState& State, const struct FDisplacementPointData& pointData);
	bool SetFlipbookDisplacementState(int32 layerIndex, const struct FDisplacementState& State, const struct FVector4f& FlipBookRenderState, const struct FVector2D& SpriteOffset);
	bool SetLayerDisplacementAlpha(int32 layerIndex, float InAlpha);
	bool SetLayerDisplacementState(int32 layerIndex, const struct FDisplacementState& State);
	bool SetLayerTransform(int32 layerIndex, const struct FTransform& InTransform);
	void StartShifting();

	float GetDisplacementAlpha() const;
	bool IsTicking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeDisplacementVolume">();
	}
	static class ALandscapeDisplacementVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandscapeDisplacementVolume>();
	}
};
static_assert(alignof(ALandscapeDisplacementVolume) == 0x000010, "Wrong alignment on ALandscapeDisplacementVolume");
static_assert(sizeof(ALandscapeDisplacementVolume) == 0x000810, "Wrong size on ALandscapeDisplacementVolume");
static_assert(offsetof(ALandscapeDisplacementVolume, m_RenderDebugBounds) == 0x000350, "Member 'ALandscapeDisplacementVolume::m_RenderDebugBounds' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_BoundsColor) == 0x000354, "Member 'ALandscapeDisplacementVolume::m_BoundsColor' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_OrderedCollisionComponents) == 0x000410, "Member 'ALandscapeDisplacementVolume::m_OrderedCollisionComponents' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_pResetter) == 0x000460, "Member 'ALandscapeDisplacementVolume::m_pResetter' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_pTaskParamsCache) == 0x000468, "Member 'ALandscapeDisplacementVolume::m_pTaskParamsCache' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisplacementType) == 0x000470, "Member 'ALandscapeDisplacementVolume::m_DisplacementType' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisplacementInstigatorType) == 0x000471, "Member 'ALandscapeDisplacementVolume::m_DisplacementInstigatorType' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_bSaveAsDynamicFormat) == 0x000472, "Member 'ALandscapeDisplacementVolume::m_bSaveAsDynamicFormat' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_CompositeBlendMode) == 0x000473, "Member 'ALandscapeDisplacementVolume::m_CompositeBlendMode' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DynamicLayers) == 0x000478, "Member 'ALandscapeDisplacementVolume::m_DynamicLayers' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisplacementMode) == 0x000488, "Member 'ALandscapeDisplacementVolume::m_DisplacementMode' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_pDisplacementMap) == 0x000490, "Member 'ALandscapeDisplacementVolume::m_pDisplacementMap' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_TargetLandscape) == 0x000498, "Member 'ALandscapeDisplacementVolume::m_TargetLandscape' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisplacementAlpha) == 0x0004A0, "Member 'ALandscapeDisplacementVolume::m_DisplacementAlpha' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_ExternalDisplacementLayer) == 0x0004A8, "Member 'ALandscapeDisplacementVolume::m_ExternalDisplacementLayer' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_EnableLocalControl) == 0x0004B0, "Member 'ALandscapeDisplacementVolume::m_EnableLocalControl' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_VelocitySystemSoftRef) == 0x0004B8, "Member 'ALandscapeDisplacementVolume::m_VelocitySystemSoftRef' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_SVDisplacementSpeed) == 0x0004E8, "Member 'ALandscapeDisplacementVolume::m_SVDisplacementSpeed' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_SVDisplacementAlpha) == 0x0004EC, "Member 'ALandscapeDisplacementVolume::m_SVDisplacementAlpha' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisablePhysics) == 0x0004F0, "Member 'ALandscapeDisplacementVolume::m_DisablePhysics' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_ParticleVelocityMap) == 0x0004F8, "Member 'ALandscapeDisplacementVolume::m_ParticleVelocityMap' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_ParticleSystem) == 0x000500, "Member 'ALandscapeDisplacementVolume::m_ParticleSystem' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_pNiagaraComponent) == 0x000508, "Member 'ALandscapeDisplacementVolume::m_pNiagaraComponent' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_TargetLandscapes) == 0x000510, "Member 'ALandscapeDisplacementVolume::m_TargetLandscapes' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_UpdateComponentHeightMaps) == 0x000560, "Member 'ALandscapeDisplacementVolume::m_UpdateComponentHeightMaps' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_GenerateNormals) == 0x000561, "Member 'ALandscapeDisplacementVolume::m_GenerateNormals' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_PerformBlending) == 0x000562, "Member 'ALandscapeDisplacementVolume::m_PerformBlending' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_UpdateCollisionTexture) == 0x000563, "Member 'ALandscapeDisplacementVolume::m_UpdateCollisionTexture' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_UpdateCollision) == 0x000564, "Member 'ALandscapeDisplacementVolume::m_UpdateCollision' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisplacementComponents) == 0x000568, "Member 'ALandscapeDisplacementVolume::m_DisplacementComponents' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisplacementSize) == 0x000578, "Member 'ALandscapeDisplacementVolume::m_DisplacementSize' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_DisplacementLayers) == 0x000580, "Member 'ALandscapeDisplacementVolume::m_DisplacementLayers' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_ActiveCollisionComponents) == 0x000590, "Member 'ALandscapeDisplacementVolume::m_ActiveCollisionComponents' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_LeftNeighbour) == 0x0005E0, "Member 'ALandscapeDisplacementVolume::m_LeftNeighbour' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_TopNeighbour) == 0x0005E8, "Member 'ALandscapeDisplacementVolume::m_TopNeighbour' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_OriginalHeightMaps) == 0x0005F0, "Member 'ALandscapeDisplacementVolume::m_OriginalHeightMaps' has a wrong offset!");
static_assert(offsetof(ALandscapeDisplacementVolume, m_CopiedHeightMaps) == 0x000640, "Member 'ALandscapeDisplacementVolume::m_CopiedHeightMaps' has a wrong offset!");

// Class LandscapeDisplacement.LandscapeDisplacementVolumeProxyComponent
// 0x0018 (0x0140 - 0x0128)
class ULandscapeDisplacementVolumeProxyComponent final : public UActorComponent
{
public:
	class UMaterialInstanceDynamic*               m_DynamicMaterialInstance;                         // 0x0128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  m_LandscapeGuid;                                   // 0x0130(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandscapeDisplacementVolumeProxyComponent">();
	}
	static class ULandscapeDisplacementVolumeProxyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandscapeDisplacementVolumeProxyComponent>();
	}
};
static_assert(alignof(ULandscapeDisplacementVolumeProxyComponent) == 0x000008, "Wrong alignment on ULandscapeDisplacementVolumeProxyComponent");
static_assert(sizeof(ULandscapeDisplacementVolumeProxyComponent) == 0x000140, "Wrong size on ULandscapeDisplacementVolumeProxyComponent");
static_assert(offsetof(ULandscapeDisplacementVolumeProxyComponent, m_DynamicMaterialInstance) == 0x000128, "Member 'ULandscapeDisplacementVolumeProxyComponent::m_DynamicMaterialInstance' has a wrong offset!");
static_assert(offsetof(ULandscapeDisplacementVolumeProxyComponent, m_LandscapeGuid) == 0x000130, "Member 'ULandscapeDisplacementVolumeProxyComponent::m_LandscapeGuid' has a wrong offset!");

}


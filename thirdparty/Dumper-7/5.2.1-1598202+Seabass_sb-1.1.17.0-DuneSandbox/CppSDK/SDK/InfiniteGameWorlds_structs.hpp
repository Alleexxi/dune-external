#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InfiniteGameWorlds

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "IgwCore_structs.hpp"
#include "NetCore_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum InfiniteGameWorlds.EIgwReplicationGraphMode
// NumValues: 0x0003
enum class EIgwReplicationGraphMode : uint8
{
	IgwRepGraphMode_C2S                      = 0,
	IgwRepGraphMode_S2S                      = 1,
	IgwRepGraphMode_MAX                      = 2,
};

// Enum InfiniteGameWorlds.EConnectFarm
// NumValues: 0x0004
enum class EConnectFarm : uint8
{
	All                                      = 0,
	SameMap                                  = 1,
	None                                     = 2,
	EConnectFarm_MAX                         = 3,
};

// Enum InfiniteGameWorlds.EIGWDebugLevel
// NumValues: 0x0006
enum class EIGWDebugLevel : uint8
{
	DEBUG_None                               = 0,
	DEBUG_Basic                              = 1,
	DEBUG_Full                               = 2,
	DEBUG_Players                            = 3,
	DEBUG_NPCs                               = 4,
	DEBUG_MAX                                = 5,
};

// Enum InfiniteGameWorlds.EPrimaryState
// NumValues: 0x0004
enum class EPrimaryState : uint8
{
	No                                       = 0,
	Requested                                = 1,
	Active                                   = 2,
	EPrimaryState_MAX                        = 3,
};

// Enum InfiniteGameWorlds.ES2SServerState
// NumValues: 0x0006
enum class ES2SServerState : uint8
{
	S2S_None                                 = 0,
	S2S_Starting                             = 1,
	S2S_Connecting                           = 2,
	S2S_WaitingForIndex                      = 3,
	S2S_Ready                                = 4,
	S2S_MAX                                  = 5,
};

// Enum InfiniteGameWorlds.ES2SServerRole
// NumValues: 0x0004
enum class ES2SServerRole : uint8
{
	Role_Leader                              = 0,
	Role_Follower                            = 1,
	Role_Candidate                           = 2,
	Role_MAX                                 = 3,
};

// ScriptStruct InfiniteGameWorlds.ServerIndices
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x08) FServerIndices final
{
public:
	uint8                                         Pad_0[0xB0];                                       // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerIndices) == 0x000008, "Wrong alignment on FServerIndices");
static_assert(sizeof(FServerIndices) == 0x0000B0, "Wrong size on FServerIndices");

// ScriptStruct InfiniteGameWorlds.ActorDebugMap
// 0x0180 (0x0180 - 0x0000)
struct alignas(0x10) FActorDebugMap final
{
public:
	uint8                                         Pad_0[0x180];                                      // 0x0000(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorDebugMap) == 0x000010, "Wrong alignment on FActorDebugMap");
static_assert(sizeof(FActorDebugMap) == 0x000180, "Wrong size on FActorDebugMap");

// ScriptStruct InfiniteGameWorlds.LevelArrayRepl
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FLevelArrayRepl final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelArrayRepl) == 0x000008, "Wrong alignment on FLevelArrayRepl");
static_assert(sizeof(FLevelArrayRepl) == 0x000018, "Wrong size on FLevelArrayRepl");

// ScriptStruct InfiniteGameWorlds.ActorGIDDataMap
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FActorGIDDataMap final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorGIDDataMap) == 0x000008, "Wrong alignment on FActorGIDDataMap");
static_assert(sizeof(FActorGIDDataMap) == 0x0000A0, "Wrong size on FActorGIDDataMap");

// ScriptStruct InfiniteGameWorlds.ServerBoundaries
// 0x00F8 (0x00F8 - 0x0000)
struct alignas(0x08) FServerBoundaries final
{
public:
	uint8                                         Pad_0[0xF8];                                       // 0x0000(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerBoundaries) == 0x000008, "Wrong alignment on FServerBoundaries");
static_assert(sizeof(FServerBoundaries) == 0x0000F8, "Wrong size on FServerBoundaries");

// ScriptStruct InfiniteGameWorlds.IGWServer
// 0x0084 (0x0090 - 0x000C)
struct FIGWServer final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FURL                                   URL;                                               // 0x0010(0x0068)(NativeAccessSpecifierPublic)
	struct FServerID                              ServerID;                                          // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPrimaryState                                 IsPrimary;                                         // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIGWServer) == 0x000008, "Wrong alignment on FIGWServer");
static_assert(sizeof(FIGWServer) == 0x000090, "Wrong size on FIGWServer");
static_assert(offsetof(FIGWServer, URL) == 0x000010, "Member 'FIGWServer::URL' has a wrong offset!");
static_assert(offsetof(FIGWServer, ServerID) == 0x000078, "Member 'FIGWServer::ServerID' has a wrong offset!");
static_assert(offsetof(FIGWServer, IsPrimary) == 0x000088, "Member 'FIGWServer::IsPrimary' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.IGWServerArray
// 0x0010 (0x0138 - 0x0128)
struct FIGWServerArray final : public FFastArraySerializer
{
public:
	TArray<struct FIGWServer>                     Servers;                                           // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FIGWServerArray) == 0x000008, "Wrong alignment on FIGWServerArray");
static_assert(sizeof(FIGWServerArray) == 0x000138, "Wrong size on FIGWServerArray");
static_assert(offsetof(FIGWServerArray, Servers) == 0x000128, "Member 'FIGWServerArray::Servers' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.UniqueNetIdGUIDs
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FUniqueNetIdGUIDs final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueNetIdGUIDs) == 0x000008, "Wrong alignment on FUniqueNetIdGUIDs");
static_assert(sizeof(FUniqueNetIdGUIDs) == 0x000058, "Wrong size on FUniqueNetIdGUIDs");

// ScriptStruct InfiniteGameWorlds.ServerArrayItem
// 0x0010 (0x001C - 0x000C)
struct FServerArrayItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x10];                                       // 0x000C(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerArrayItem) == 0x000004, "Wrong alignment on FServerArrayItem");
static_assert(sizeof(FServerArrayItem) == 0x00001C, "Wrong size on FServerArrayItem");

// ScriptStruct InfiniteGameWorlds.ServerIDArray
// 0x0010 (0x0138 - 0x0128)
struct FServerIDArray final : public FFastArraySerializer
{
public:
	TArray<struct FServerArrayItem>               Servers;                                           // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FServerIDArray) == 0x000008, "Wrong alignment on FServerIDArray");
static_assert(sizeof(FServerIDArray) == 0x000138, "Wrong size on FServerIDArray");
static_assert(offsetof(FServerIDArray, Servers) == 0x000128, "Member 'FServerIDArray::Servers' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.ServerGridLevelMap
// 0x0300 (0x0300 - 0x0000)
struct alignas(0x08) FServerGridLevelMap final
{
public:
	uint8                                         Pad_0[0x300];                                      // 0x0000(0x0300)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerGridLevelMap) == 0x000008, "Wrong alignment on FServerGridLevelMap");
static_assert(sizeof(FServerGridLevelMap) == 0x000300, "Wrong size on FServerGridLevelMap");

// ScriptStruct InfiniteGameWorlds.ServerDataEntry
// 0x006C (0x0078 - 0x000C)
struct FServerDataEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FURL                                   ServerAddress;                                     // 0x0010(0x0068)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerDataEntry) == 0x000008, "Wrong alignment on FServerDataEntry");
static_assert(sizeof(FServerDataEntry) == 0x000078, "Wrong size on FServerDataEntry");
static_assert(offsetof(FServerDataEntry, ServerAddress) == 0x000010, "Member 'FServerDataEntry::ServerAddress' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.ServerDataArray
// 0x0010 (0x0138 - 0x0128)
struct FServerDataArray final : public FFastArraySerializer
{
public:
	TArray<struct FServerDataEntry>               ServerData;                                        // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerDataArray) == 0x000008, "Wrong alignment on FServerDataArray");
static_assert(sizeof(FServerDataArray) == 0x000138, "Wrong size on FServerDataArray");
static_assert(offsetof(FServerDataArray, ServerData) == 0x000128, "Member 'FServerDataArray::ServerData' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.PeerServerData
// 0x00D0 (0x00D0 - 0x0000)
struct FPeerServerData final
{
public:
	struct FURL                                   GameAddress;                                       // 0x0000(0x0068)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FURL                                   LocalAddress;                                      // 0x0068(0x0068)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPeerServerData) == 0x000008, "Wrong alignment on FPeerServerData");
static_assert(sizeof(FPeerServerData) == 0x0000D0, "Wrong size on FPeerServerData");
static_assert(offsetof(FPeerServerData, GameAddress) == 0x000000, "Member 'FPeerServerData::GameAddress' has a wrong offset!");
static_assert(offsetof(FPeerServerData, LocalAddress) == 0x000068, "Member 'FPeerServerData::LocalAddress' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.ActorStatePacket
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FActorStatePacket final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorStatePacket) == 0x000008, "Wrong alignment on FActorStatePacket");
static_assert(sizeof(FActorStatePacket) == 0x000028, "Wrong size on FActorStatePacket");

// ScriptStruct InfiniteGameWorlds.GlobalActorHandle
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FGlobalActorHandle final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalActorHandle) == 0x000004, "Wrong alignment on FGlobalActorHandle");
static_assert(sizeof(FGlobalActorHandle) == 0x000014, "Wrong size on FGlobalActorHandle");

// ScriptStruct InfiniteGameWorlds.PlayerDataEntry
// 0x001C (0x0028 - 0x000C)
struct FPlayerDataEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataEntry) == 0x000008, "Wrong alignment on FPlayerDataEntry");
static_assert(sizeof(FPlayerDataEntry) == 0x000028, "Wrong size on FPlayerDataEntry");
static_assert(offsetof(FPlayerDataEntry, Location) == 0x000010, "Member 'FPlayerDataEntry::Location' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.PlayerDataArray
// 0x0010 (0x0138 - 0x0128)
struct FPlayerDataArray final : public FFastArraySerializer
{
public:
	TArray<struct FPlayerDataEntry>               PlayerData;                                        // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDataArray) == 0x000008, "Wrong alignment on FPlayerDataArray");
static_assert(sizeof(FPlayerDataArray) == 0x000138, "Wrong size on FPlayerDataArray");
static_assert(offsetof(FPlayerDataArray, PlayerData) == 0x000128, "Member 'FPlayerDataArray::PlayerData' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.AreaBlocker
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FAreaBlocker final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAreaBlocker) == 0x000008, "Wrong alignment on FAreaBlocker");
static_assert(sizeof(FAreaBlocker) == 0x000038, "Wrong size on FAreaBlocker");

// ScriptStruct InfiniteGameWorlds.BlockedAreaSerializerItem
// 0x003C (0x0048 - 0x000C)
struct FBlockedAreaSerializerItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox2D                                 m_Box;                                             // 0x0010(0x0028)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FServerID                              m_ServerID;                                        // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockedAreaSerializerItem) == 0x000008, "Wrong alignment on FBlockedAreaSerializerItem");
static_assert(sizeof(FBlockedAreaSerializerItem) == 0x000048, "Wrong size on FBlockedAreaSerializerItem");
static_assert(offsetof(FBlockedAreaSerializerItem, m_Box) == 0x000010, "Member 'FBlockedAreaSerializerItem::m_Box' has a wrong offset!");
static_assert(offsetof(FBlockedAreaSerializerItem, m_ServerID) == 0x000038, "Member 'FBlockedAreaSerializerItem::m_ServerID' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.AreaBlockerArray
// 0x0010 (0x0138 - 0x0128)
struct FAreaBlockerArray final : public FFastArraySerializer
{
public:
	TArray<struct FBlockedAreaSerializerItem>     m_BlockedAreas;                                    // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAreaBlockerArray) == 0x000008, "Wrong alignment on FAreaBlockerArray");
static_assert(sizeof(FAreaBlockerArray) == 0x000138, "Wrong size on FAreaBlockerArray");
static_assert(offsetof(FAreaBlockerArray, m_BlockedAreas) == 0x000128, "Member 'FAreaBlockerArray::m_BlockedAreas' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.IgwActorPointer
// 0x0008 (0x0008 - 0x0000)
struct FIgwActorPointer final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIgwActorPointer) == 0x000004, "Wrong alignment on FIgwActorPointer");
static_assert(sizeof(FIgwActorPointer) == 0x000008, "Wrong size on FIgwActorPointer");
static_assert(offsetof(FIgwActorPointer, Actor) == 0x000000, "Member 'FIgwActorPointer::Actor' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.IgwActorComponentPointer
// 0x0008 (0x0008 - 0x0000)
struct FIgwActorComponentPointer final
{
public:
	TWeakObjectPtr<class UActorComponent>         ActorComponent;                                    // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIgwActorComponentPointer) == 0x000004, "Wrong alignment on FIgwActorComponentPointer");
static_assert(sizeof(FIgwActorComponentPointer) == 0x000008, "Wrong size on FIgwActorComponentPointer");
static_assert(offsetof(FIgwActorComponentPointer, ActorComponent) == 0x000000, "Member 'FIgwActorComponentPointer::ActorComponent' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.ActorGlobalIDRepl
// 0x0000 (0x0020 - 0x0020)
struct FActorGlobalIDRepl final : public FActorGlobalID
{
};
static_assert(alignof(FActorGlobalIDRepl) == 0x000008, "Wrong alignment on FActorGlobalIDRepl");
static_assert(sizeof(FActorGlobalIDRepl) == 0x000020, "Wrong size on FActorGlobalIDRepl");

// ScriptStruct InfiniteGameWorlds.PartitionDefinitionRepl
// 0x0000 (0x0068 - 0x0068)
struct FPartitionDefinitionRepl final : public FPartitionDefinition
{
};
static_assert(alignof(FPartitionDefinitionRepl) == 0x000008, "Wrong alignment on FPartitionDefinitionRepl");
static_assert(sizeof(FPartitionDefinitionRepl) == 0x000068, "Wrong size on FPartitionDefinitionRepl");

// ScriptStruct InfiniteGameWorlds.ElectionData
// 0x0020 (0x0020 - 0x0000)
struct FElectionData
{
public:
	ES2SServerRole                                Role;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Term;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FServerID                              LastVotedFor;                                      // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentServerIndex;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentDimensionIndex;                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElectionData) == 0x000004, "Wrong alignment on FElectionData");
static_assert(sizeof(FElectionData) == 0x000020, "Wrong size on FElectionData");
static_assert(offsetof(FElectionData, Role) == 0x000000, "Member 'FElectionData::Role' has a wrong offset!");
static_assert(offsetof(FElectionData, Term) == 0x000004, "Member 'FElectionData::Term' has a wrong offset!");
static_assert(offsetof(FElectionData, LastVotedFor) == 0x000008, "Member 'FElectionData::LastVotedFor' has a wrong offset!");
static_assert(offsetof(FElectionData, CurrentServerIndex) == 0x000018, "Member 'FElectionData::CurrentServerIndex' has a wrong offset!");
static_assert(offsetof(FElectionData, CurrentDimensionIndex) == 0x00001C, "Member 'FElectionData::CurrentDimensionIndex' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.MapElectionData
// 0x0008 (0x0028 - 0x0020)
struct FMapElectionData final : public FElectionData
{
public:
	class FName                                   MapName;                                           // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapElectionData) == 0x000004, "Wrong alignment on FMapElectionData");
static_assert(sizeof(FMapElectionData) == 0x000028, "Wrong size on FMapElectionData");
static_assert(offsetof(FMapElectionData, MapName) == 0x000020, "Member 'FMapElectionData::MapName' has a wrong offset!");

// ScriptStruct InfiniteGameWorlds.S2sControllerTickFunction
// 0x0008 (0x0060 - 0x0058)
struct FS2sControllerTickFunction : public FTickFunction
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS2sControllerTickFunction) == 0x000008, "Wrong alignment on FS2sControllerTickFunction");
static_assert(sizeof(FS2sControllerTickFunction) == 0x000060, "Wrong size on FS2sControllerTickFunction");

// ScriptStruct InfiniteGameWorlds.FarmHealthTickFunction
// 0x0000 (0x0060 - 0x0060)
struct FFarmHealthTickFunction final : public FS2sControllerTickFunction
{
};
static_assert(alignof(FFarmHealthTickFunction) == 0x000008, "Wrong alignment on FFarmHealthTickFunction");
static_assert(sizeof(FFarmHealthTickFunction) == 0x000060, "Wrong size on FFarmHealthTickFunction");

// ScriptStruct InfiniteGameWorlds.S2sControllerPostUpdateWorkTickFunction
// 0x0008 (0x0060 - 0x0058)
struct FS2sControllerPostUpdateWorkTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FS2sControllerPostUpdateWorkTickFunction) == 0x000008, "Wrong alignment on FS2sControllerPostUpdateWorkTickFunction");
static_assert(sizeof(FS2sControllerPostUpdateWorkTickFunction) == 0x000060, "Wrong size on FS2sControllerPostUpdateWorkTickFunction");

// ScriptStruct InfiniteGameWorlds.ServerDebugData
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FServerDebugData final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerDebugData) == 0x000008, "Wrong alignment on FServerDebugData");
static_assert(sizeof(FServerDebugData) == 0x0000A0, "Wrong size on FServerDebugData");

// ScriptStruct InfiniteGameWorlds.FarmTime
// 0x0018 (0x0018 - 0x0000)
struct FFarmTime final
{
public:
	struct FDateTime                              StartTime;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              DownDuration;                                      // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFarmTimeReady;                                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFarmTime) == 0x000008, "Wrong alignment on FFarmTime");
static_assert(sizeof(FFarmTime) == 0x000018, "Wrong size on FFarmTime");
static_assert(offsetof(FFarmTime, StartTime) == 0x000000, "Member 'FFarmTime::StartTime' has a wrong offset!");
static_assert(offsetof(FFarmTime, DownDuration) == 0x000008, "Member 'FFarmTime::DownDuration' has a wrong offset!");
static_assert(offsetof(FFarmTime, bIsFarmTimeReady) == 0x000010, "Member 'FFarmTime::bIsFarmTimeReady' has a wrong offset!");

}


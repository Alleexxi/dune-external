#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UE4Dreamworld

#include "Basic.hpp"

#include "UE4Dreamworld_classes.hpp"
#include "UE4Dreamworld_parameters.hpp"


namespace SDK
{

// Function UE4Dreamworld.PersistenceUtilsBpLibrary.GetActorUID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueID                        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueID UPersistenceUtilsBpLibrary::GetActorUID(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PersistenceUtilsBpLibrary", "GetActorUID");

	Params::PersistenceUtilsBpLibrary_GetActorUID Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.MetricsReporter.Reset
// (Native, Public, BlueprintCallable)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricsReporter::Reset(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricsReporter", "Reset");

	Params::MetricsReporter_Reset Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.MetricsReporter.SetResetInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricsReporter::SetResetInterval(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricsReporter", "SetResetInterval");

	Params::MetricsReporter_SetResetInterval Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.MetricsReporter.Tick
// (Native, Public, BlueprintCallable)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricsReporter::Tick(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricsReporter", "Tick");

	Params::MetricsReporter_Tick Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.MetricsReporter.GetResetInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMetricsReporter::GetResetInterval() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricsReporter", "GetResetInterval");

	Params::MetricsReporter_GetResetInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.CacheModule.CacheItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   KeepAliveTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACacheModule::CacheItem(class UObject* Asset, float KeepAliveTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CacheModule", "CacheItem");

	Params::CacheModule_CacheItem Parms{};

	Parms.Asset = Asset;
	Parms.KeepAliveTime = KeepAliveTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.CacheModule.Flush
// (Final, Native, Public, BlueprintCallable)

void ACacheModule::Flush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CacheModule", "Flush");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.QuadtreeComponent.OnQuadTreeUpdated
// (Event, Public, BlueprintEvent)

void UQuadtreeComponent::OnQuadTreeUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuadtreeComponent", "OnQuadTreeUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UE4Dreamworld.QuadTreeFunctionLibrary.GetOverlappingActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       TreeName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SpherePos                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OverlappingActors                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuadTreeFunctionLibrary::GetOverlappingActors(const class UObject* WorldContextObject, const class FName TreeName, const struct FVector& SpherePos, float SphereRadius, TSubclassOf<class AActor> ActorClass, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OverlappingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuadTreeFunctionLibrary", "GetOverlappingActors");

	Params::QuadTreeFunctionLibrary_GetOverlappingActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TreeName = TreeName;
	Parms.SpherePos = std::move(SpherePos);
	Parms.SphereRadius = SphereRadius;
	Parms.ActorClass = ActorClass;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OverlappingActors != nullptr)
		*OverlappingActors = std::move(Parms.OverlappingActors);

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.BudgetKeeper.CheckPerformanceBudgets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   FrameCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBudgetKeeper::CheckPerformanceBudgets(int32 FrameCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BudgetKeeper", "CheckPerformanceBudgets");

	Params::BudgetKeeper_CheckPerformanceBudgets Parms{};

	Parms.FrameCount = FrameCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.FrameRateTracker.GetAverageFps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateTracker::GetAverageFps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "GetAverageFps");

	Params::FrameRateTracker_GetAverageFps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.FrameRateTracker.GetAverageFrameTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateTracker::GetAverageFrameTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "GetAverageFrameTime");

	Params::FrameRateTracker_GetAverageFrameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.FrameRateTracker.GetBestFps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateTracker::GetBestFps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "GetBestFps");

	Params::FrameRateTracker_GetBestFps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.FrameRateTracker.GetBestFrameTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateTracker::GetBestFrameTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "GetBestFrameTime");

	Params::FrameRateTracker_GetBestFrameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.FrameRateTracker.GetElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateTracker::GetElapsedTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "GetElapsedTime");

	Params::FrameRateTracker_GetElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.FrameRateTracker.GetWorstFps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateTracker::GetWorstFps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "GetWorstFps");

	Params::FrameRateTracker_GetWorstFps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.FrameRateTracker.GetWorstFrameTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateTracker::GetWorstFrameTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "GetWorstFrameTime");

	Params::FrameRateTracker_GetWorstFrameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.FrameRateTracker.K2_GetFrameCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFrameRateTracker::K2_GetFrameCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrameRateTracker", "K2_GetFrameCount");

	Params::FrameRateTracker_K2_GetFrameCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.ApplyRadialDamageAsync
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoFullDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UApplyRadialDamageWithFalloffProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UApplyRadialDamageWithFalloffProxy* UApplyRadialDamageWithFalloffProxy::ApplyRadialDamageAsync(const class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ApplyRadialDamageWithFalloffProxy", "ApplyRadialDamageAsync");

	Params::ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageRadius = DamageRadius;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.bDoFullDamage = bDoFullDamage;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.ApplyRadialDamageWithFalloffAsync
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinimumDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageInnerRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageOuterRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageFalloff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UApplyRadialDamageWithFalloffProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UApplyRadialDamageWithFalloffProxy* UApplyRadialDamageWithFalloffProxy::ApplyRadialDamageWithFalloffAsync(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ApplyRadialDamageWithFalloffProxy", "ApplyRadialDamageWithFalloffAsync");

	Params::ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.MinimumDamage = MinimumDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageInnerRadius = DamageInnerRadius;
	Parms.DamageOuterRadius = DamageOuterRadius;
	Parms.DamageFalloff = DamageFalloff;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.BeginApplyRadialDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoFullDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UApplyRadialDamageWithFalloffProxy::BeginApplyRadialDamage(const class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ApplyRadialDamageWithFalloffProxy", "BeginApplyRadialDamage");

	Params::ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageRadius = DamageRadius;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.bDoFullDamage = bDoFullDamage;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.BeginApplyRadialDamageWithFalloff
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinimumDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageInnerRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageOuterRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageFalloff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UApplyRadialDamageWithFalloffProxy::BeginApplyRadialDamageWithFalloff(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ApplyRadialDamageWithFalloffProxy", "BeginApplyRadialDamageWithFalloff");

	Params::ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.MinimumDamage = MinimumDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageInnerRadius = DamageInnerRadius;
	Parms.DamageOuterRadius = DamageOuterRadius;
	Parms.DamageFalloff = DamageFalloff;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.AsyncLineTraceByChannelProxy.AsyncLineTraceByChannel
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncLineTraceByChannelProxy*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncLineTraceByChannelProxy* UAsyncLineTraceByChannelProxy::AsyncLineTraceByChannel(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncLineTraceByChannelProxy", "AsyncLineTraceByChannel");

	Params::AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.ChangeMaxRelevancyScaling
// (Final, Exec, Native, Static, Public)
// Parameters:
// float                                   Scaling                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamworldBlueprints::ChangeMaxRelevancyScaling(float Scaling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "ChangeMaxRelevancyScaling");

	Params::DreamworldBlueprints_ChangeMaxRelevancyScaling Parms{};

	Parms.Scaling = Scaling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DreamworldBlueprints.ClearUniqueID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamworldBlueprints::ClearUniqueID(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "ClearUniqueID");

	Params::DreamworldBlueprints_ClearUniqueID Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DreamworldBlueprints.ClientGetPlayerId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDreamworldBlueprints::ClientGetPlayerId(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "ClientGetPlayerId");

	Params::DreamworldBlueprints_ClientGetPlayerId Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.Conv_UniqueIDToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUniqueID&                 UID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDreamworldBlueprints::Conv_UniqueIDToString(const struct FUniqueID& UID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "Conv_UniqueIDToString");

	Params::DreamworldBlueprints_Conv_UniqueIDToString Parms{};

	Parms.UID = std::move(UID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.Conv_UUIDToText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUniqueID&                 Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDreamworldBlueprints::Conv_UUIDToText(const struct FUniqueID& Value, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "Conv_UUIDToText");

	Params::DreamworldBlueprints_Conv_UUIDToText Parms{};

	Parms.Value = std::move(Value);
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.EqualEqual_UUIDUUID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUniqueID&                 A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUniqueID&                 B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::EqualEqual_UUIDUUID(const struct FUniqueID& A, const struct FUniqueID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "EqualEqual_UUIDUUID");

	Params::DreamworldBlueprints_EqualEqual_UUIDUUID Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.GenerateBugReport
// (Final, Native, Static, Public, BlueprintCallable)

void UDreamworldBlueprints::GenerateBugReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "GenerateBugReport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DreamworldBlueprints.GetClassDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDreamworldBlueprints::GetClassDefaultObject(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "GetClassDefaultObject");

	Params::DreamworldBlueprints_GetClassDefaultObject Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.GetConsoleUserIdOverride
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDreamworldBlueprints::GetConsoleUserIdOverride(const class FString& UserId, class APlayerController* Controller, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "GetConsoleUserIdOverride");

	Params::DreamworldBlueprints_GetConsoleUserIdOverride Parms{};

	Parms.UserId = std::move(UserId);
	Parms.Controller = Controller;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.GetDreamworldVersion
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Branch                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Project                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          configuration                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString*                          Platform                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  Revision                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  base_revision                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  Snapshot                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamworldBlueprints::GetDreamworldVersion(class UObject* WorldContextObject, class FString* Branch, class FString* Project, class FString* configuration, class FString* Platform, int32* Revision, int32* base_revision, int32* Snapshot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "GetDreamworldVersion");

	Params::DreamworldBlueprints_GetDreamworldVersion Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branch != nullptr)
		*Branch = std::move(Parms.Branch);

	if (Project != nullptr)
		*Project = std::move(Parms.Project);

	if (configuration != nullptr)
		*configuration = std::move(Parms.configuration);

	if (Platform != nullptr)
		*Platform = std::move(Parms.Platform);

	if (Revision != nullptr)
		*Revision = Parms.Revision;

	if (base_revision != nullptr)
		*base_revision = Parms.base_revision;

	if (Snapshot != nullptr)
		*Snapshot = Parms.Snapshot;
}


// Function UE4Dreamworld.DreamworldBlueprints.GetNumStressClients
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDreamworldBlueprints::GetNumStressClients(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "GetNumStressClients");

	Params::DreamworldBlueprints_GetNumStressClients Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.GetPlayerId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDreamworldBlueprints::GetPlayerId(class UObject* WorldContextObject, class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "GetPlayerId");

	Params::DreamworldBlueprints_GetPlayerId Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.GetServerName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDreamworldBlueprints::GetServerName(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "GetServerName");

	Params::DreamworldBlueprints_GetServerName Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.IsDedicatedSession
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::IsDedicatedSession(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "IsDedicatedSession");

	Params::DreamworldBlueprints_IsDedicatedSession Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.IsDeveloperMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::IsDeveloperMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "IsDeveloperMode");

	Params::DreamworldBlueprints_IsDeveloperMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.IsDeveloperUniverse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::IsDeveloperUniverse(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "IsDeveloperUniverse");

	Params::DreamworldBlueprints_IsDeveloperUniverse Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.IsInTrialMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::IsInTrialMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "IsInTrialMode");

	Params::DreamworldBlueprints_IsInTrialMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.IsSessionJoinable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bPublicJoinable                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bFriendJoinable                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bInviteOnly                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bAllowInvites                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::IsSessionJoinable(class UObject* WorldContextObject, bool* bPublicJoinable, bool* bFriendJoinable, bool* bInviteOnly, bool* bAllowInvites)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "IsSessionJoinable");

	Params::DreamworldBlueprints_IsSessionJoinable Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bPublicJoinable != nullptr)
		*bPublicJoinable = Parms.bPublicJoinable;

	if (bFriendJoinable != nullptr)
		*bFriendJoinable = Parms.bFriendJoinable;

	if (bInviteOnly != nullptr)
		*bInviteOnly = Parms.bInviteOnly;

	if (bAllowInvites != nullptr)
		*bAllowInvites = Parms.bAllowInvites;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.IsStressClient
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::IsStressClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "IsStressClient");

	Params::DreamworldBlueprints_IsStressClient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.IsValidUniqueID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUniqueID&                 UniqueID                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::IsValidUniqueID(const struct FUniqueID& UniqueID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "IsValidUniqueID");

	Params::DreamworldBlueprints_IsValidUniqueID Parms{};

	Parms.UniqueID = std::move(UniqueID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.NotEqual_UUIDUUID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FUniqueID&                 A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUniqueID&                 B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::NotEqual_UUIDUUID(const struct FUniqueID& A, const struct FUniqueID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "NotEqual_UUIDUUID");

	Params::DreamworldBlueprints_NotEqual_UUIDUUID Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.PresenceSession
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::PresenceSession(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "PresenceSession");

	Params::DreamworldBlueprints_PresenceSession Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.SetUniqueID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUniqueID&                 UID                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamworldBlueprints::SetUniqueID(class AActor* Actor, const struct FUniqueID& UID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "SetUniqueID");

	Params::DreamworldBlueprints_SetUniqueID Parms{};

	Parms.Actor = Actor;
	Parms.UID = std::move(UID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DreamworldBlueprints.ShowAccountPicker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamworldBlueprints::ShowAccountPicker(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "ShowAccountPicker");

	Params::DreamworldBlueprints_ShowAccountPicker Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DreamworldBlueprints.SphereTraceSingleCollision
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::SphereTraceSingleCollision(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ECollisionChannel CollisionChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "SphereTraceSingleCollision");

	Params::DreamworldBlueprints_SphereTraceSingleCollision Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.CollisionChannel = CollisionChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.StreamPlayerStartLevels
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFlush                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamworldBlueprints::StreamPlayerStartLevels(class UObject* WorldContextObject, bool bFlush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "StreamPlayerStartLevels");

	Params::DreamworldBlueprints_StreamPlayerStartLevels Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bFlush = bFlush;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DreamworldBlueprints.ValidateOnlineSession
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBlueprintSessionResult&   Session                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDreamworldBlueprints::ValidateOnlineSession(class UObject* WorldContextObject, const struct FBlueprintSessionResult& Session)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "ValidateOnlineSession");

	Params::DreamworldBlueprints_ValidateOnlineSession Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Session = std::move(Session);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DreamworldBlueprints.ValidateOnlineSessions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FBlueprintSessionResult>&Search                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FBlueprintSessionResult>* Valid                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FBlueprintSessionResult>* Invalid                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDreamworldBlueprints::ValidateOnlineSessions(class UObject* WorldContextObject, const TArray<struct FBlueprintSessionResult>& Search, TArray<struct FBlueprintSessionResult>* Valid, TArray<struct FBlueprintSessionResult>* Invalid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DreamworldBlueprints", "ValidateOnlineSessions");

	Params::DreamworldBlueprints_ValidateOnlineSessions Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Search = std::move(Search);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Valid != nullptr)
		*Valid = std::move(Parms.Valid);

	if (Invalid != nullptr)
		*Invalid = std::move(Parms.Invalid);
}


// Function UE4Dreamworld.DWCheatManager.CrashServer
// (Exec, Native, Public)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDWCheatManager::CrashServer(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DWCheatManager", "CrashServer");

	Params::DWCheatManager_CrashServer Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DWCheatManager.SimulateNetworkFailure
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ConnectionIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetworkFailure                         FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDWCheatManager::SimulateNetworkFailure(int32 ConnectionIndex, ENetworkFailure FailureType, bool bServer, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DWCheatManager", "SimulateNetworkFailure");

	Params::DWCheatManager_SimulateNetworkFailure Parms{};

	Parms.ConnectionIndex = ConnectionIndex;
	Parms.FailureType = FailureType;
	Parms.bServer = bServer;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DWCheatManager.SummonPersistent
// (Exec, Native, Public)
// Parameters:
// const class FString&                    ClassName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDWCheatManager::SummonPersistent(const class FString& ClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DWCheatManager", "SummonPersistent");

	Params::DWCheatManager_SummonPersistent Parms{};

	Parms.ClassName = std::move(ClassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DWDebugLibrary.SaveScreenshot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDWDebugLibrary::SaveScreenshot(class UObject* WorldContextObject, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DWDebugLibrary", "SaveScreenshot");

	Params::DWDebugLibrary_SaveScreenshot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.TsomTestDummy.GetFavoriteNumber
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTsomTestDummy::GetFavoriteNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TsomTestDummy", "GetFavoriteNumber");

	Params::TsomTestDummy_GetFavoriteNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.DWReplicationGraph.AddDependentActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Child                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDWReplicationGraph::AddDependentActor(class AActor* Parent, class AActor* Child)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DWReplicationGraph", "AddDependentActor");

	Params::DWReplicationGraph_AddDependentActor Parms{};

	Parms.Parent = Parent;
	Parms.Child = Child;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.DWReplicationGraph.RemoveDependentActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Child                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDWReplicationGraph::RemoveDependentActor(class AActor* Parent, class AActor* Child)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DWReplicationGraph", "RemoveDependentActor");

	Params::DWReplicationGraph_RemoveDependentActor Parms{};

	Parms.Parent = Parent;
	Parms.Child = Child;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidator.GatherWorldData
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidator::GatherWorldData(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "GatherWorldData");

	Params::SceneValidator_GatherWorldData Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidator.GatherWorldSectionData
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FValidationWorldSection&   WorldSection                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USceneValidator::GatherWorldSectionData(class UWorld* World, const struct FValidationWorldSection& WorldSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "GatherWorldSectionData");

	Params::SceneValidator_GatherWorldSectionData Parms{};

	Parms.World = World;
	Parms.WorldSection = std::move(WorldSection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidator.GatherWorldSectionStats
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FValidationWorldSection&   WorldSection                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USceneValidator::GatherWorldSectionStats(class UWorld* World, const struct FValidationWorldSection& WorldSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "GatherWorldSectionStats");

	Params::SceneValidator_GatherWorldSectionStats Parms{};

	Parms.World = World;
	Parms.WorldSection = std::move(WorldSection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidator.GatherWorldStats
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidator::GatherWorldStats(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "GatherWorldStats");

	Params::SceneValidator_GatherWorldStats Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidator.ValidateWorld
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSectionsPassedValidation                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneValidator::ValidateWorld(bool bSectionsPassedValidation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "ValidateWorld");

	Params::SceneValidator_ValidateWorld Parms{};

	Parms.bSectionsPassedValidation = bSectionsPassedValidation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.SceneValidator.ValidateWorldSection
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FValidationWorldSection&   WorldSection                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneValidator::ValidateWorldSection(const struct FValidationWorldSection& WorldSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "ValidateWorldSection");

	Params::SceneValidator_ValidateWorldSection Parms{};

	Parms.WorldSection = std::move(WorldSection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.SceneValidator.WriteKeyToStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidator::WriteKeyToStats(const class FString& Key, int32 Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "WriteKeyToStats");

	Params::SceneValidator_WriteKeyToStats Parms{};

	Parms.Key = std::move(Key);
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidator.WriteToStats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStruct*                          Data                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidator::WriteToStats(class UStruct* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "WriteToStats");

	Params::SceneValidator_WriteToStats Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidator.GetValidationWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* USceneValidator::GetValidationWorld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "GetValidationWorld");

	Params::SceneValidator_GetValidationWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.SceneValidator.GetWorldSections
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FValidationWorldSection>* OutSections                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeEditor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidator::GetWorldSections(TArray<struct FValidationWorldSection>* OutSections, bool bIncludeEditor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "GetWorldSections");

	Params::SceneValidator_GetWorldSections Parms{};

	Parms.bIncludeEditor = bIncludeEditor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSections != nullptr)
		*OutSections = std::move(Parms.OutSections);
}


// Function UE4Dreamworld.SceneValidator.GetWorldSectionsForBox
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBox&                      Box                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FValidationWorldSection>* OutSections                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeEditor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutClamped                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidator::GetWorldSectionsForBox(const struct FBox& Box, TArray<struct FValidationWorldSection>* OutSections, bool bIncludeEditor, bool* bOutClamped) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneValidator", "GetWorldSectionsForBox");

	Params::SceneValidator_GetWorldSectionsForBox Parms{};

	Parms.Box = std::move(Box);
	Parms.bIncludeEditor = bIncludeEditor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSections != nullptr)
		*OutSections = std::move(Parms.OutSections);

	if (bOutClamped != nullptr)
		*bOutClamped = Parms.bOutClamped;
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.AddValidationError
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    ContextObj                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      SectionBounds                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::AddValidationError(const class FString& Message, const class UObject* ContextObj, const struct FBox& SectionBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "AddValidationError");

	Params::SceneValidatorFunctionLibrary_AddValidationError Parms{};

	Parms.Message = std::move(Message);
	Parms.ContextObj = ContextObj;
	Parms.SectionBounds = std::move(SectionBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.AddValidationInfo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    ContextObj                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      SectionBounds                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::AddValidationInfo(const class FString& Message, const class UObject* ContextObj, const struct FBox& SectionBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "AddValidationInfo");

	Params::SceneValidatorFunctionLibrary_AddValidationInfo Parms{};

	Parms.Message = std::move(Message);
	Parms.ContextObj = ContextObj;
	Parms.SectionBounds = std::move(SectionBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.AddValidationWarning
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    ContextObj                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      SectionBounds                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::AddValidationWarning(const class FString& Message, const class UObject* ContextObj, const struct FBox& SectionBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "AddValidationWarning");

	Params::SceneValidatorFunctionLibrary_AddValidationWarning Parms{};

	Parms.Message = std::move(Message);
	Parms.ContextObj = ContextObj;
	Parms.SectionBounds = std::move(SectionBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.ConditionalBreakpoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bBreak                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::ConditionalBreakpoint(bool bBreak)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "ConditionalBreakpoint");

	Params::SceneValidatorFunctionLibrary_ConditionalBreakpoint Parms{};

	Parms.bBreak = bBreak;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetAllObjectsOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UObject*>*                 OutObjects                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeEditorOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::GetAllObjectsOfClass(TArray<class UObject*>* OutObjects, class UClass* Class_0, class UWorld* World, bool bIncludeEditorOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "GetAllObjectsOfClass");

	Params::SceneValidatorFunctionLibrary_GetAllObjectsOfClass Parms{};

	Parms.Class_0 = Class_0;
	Parms.World = World;
	Parms.bIncludeEditorOnly = bIncludeEditorOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutObjects != nullptr)
		*OutObjects = std::move(Parms.OutObjects);
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetCollisionTransforms
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FTransform>*              OutCollisionTransforms                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::GetCollisionTransforms(class UPrimitiveComponent* PrimitiveComponent, const struct FBox& Bounds, TArray<struct FTransform>* OutCollisionTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "GetCollisionTransforms");

	Params::SceneValidatorFunctionLibrary_GetCollisionTransforms Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCollisionTransforms != nullptr)
		*OutCollisionTransforms = std::move(Parms.OutCollisionTransforms);
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetNumCollisionTris
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USceneValidatorFunctionLibrary::GetNumCollisionTris(class UPrimitiveComponent* PrimitiveComponent, const struct FBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "GetNumCollisionTris");

	Params::SceneValidatorFunctionLibrary_GetNumCollisionTris Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetTriangleCount
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int64*                                  NaniteTriangles                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64*                                  Triangles                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64*                                  BodyCount                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::GetTriangleCount(class UPrimitiveComponent* PrimitiveComponent, const struct FBox& Bounds, int64* NaniteTriangles, int64* Triangles, int64* BodyCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "GetTriangleCount");

	Params::SceneValidatorFunctionLibrary_GetTriangleCount Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NaniteTriangles != nullptr)
		*NaniteTriangles = Parms.NaniteTriangles;

	if (Triangles != nullptr)
		*Triangles = Parms.Triangles;

	if (BodyCount != nullptr)
		*BodyCount = Parms.BodyCount;
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.OverlapMultiByChannelForBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FBoxOverlapResult>*       OutOverlaps                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const ECollisionChannel                 Channel                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EBoxOverlapMobilityType           MobilityType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::OverlapMultiByChannelForBox(TArray<struct FBoxOverlapResult>* OutOverlaps, const class UWorld* World, const struct FBox& Box, const ECollisionChannel Channel, const EBoxOverlapMobilityType MobilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "OverlapMultiByChannelForBox");

	Params::SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox Parms{};

	Parms.World = World;
	Parms.Box = std::move(Box);
	Parms.Channel = Channel;
	Parms.MobilityType = MobilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverlaps != nullptr)
		*OutOverlaps = std::move(Parms.OutOverlaps);
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.SortArrayWithComparisonValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<int32>&                    inArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<int32>&                    ComparisonValues                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutArray                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::SortArrayWithComparisonValues(const TArray<int32>& inArray, const TArray<int32>& ComparisonValues, TArray<int32>* OutArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "SortArrayWithComparisonValues");

	Params::SceneValidatorFunctionLibrary_SortArrayWithComparisonValues Parms{};

	Parms.inArray = std::move(inArray);
	Parms.ComparisonValues = std::move(ComparisonValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutArray != nullptr)
		*OutArray = std::move(Parms.OutArray);
}


// Function UE4Dreamworld.SceneValidatorFunctionLibrary.SweepSingleByChannelForBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   BoxExtent                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rot                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneValidatorFunctionLibrary::SweepSingleByChannelForBox(struct FHitResult* OutHit, const class UWorld* World, const struct FVector& BoxExtent, const struct FVector& Start, const struct FVector& End, const struct FQuat& Rot, ECollisionChannel TraceChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneValidatorFunctionLibrary", "SweepSingleByChannelForBox");

	Params::SceneValidatorFunctionLibrary_SweepSingleByChannelForBox Parms{};

	Parms.World = World;
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Rot = std::move(Rot);
	Parms.TraceChannel = TraceChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);
}

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: W_SpiceAddictionStatus

#include "Basic.hpp"

#include "W_SpiceAddictionStatus_classes.hpp"
#include "W_SpiceAddictionStatus_parameters.hpp"


namespace SDK
{

// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.Tick
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// const struct FGeometry&                 MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// float                                   InDeltaTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::Tick(const struct FGeometry& MyGeometry, float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "Tick");

	Params::W_SpiceAddictionStatus_C_Tick Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.SetEffectEntriesEnabled
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UListView*                        Effect_List                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Is_Enabled                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::SetEffectEntriesEnabled(class UListView* Effect_List, bool Is_Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "SetEffectEntriesEnabled");

	Params::W_SpiceAddictionStatus_C_SetEffectEntriesEnabled Parms{};

	Parms.Effect_List = Effect_List;
	Parms.Is_Enabled = Is_Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.RemoveExpiredEffectEntries
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UListView*                        Effect_List                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::RemoveExpiredEffectEntries(class UListView* Effect_List)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "RemoveExpiredEffectEntries");

	Params::W_SpiceAddictionStatus_C_RemoveExpiredEffectEntries Parms{};

	Parms.Effect_List = Effect_List;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.OnTemporaryEffectApplied
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FActiveGameplayEffectHandle&GameplayEffectHandle                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// const class USpiceAddictionGameplayEffectUIData*UIData                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::OnTemporaryEffectApplied(const struct FActiveGameplayEffectHandle& GameplayEffectHandle, const class USpiceAddictionGameplayEffectUIData* UIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "OnTemporaryEffectApplied");

	Params::W_SpiceAddictionStatus_C_OnTemporaryEffectApplied Parms{};

	Parms.GameplayEffectHandle = std::move(GameplayEffectHandle);
	Parms.UIData = UIData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.OnSpiceToleranceAmountChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             CurrentSpiceAmount                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const float                             MaxSpiceAmount                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::OnSpiceToleranceAmountChanged(const float CurrentSpiceAmount, const float MaxSpiceAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "OnSpiceToleranceAmountChanged");

	Params::W_SpiceAddictionStatus_C_OnSpiceToleranceAmountChanged Parms{};

	Parms.CurrentSpiceAmount = CurrentSpiceAmount;
	Parms.MaxSpiceAmount = MaxSpiceAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.OnSpiceExposureLevelChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             SpiceExposureLevel                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::OnSpiceExposureLevelChanged(const float SpiceExposureLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "OnSpiceExposureLevelChanged");

	Params::W_SpiceAddictionStatus_C_OnSpiceExposureLevelChanged Parms{};

	Parms.SpiceExposureLevel = SpiceExposureLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.OnSpiceAmountChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             CurrentSpiceAmount                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const float                             MaxSpiceAmount                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::OnSpiceAmountChanged(const float CurrentSpiceAmount, const float MaxSpiceAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "OnSpiceAmountChanged");

	Params::W_SpiceAddictionStatus_C_OnSpiceAmountChanged Parms{};

	Parms.CurrentSpiceAmount = CurrentSpiceAmount;
	Parms.MaxSpiceAmount = MaxSpiceAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.OnPulseOpacity
// (Event, Protected, BlueprintEvent)

void UW_SpiceAddictionStatus_C::OnPulseOpacity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "OnPulseOpacity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.OnPermanentEffectApplied
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FActiveGameplayEffectHandle&GameplayEffectHandle                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// const class USpiceAddictionGameplayEffectUIData*UIData                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::OnPermanentEffectApplied(const struct FActiveGameplayEffectHandle& GameplayEffectHandle, const class USpiceAddictionGameplayEffectUIData* UIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "OnPermanentEffectApplied");

	Params::W_SpiceAddictionStatus_C_OnPermanentEffectApplied Parms{};

	Parms.GameplayEffectHandle = std::move(GameplayEffectHandle);
	Parms.UIData = UIData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.OnEffectDisplayEnabledChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              bIsEffectDisplayEnabled                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::OnEffectDisplayEnabledChanged(const bool bIsEffectDisplayEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "OnEffectDisplayEnabledChanged");

	Params::W_SpiceAddictionStatus_C_OnEffectDisplayEnabledChanged Parms{};

	Parms.bIsEffectDisplayEnabled = bIsEffectDisplayEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.IsTrackingEffect
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FActiveGameplayEffectHandle&EffectHandle                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class UListView*                        EffectList                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool*                                   bIsTrackingEffect                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::IsTrackingEffect(const struct FActiveGameplayEffectHandle& EffectHandle, class UListView* EffectList, bool* bIsTrackingEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "IsTrackingEffect");

	Params::W_SpiceAddictionStatus_C_IsTrackingEffect Parms{};

	Parms.EffectHandle = std::move(EffectHandle);
	Parms.EffectList = EffectList;

	UObject::ProcessEvent(Func, &Parms);

	if (bIsTrackingEffect != nullptr)
		*bIsTrackingEffect = Parms.bIsTrackingEffect;
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.Finished_1C08B2D241CCA300D1E4DC81393463E0
// (BlueprintCallable, BlueprintEvent)

void UW_SpiceAddictionStatus_C::Finished_1C08B2D241CCA300D1E4DC81393463E0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "Finished_1C08B2D241CCA300D1E4DC81393463E0");

	UObject::ProcessEvent(Func, nullptr);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.ExecuteUbergraph_W_SpiceAddictionStatus
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::ExecuteUbergraph_W_SpiceAddictionStatus(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "ExecuteUbergraph_W_SpiceAddictionStatus");

	Params::W_SpiceAddictionStatus_C_ExecuteUbergraph_W_SpiceAddictionStatus Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.AddEffectEntry
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UListView*                        Effect_List                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FActiveGameplayEffectHandle&Gameplay_Effect_Handle                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash)
// class USpiceAddictionGameplayEffectUIData*Gameplay_Effect_UI_Data                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UW_SpiceAddictionStatus_C::AddEffectEntry(class UListView* Effect_List, const struct FActiveGameplayEffectHandle& Gameplay_Effect_Handle, class USpiceAddictionGameplayEffectUIData* Gameplay_Effect_UI_Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "AddEffectEntry");

	Params::W_SpiceAddictionStatus_C_AddEffectEntry Parms{};

	Parms.Effect_List = Effect_List;
	Parms.Gameplay_Effect_Handle = std::move(Gameplay_Effect_Handle);
	Parms.Gameplay_Effect_UI_Data = Gameplay_Effect_UI_Data;

	UObject::ProcessEvent(Func, &Parms);
}


// Function W_SpiceAddictionStatus.W_SpiceAddictionStatus_C.GetGameplayEffectsToTrack
// (Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// TArray<TSubclassOf<class UGameplayEffect>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper)

TArray<TSubclassOf<class UGameplayEffect>> UW_SpiceAddictionStatus_C::GetGameplayEffectsToTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("W_SpiceAddictionStatus_C", "GetGameplayEffectsToTrack");

	Params::W_SpiceAddictionStatus_C_GetGameplayEffectsToTrack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}


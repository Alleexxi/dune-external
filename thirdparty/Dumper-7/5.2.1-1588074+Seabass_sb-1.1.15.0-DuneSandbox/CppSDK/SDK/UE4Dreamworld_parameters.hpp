#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UE4Dreamworld

#include "Basic.hpp"

#include "PersistenceCore_structs.hpp"
#include "UE4Dreamworld_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "NetCore_structs.hpp"
#include "OnlineSubsystemUtils_structs.hpp"


namespace SDK::Params
{

// Function UE4Dreamworld.PersistenceUtilsBpLibrary.GetActorUID
// 0x0010 (0x0010 - 0x0000)
struct PersistenceUtilsBpLibrary_GetActorUID final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueID                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PersistenceUtilsBpLibrary_GetActorUID) == 0x000008, "Wrong alignment on PersistenceUtilsBpLibrary_GetActorUID");
static_assert(sizeof(PersistenceUtilsBpLibrary_GetActorUID) == 0x000010, "Wrong size on PersistenceUtilsBpLibrary_GetActorUID");
static_assert(offsetof(PersistenceUtilsBpLibrary_GetActorUID, Actor) == 0x000000, "Member 'PersistenceUtilsBpLibrary_GetActorUID::Actor' has a wrong offset!");
static_assert(offsetof(PersistenceUtilsBpLibrary_GetActorUID, ReturnValue) == 0x000008, "Member 'PersistenceUtilsBpLibrary_GetActorUID::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.MetricsReporter.Reset
// 0x0008 (0x0008 - 0x0000)
struct MetricsReporter_Reset final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MetricsReporter_Reset) == 0x000008, "Wrong alignment on MetricsReporter_Reset");
static_assert(sizeof(MetricsReporter_Reset) == 0x000008, "Wrong size on MetricsReporter_Reset");
static_assert(offsetof(MetricsReporter_Reset, World) == 0x000000, "Member 'MetricsReporter_Reset::World' has a wrong offset!");

// Function UE4Dreamworld.MetricsReporter.SetResetInterval
// 0x0004 (0x0004 - 0x0000)
struct MetricsReporter_SetResetInterval final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MetricsReporter_SetResetInterval) == 0x000004, "Wrong alignment on MetricsReporter_SetResetInterval");
static_assert(sizeof(MetricsReporter_SetResetInterval) == 0x000004, "Wrong size on MetricsReporter_SetResetInterval");
static_assert(offsetof(MetricsReporter_SetResetInterval, Value) == 0x000000, "Member 'MetricsReporter_SetResetInterval::Value' has a wrong offset!");

// Function UE4Dreamworld.MetricsReporter.Tick
// 0x0008 (0x0008 - 0x0000)
struct MetricsReporter_Tick final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MetricsReporter_Tick) == 0x000008, "Wrong alignment on MetricsReporter_Tick");
static_assert(sizeof(MetricsReporter_Tick) == 0x000008, "Wrong size on MetricsReporter_Tick");
static_assert(offsetof(MetricsReporter_Tick, World) == 0x000000, "Member 'MetricsReporter_Tick::World' has a wrong offset!");

// Function UE4Dreamworld.MetricsReporter.GetResetInterval
// 0x0004 (0x0004 - 0x0000)
struct MetricsReporter_GetResetInterval final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MetricsReporter_GetResetInterval) == 0x000004, "Wrong alignment on MetricsReporter_GetResetInterval");
static_assert(sizeof(MetricsReporter_GetResetInterval) == 0x000004, "Wrong size on MetricsReporter_GetResetInterval");
static_assert(offsetof(MetricsReporter_GetResetInterval, ReturnValue) == 0x000000, "Member 'MetricsReporter_GetResetInterval::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.CacheModule.CacheItem
// 0x0010 (0x0010 - 0x0000)
struct CacheModule_CacheItem final
{
public:
	class UObject*                                Asset;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepAliveTime;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CacheModule_CacheItem) == 0x000008, "Wrong alignment on CacheModule_CacheItem");
static_assert(sizeof(CacheModule_CacheItem) == 0x000010, "Wrong size on CacheModule_CacheItem");
static_assert(offsetof(CacheModule_CacheItem, Asset) == 0x000000, "Member 'CacheModule_CacheItem::Asset' has a wrong offset!");
static_assert(offsetof(CacheModule_CacheItem, KeepAliveTime) == 0x000008, "Member 'CacheModule_CacheItem::KeepAliveTime' has a wrong offset!");

// Function UE4Dreamworld.QuadTreeFunctionLibrary.GetOverlappingActors
// 0x0060 (0x0060 - 0x0000)
struct QuadTreeFunctionLibrary_GetOverlappingActors final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TreeName;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpherePos;                                         // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OverlappingActors;                                 // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(QuadTreeFunctionLibrary_GetOverlappingActors) == 0x000008, "Wrong alignment on QuadTreeFunctionLibrary_GetOverlappingActors");
static_assert(sizeof(QuadTreeFunctionLibrary_GetOverlappingActors) == 0x000060, "Wrong size on QuadTreeFunctionLibrary_GetOverlappingActors");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, WorldContextObject) == 0x000000, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, TreeName) == 0x000008, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::TreeName' has a wrong offset!");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, SpherePos) == 0x000010, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::SpherePos' has a wrong offset!");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, SphereRadius) == 0x000028, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::SphereRadius' has a wrong offset!");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, ActorClass) == 0x000030, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::ActorClass' has a wrong offset!");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, ActorsToIgnore) == 0x000038, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, OverlappingActors) == 0x000048, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::OverlappingActors' has a wrong offset!");
static_assert(offsetof(QuadTreeFunctionLibrary_GetOverlappingActors, ReturnValue) == 0x000058, "Member 'QuadTreeFunctionLibrary_GetOverlappingActors::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.BudgetKeeper.CheckPerformanceBudgets
// 0x0004 (0x0004 - 0x0000)
struct BudgetKeeper_CheckPerformanceBudgets final
{
public:
	int32                                         FrameCount;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BudgetKeeper_CheckPerformanceBudgets) == 0x000004, "Wrong alignment on BudgetKeeper_CheckPerformanceBudgets");
static_assert(sizeof(BudgetKeeper_CheckPerformanceBudgets) == 0x000004, "Wrong size on BudgetKeeper_CheckPerformanceBudgets");
static_assert(offsetof(BudgetKeeper_CheckPerformanceBudgets, FrameCount) == 0x000000, "Member 'BudgetKeeper_CheckPerformanceBudgets::FrameCount' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.GetAverageFps
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_GetAverageFps final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_GetAverageFps) == 0x000004, "Wrong alignment on FrameRateTracker_GetAverageFps");
static_assert(sizeof(FrameRateTracker_GetAverageFps) == 0x000004, "Wrong size on FrameRateTracker_GetAverageFps");
static_assert(offsetof(FrameRateTracker_GetAverageFps, ReturnValue) == 0x000000, "Member 'FrameRateTracker_GetAverageFps::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.GetAverageFrameTime
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_GetAverageFrameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_GetAverageFrameTime) == 0x000004, "Wrong alignment on FrameRateTracker_GetAverageFrameTime");
static_assert(sizeof(FrameRateTracker_GetAverageFrameTime) == 0x000004, "Wrong size on FrameRateTracker_GetAverageFrameTime");
static_assert(offsetof(FrameRateTracker_GetAverageFrameTime, ReturnValue) == 0x000000, "Member 'FrameRateTracker_GetAverageFrameTime::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.GetBestFps
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_GetBestFps final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_GetBestFps) == 0x000004, "Wrong alignment on FrameRateTracker_GetBestFps");
static_assert(sizeof(FrameRateTracker_GetBestFps) == 0x000004, "Wrong size on FrameRateTracker_GetBestFps");
static_assert(offsetof(FrameRateTracker_GetBestFps, ReturnValue) == 0x000000, "Member 'FrameRateTracker_GetBestFps::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.GetBestFrameTime
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_GetBestFrameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_GetBestFrameTime) == 0x000004, "Wrong alignment on FrameRateTracker_GetBestFrameTime");
static_assert(sizeof(FrameRateTracker_GetBestFrameTime) == 0x000004, "Wrong size on FrameRateTracker_GetBestFrameTime");
static_assert(offsetof(FrameRateTracker_GetBestFrameTime, ReturnValue) == 0x000000, "Member 'FrameRateTracker_GetBestFrameTime::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.GetElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_GetElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_GetElapsedTime) == 0x000004, "Wrong alignment on FrameRateTracker_GetElapsedTime");
static_assert(sizeof(FrameRateTracker_GetElapsedTime) == 0x000004, "Wrong size on FrameRateTracker_GetElapsedTime");
static_assert(offsetof(FrameRateTracker_GetElapsedTime, ReturnValue) == 0x000000, "Member 'FrameRateTracker_GetElapsedTime::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.GetWorstFps
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_GetWorstFps final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_GetWorstFps) == 0x000004, "Wrong alignment on FrameRateTracker_GetWorstFps");
static_assert(sizeof(FrameRateTracker_GetWorstFps) == 0x000004, "Wrong size on FrameRateTracker_GetWorstFps");
static_assert(offsetof(FrameRateTracker_GetWorstFps, ReturnValue) == 0x000000, "Member 'FrameRateTracker_GetWorstFps::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.GetWorstFrameTime
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_GetWorstFrameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_GetWorstFrameTime) == 0x000004, "Wrong alignment on FrameRateTracker_GetWorstFrameTime");
static_assert(sizeof(FrameRateTracker_GetWorstFrameTime) == 0x000004, "Wrong size on FrameRateTracker_GetWorstFrameTime");
static_assert(offsetof(FrameRateTracker_GetWorstFrameTime, ReturnValue) == 0x000000, "Member 'FrameRateTracker_GetWorstFrameTime::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.FrameRateTracker.K2_GetFrameCount
// 0x0004 (0x0004 - 0x0000)
struct FrameRateTracker_K2_GetFrameCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrameRateTracker_K2_GetFrameCount) == 0x000004, "Wrong alignment on FrameRateTracker_K2_GetFrameCount");
static_assert(sizeof(FrameRateTracker_K2_GetFrameCount) == 0x000004, "Wrong size on FrameRateTracker_K2_GetFrameCount");
static_assert(offsetof(FrameRateTracker_K2_GetFrameCount, ReturnValue) == 0x000000, "Member 'FrameRateTracker_K2_GetFrameCount::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.ApplyRadialDamageAsync
// 0x0068 (0x0068 - 0x0000)
struct ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedByController;                            // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoFullDamage;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamagePreventionChannel;                           // 0x0059(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UApplyRadialDamageWithFalloffProxy*     ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync) == 0x000008, "Wrong alignment on ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync");
static_assert(sizeof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync) == 0x000068, "Wrong size on ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, WorldContextObject) == 0x000000, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, BaseDamage) == 0x000008, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::BaseDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, Origin) == 0x000010, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::Origin' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, DamageRadius) == 0x000028, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::DamageRadius' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, DamageTypeClass) == 0x000030, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, IgnoreActors) == 0x000038, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::IgnoreActors' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, DamageCauser) == 0x000048, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::DamageCauser' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, InstigatedByController) == 0x000050, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::InstigatedByController' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, bDoFullDamage) == 0x000058, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::bDoFullDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, DamagePreventionChannel) == 0x000059, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::DamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync, ReturnValue) == 0x000060, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageAsync::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.ApplyRadialDamageWithFalloffAsync
// 0x0070 (0x0070 - 0x0000)
struct ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDamage;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageFalloff;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedByController;                            // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamagePreventionChannel;                           // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UApplyRadialDamageWithFalloffProxy*     ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync) == 0x000008, "Wrong alignment on ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync");
static_assert(sizeof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync) == 0x000070, "Wrong size on ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, WorldContextObject) == 0x000000, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, BaseDamage) == 0x000008, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::BaseDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, MinimumDamage) == 0x00000C, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::MinimumDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, Origin) == 0x000010, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::Origin' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, DamageInnerRadius) == 0x000028, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, DamageOuterRadius) == 0x00002C, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, DamageFalloff) == 0x000030, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::DamageFalloff' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, DamageTypeClass) == 0x000038, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, IgnoreActors) == 0x000040, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::IgnoreActors' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, DamageCauser) == 0x000050, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::DamageCauser' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, InstigatedByController) == 0x000058, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::InstigatedByController' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, DamagePreventionChannel) == 0x000060, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::DamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync, ReturnValue) == 0x000068, "Member 'ApplyRadialDamageWithFalloffProxy_ApplyRadialDamageWithFalloffAsync::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.BeginApplyRadialDamage
// 0x0060 (0x0060 - 0x0000)
struct ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedByController;                            // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoFullDamage;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamagePreventionChannel;                           // 0x0059(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage) == 0x000008, "Wrong alignment on ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage");
static_assert(sizeof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage) == 0x000060, "Wrong size on ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, WorldContextObject) == 0x000000, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, BaseDamage) == 0x000008, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::BaseDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, Origin) == 0x000010, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::Origin' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, DamageRadius) == 0x000028, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::DamageRadius' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, DamageTypeClass) == 0x000030, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, IgnoreActors) == 0x000038, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::IgnoreActors' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, DamageCauser) == 0x000048, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, InstigatedByController) == 0x000050, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::InstigatedByController' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, bDoFullDamage) == 0x000058, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::bDoFullDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage, DamagePreventionChannel) == 0x000059, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamage::DamagePreventionChannel' has a wrong offset!");

// Function UE4Dreamworld.ApplyRadialDamageWithFalloffProxy.BeginApplyRadialDamageWithFalloff
// 0x0068 (0x0068 - 0x0000)
struct ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDamage;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageFalloff;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedByController;                            // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamagePreventionChannel;                           // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff) == 0x000008, "Wrong alignment on ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff");
static_assert(sizeof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff) == 0x000068, "Wrong size on ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, WorldContextObject) == 0x000000, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, BaseDamage) == 0x000008, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::BaseDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, MinimumDamage) == 0x00000C, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::MinimumDamage' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, Origin) == 0x000010, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::Origin' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, DamageInnerRadius) == 0x000028, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, DamageOuterRadius) == 0x00002C, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, DamageFalloff) == 0x000030, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::DamageFalloff' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, DamageTypeClass) == 0x000038, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, IgnoreActors) == 0x000040, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::IgnoreActors' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, DamageCauser) == 0x000050, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::DamageCauser' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, InstigatedByController) == 0x000058, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::InstigatedByController' has a wrong offset!");
static_assert(offsetof(ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff, DamagePreventionChannel) == 0x000060, "Member 'ApplyRadialDamageWithFalloffProxy_BeginApplyRadialDamageWithFalloff::DamagePreventionChannel' has a wrong offset!");

// Function UE4Dreamworld.AsyncLineTraceByChannelProxy.AsyncLineTraceByChannel
// 0x0060 (0x0060 - 0x0000)
struct AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncLineTraceByChannelProxy*          ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel) == 0x000008, "Wrong alignment on AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel");
static_assert(sizeof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel) == 0x000060, "Wrong size on AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, WorldContextObject) == 0x000000, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, Start) == 0x000008, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::Start' has a wrong offset!");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, End) == 0x000020, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::End' has a wrong offset!");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, TraceChannel) == 0x000038, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::TraceChannel' has a wrong offset!");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, bTraceComplex) == 0x000039, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::bTraceComplex' has a wrong offset!");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, ActorsToIgnore) == 0x000040, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, bIgnoreSelf) == 0x000050, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel, ReturnValue) == 0x000058, "Member 'AsyncLineTraceByChannelProxy_AsyncLineTraceByChannel::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.ChangeMaxRelevancyScaling
// 0x0004 (0x0004 - 0x0000)
struct DreamworldBlueprints_ChangeMaxRelevancyScaling final
{
public:
	float                                         Scaling;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_ChangeMaxRelevancyScaling) == 0x000004, "Wrong alignment on DreamworldBlueprints_ChangeMaxRelevancyScaling");
static_assert(sizeof(DreamworldBlueprints_ChangeMaxRelevancyScaling) == 0x000004, "Wrong size on DreamworldBlueprints_ChangeMaxRelevancyScaling");
static_assert(offsetof(DreamworldBlueprints_ChangeMaxRelevancyScaling, Scaling) == 0x000000, "Member 'DreamworldBlueprints_ChangeMaxRelevancyScaling::Scaling' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.ClearUniqueID
// 0x0008 (0x0008 - 0x0000)
struct DreamworldBlueprints_ClearUniqueID final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_ClearUniqueID) == 0x000008, "Wrong alignment on DreamworldBlueprints_ClearUniqueID");
static_assert(sizeof(DreamworldBlueprints_ClearUniqueID) == 0x000008, "Wrong size on DreamworldBlueprints_ClearUniqueID");
static_assert(offsetof(DreamworldBlueprints_ClearUniqueID, Actor) == 0x000000, "Member 'DreamworldBlueprints_ClearUniqueID::Actor' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.ClientGetPlayerId
// 0x0018 (0x0018 - 0x0000)
struct DreamworldBlueprints_ClientGetPlayerId final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_ClientGetPlayerId) == 0x000008, "Wrong alignment on DreamworldBlueprints_ClientGetPlayerId");
static_assert(sizeof(DreamworldBlueprints_ClientGetPlayerId) == 0x000018, "Wrong size on DreamworldBlueprints_ClientGetPlayerId");
static_assert(offsetof(DreamworldBlueprints_ClientGetPlayerId, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_ClientGetPlayerId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_ClientGetPlayerId, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_ClientGetPlayerId::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.Conv_UniqueIDToString
// 0x0018 (0x0018 - 0x0000)
struct DreamworldBlueprints_Conv_UniqueIDToString final
{
public:
	struct FUniqueID                              UID;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_Conv_UniqueIDToString) == 0x000008, "Wrong alignment on DreamworldBlueprints_Conv_UniqueIDToString");
static_assert(sizeof(DreamworldBlueprints_Conv_UniqueIDToString) == 0x000018, "Wrong size on DreamworldBlueprints_Conv_UniqueIDToString");
static_assert(offsetof(DreamworldBlueprints_Conv_UniqueIDToString, UID) == 0x000000, "Member 'DreamworldBlueprints_Conv_UniqueIDToString::UID' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_Conv_UniqueIDToString, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_Conv_UniqueIDToString::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.Conv_UUIDToText
// 0x0030 (0x0030 - 0x0000)
struct DreamworldBlueprints_Conv_UUIDToText final
{
public:
	struct FUniqueID                              Value;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_Conv_UUIDToText) == 0x000008, "Wrong alignment on DreamworldBlueprints_Conv_UUIDToText");
static_assert(sizeof(DreamworldBlueprints_Conv_UUIDToText) == 0x000030, "Wrong size on DreamworldBlueprints_Conv_UUIDToText");
static_assert(offsetof(DreamworldBlueprints_Conv_UUIDToText, Value) == 0x000000, "Member 'DreamworldBlueprints_Conv_UUIDToText::Value' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_Conv_UUIDToText, bUseGrouping) == 0x000008, "Member 'DreamworldBlueprints_Conv_UUIDToText::bUseGrouping' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_Conv_UUIDToText, MinimumIntegralDigits) == 0x00000C, "Member 'DreamworldBlueprints_Conv_UUIDToText::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_Conv_UUIDToText, MaximumIntegralDigits) == 0x000010, "Member 'DreamworldBlueprints_Conv_UUIDToText::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_Conv_UUIDToText, ReturnValue) == 0x000018, "Member 'DreamworldBlueprints_Conv_UUIDToText::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.EqualEqual_UUIDUUID
// 0x0018 (0x0018 - 0x0000)
struct DreamworldBlueprints_EqualEqual_UUIDUUID final
{
public:
	struct FUniqueID                              A;                                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueID                              B;                                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_EqualEqual_UUIDUUID) == 0x000008, "Wrong alignment on DreamworldBlueprints_EqualEqual_UUIDUUID");
static_assert(sizeof(DreamworldBlueprints_EqualEqual_UUIDUUID) == 0x000018, "Wrong size on DreamworldBlueprints_EqualEqual_UUIDUUID");
static_assert(offsetof(DreamworldBlueprints_EqualEqual_UUIDUUID, A) == 0x000000, "Member 'DreamworldBlueprints_EqualEqual_UUIDUUID::A' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_EqualEqual_UUIDUUID, B) == 0x000008, "Member 'DreamworldBlueprints_EqualEqual_UUIDUUID::B' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_EqualEqual_UUIDUUID, ReturnValue) == 0x000010, "Member 'DreamworldBlueprints_EqualEqual_UUIDUUID::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.GetClassDefaultObject
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_GetClassDefaultObject final
{
public:
	class UClass*                                 Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_GetClassDefaultObject) == 0x000008, "Wrong alignment on DreamworldBlueprints_GetClassDefaultObject");
static_assert(sizeof(DreamworldBlueprints_GetClassDefaultObject) == 0x000010, "Wrong size on DreamworldBlueprints_GetClassDefaultObject");
static_assert(offsetof(DreamworldBlueprints_GetClassDefaultObject, Class_0) == 0x000000, "Member 'DreamworldBlueprints_GetClassDefaultObject::Class_0' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetClassDefaultObject, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_GetClassDefaultObject::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.GetConsoleUserIdOverride
// 0x0030 (0x0030 - 0x0000)
struct DreamworldBlueprints_GetConsoleUserIdOverride final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_GetConsoleUserIdOverride) == 0x000008, "Wrong alignment on DreamworldBlueprints_GetConsoleUserIdOverride");
static_assert(sizeof(DreamworldBlueprints_GetConsoleUserIdOverride) == 0x000030, "Wrong size on DreamworldBlueprints_GetConsoleUserIdOverride");
static_assert(offsetof(DreamworldBlueprints_GetConsoleUserIdOverride, UserId) == 0x000000, "Member 'DreamworldBlueprints_GetConsoleUserIdOverride::UserId' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetConsoleUserIdOverride, Controller) == 0x000010, "Member 'DreamworldBlueprints_GetConsoleUserIdOverride::Controller' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetConsoleUserIdOverride, WorldContextObject) == 0x000018, "Member 'DreamworldBlueprints_GetConsoleUserIdOverride::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetConsoleUserIdOverride, ReturnValue) == 0x000020, "Member 'DreamworldBlueprints_GetConsoleUserIdOverride::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.GetDreamworldVersion
// 0x0058 (0x0058 - 0x0000)
struct DreamworldBlueprints_GetDreamworldVersion final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Branch;                                            // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Project;                                           // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 configuration;                                     // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Revision;                                          // 0x0048(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         base_revision;                                     // 0x004C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Snapshot;                                          // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_GetDreamworldVersion) == 0x000008, "Wrong alignment on DreamworldBlueprints_GetDreamworldVersion");
static_assert(sizeof(DreamworldBlueprints_GetDreamworldVersion) == 0x000058, "Wrong size on DreamworldBlueprints_GetDreamworldVersion");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_GetDreamworldVersion::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, Branch) == 0x000008, "Member 'DreamworldBlueprints_GetDreamworldVersion::Branch' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, Project) == 0x000018, "Member 'DreamworldBlueprints_GetDreamworldVersion::Project' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, configuration) == 0x000028, "Member 'DreamworldBlueprints_GetDreamworldVersion::configuration' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, Platform) == 0x000038, "Member 'DreamworldBlueprints_GetDreamworldVersion::Platform' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, Revision) == 0x000048, "Member 'DreamworldBlueprints_GetDreamworldVersion::Revision' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, base_revision) == 0x00004C, "Member 'DreamworldBlueprints_GetDreamworldVersion::base_revision' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetDreamworldVersion, Snapshot) == 0x000050, "Member 'DreamworldBlueprints_GetDreamworldVersion::Snapshot' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.GetNumStressClients
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_GetNumStressClients final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_GetNumStressClients) == 0x000008, "Wrong alignment on DreamworldBlueprints_GetNumStressClients");
static_assert(sizeof(DreamworldBlueprints_GetNumStressClients) == 0x000010, "Wrong size on DreamworldBlueprints_GetNumStressClients");
static_assert(offsetof(DreamworldBlueprints_GetNumStressClients, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_GetNumStressClients::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetNumStressClients, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_GetNumStressClients::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.GetPlayerId
// 0x0020 (0x0020 - 0x0000)
struct DreamworldBlueprints_GetPlayerId final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           PlayerState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_GetPlayerId) == 0x000008, "Wrong alignment on DreamworldBlueprints_GetPlayerId");
static_assert(sizeof(DreamworldBlueprints_GetPlayerId) == 0x000020, "Wrong size on DreamworldBlueprints_GetPlayerId");
static_assert(offsetof(DreamworldBlueprints_GetPlayerId, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_GetPlayerId::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetPlayerId, PlayerState) == 0x000008, "Member 'DreamworldBlueprints_GetPlayerId::PlayerState' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetPlayerId, ReturnValue) == 0x000010, "Member 'DreamworldBlueprints_GetPlayerId::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.GetServerName
// 0x0018 (0x0018 - 0x0000)
struct DreamworldBlueprints_GetServerName final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_GetServerName) == 0x000008, "Wrong alignment on DreamworldBlueprints_GetServerName");
static_assert(sizeof(DreamworldBlueprints_GetServerName) == 0x000018, "Wrong size on DreamworldBlueprints_GetServerName");
static_assert(offsetof(DreamworldBlueprints_GetServerName, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_GetServerName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_GetServerName, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_GetServerName::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.IsDedicatedSession
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_IsDedicatedSession final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_IsDedicatedSession) == 0x000008, "Wrong alignment on DreamworldBlueprints_IsDedicatedSession");
static_assert(sizeof(DreamworldBlueprints_IsDedicatedSession) == 0x000010, "Wrong size on DreamworldBlueprints_IsDedicatedSession");
static_assert(offsetof(DreamworldBlueprints_IsDedicatedSession, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_IsDedicatedSession::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsDedicatedSession, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_IsDedicatedSession::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.IsDeveloperMode
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_IsDeveloperMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_IsDeveloperMode) == 0x000008, "Wrong alignment on DreamworldBlueprints_IsDeveloperMode");
static_assert(sizeof(DreamworldBlueprints_IsDeveloperMode) == 0x000010, "Wrong size on DreamworldBlueprints_IsDeveloperMode");
static_assert(offsetof(DreamworldBlueprints_IsDeveloperMode, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_IsDeveloperMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsDeveloperMode, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_IsDeveloperMode::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.IsDeveloperUniverse
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_IsDeveloperUniverse final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_IsDeveloperUniverse) == 0x000008, "Wrong alignment on DreamworldBlueprints_IsDeveloperUniverse");
static_assert(sizeof(DreamworldBlueprints_IsDeveloperUniverse) == 0x000010, "Wrong size on DreamworldBlueprints_IsDeveloperUniverse");
static_assert(offsetof(DreamworldBlueprints_IsDeveloperUniverse, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_IsDeveloperUniverse::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsDeveloperUniverse, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_IsDeveloperUniverse::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.IsInTrialMode
// 0x0001 (0x0001 - 0x0000)
struct DreamworldBlueprints_IsInTrialMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_IsInTrialMode) == 0x000001, "Wrong alignment on DreamworldBlueprints_IsInTrialMode");
static_assert(sizeof(DreamworldBlueprints_IsInTrialMode) == 0x000001, "Wrong size on DreamworldBlueprints_IsInTrialMode");
static_assert(offsetof(DreamworldBlueprints_IsInTrialMode, ReturnValue) == 0x000000, "Member 'DreamworldBlueprints_IsInTrialMode::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.IsSessionJoinable
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_IsSessionJoinable final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPublicJoinable;                                   // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendJoinable;                                   // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInviteOnly;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInvites;                                     // 0x000B(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_IsSessionJoinable) == 0x000008, "Wrong alignment on DreamworldBlueprints_IsSessionJoinable");
static_assert(sizeof(DreamworldBlueprints_IsSessionJoinable) == 0x000010, "Wrong size on DreamworldBlueprints_IsSessionJoinable");
static_assert(offsetof(DreamworldBlueprints_IsSessionJoinable, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_IsSessionJoinable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsSessionJoinable, bPublicJoinable) == 0x000008, "Member 'DreamworldBlueprints_IsSessionJoinable::bPublicJoinable' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsSessionJoinable, bFriendJoinable) == 0x000009, "Member 'DreamworldBlueprints_IsSessionJoinable::bFriendJoinable' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsSessionJoinable, bInviteOnly) == 0x00000A, "Member 'DreamworldBlueprints_IsSessionJoinable::bInviteOnly' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsSessionJoinable, bAllowInvites) == 0x00000B, "Member 'DreamworldBlueprints_IsSessionJoinable::bAllowInvites' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsSessionJoinable, ReturnValue) == 0x00000C, "Member 'DreamworldBlueprints_IsSessionJoinable::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.IsStressClient
// 0x0001 (0x0001 - 0x0000)
struct DreamworldBlueprints_IsStressClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_IsStressClient) == 0x000001, "Wrong alignment on DreamworldBlueprints_IsStressClient");
static_assert(sizeof(DreamworldBlueprints_IsStressClient) == 0x000001, "Wrong size on DreamworldBlueprints_IsStressClient");
static_assert(offsetof(DreamworldBlueprints_IsStressClient, ReturnValue) == 0x000000, "Member 'DreamworldBlueprints_IsStressClient::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.IsValidUniqueID
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_IsValidUniqueID final
{
public:
	struct FUniqueID                              UniqueID;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_IsValidUniqueID) == 0x000008, "Wrong alignment on DreamworldBlueprints_IsValidUniqueID");
static_assert(sizeof(DreamworldBlueprints_IsValidUniqueID) == 0x000010, "Wrong size on DreamworldBlueprints_IsValidUniqueID");
static_assert(offsetof(DreamworldBlueprints_IsValidUniqueID, UniqueID) == 0x000000, "Member 'DreamworldBlueprints_IsValidUniqueID::UniqueID' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_IsValidUniqueID, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_IsValidUniqueID::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.NotEqual_UUIDUUID
// 0x0018 (0x0018 - 0x0000)
struct DreamworldBlueprints_NotEqual_UUIDUUID final
{
public:
	struct FUniqueID                              A;                                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueID                              B;                                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_NotEqual_UUIDUUID) == 0x000008, "Wrong alignment on DreamworldBlueprints_NotEqual_UUIDUUID");
static_assert(sizeof(DreamworldBlueprints_NotEqual_UUIDUUID) == 0x000018, "Wrong size on DreamworldBlueprints_NotEqual_UUIDUUID");
static_assert(offsetof(DreamworldBlueprints_NotEqual_UUIDUUID, A) == 0x000000, "Member 'DreamworldBlueprints_NotEqual_UUIDUUID::A' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_NotEqual_UUIDUUID, B) == 0x000008, "Member 'DreamworldBlueprints_NotEqual_UUIDUUID::B' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_NotEqual_UUIDUUID, ReturnValue) == 0x000010, "Member 'DreamworldBlueprints_NotEqual_UUIDUUID::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.PresenceSession
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_PresenceSession final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_PresenceSession) == 0x000008, "Wrong alignment on DreamworldBlueprints_PresenceSession");
static_assert(sizeof(DreamworldBlueprints_PresenceSession) == 0x000010, "Wrong size on DreamworldBlueprints_PresenceSession");
static_assert(offsetof(DreamworldBlueprints_PresenceSession, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_PresenceSession::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_PresenceSession, ReturnValue) == 0x000008, "Member 'DreamworldBlueprints_PresenceSession::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.SetUniqueID
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_SetUniqueID final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueID                              UID;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_SetUniqueID) == 0x000008, "Wrong alignment on DreamworldBlueprints_SetUniqueID");
static_assert(sizeof(DreamworldBlueprints_SetUniqueID) == 0x000010, "Wrong size on DreamworldBlueprints_SetUniqueID");
static_assert(offsetof(DreamworldBlueprints_SetUniqueID, Actor) == 0x000000, "Member 'DreamworldBlueprints_SetUniqueID::Actor' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SetUniqueID, UID) == 0x000008, "Member 'DreamworldBlueprints_SetUniqueID::UID' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.ShowAccountPicker
// 0x0008 (0x0008 - 0x0000)
struct DreamworldBlueprints_ShowAccountPicker final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_ShowAccountPicker) == 0x000008, "Wrong alignment on DreamworldBlueprints_ShowAccountPicker");
static_assert(sizeof(DreamworldBlueprints_ShowAccountPicker) == 0x000008, "Wrong size on DreamworldBlueprints_ShowAccountPicker");
static_assert(offsetof(DreamworldBlueprints_ShowAccountPicker, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_ShowAccountPicker::WorldContextObject' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.SphereTraceSingleCollision
// 0x0170 (0x0170 - 0x0000)
struct DreamworldBlueprints_SphereTraceSingleCollision final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x003D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0058(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0140(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0144(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0154(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0164(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0168(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_SphereTraceSingleCollision) == 0x000008, "Wrong alignment on DreamworldBlueprints_SphereTraceSingleCollision");
static_assert(sizeof(DreamworldBlueprints_SphereTraceSingleCollision) == 0x000170, "Wrong size on DreamworldBlueprints_SphereTraceSingleCollision");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, Start) == 0x000008, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::Start' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, End) == 0x000020, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::End' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, Radius) == 0x000038, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::Radius' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, CollisionChannel) == 0x00003C, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::CollisionChannel' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, bTraceComplex) == 0x00003D, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::bTraceComplex' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, ActorsToIgnore) == 0x000040, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, DrawDebugType) == 0x000050, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::DrawDebugType' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, OutHit) == 0x000058, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::OutHit' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, bIgnoreSelf) == 0x000140, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, TraceColor) == 0x000144, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::TraceColor' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, TraceHitColor) == 0x000154, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::TraceHitColor' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, DrawTime) == 0x000164, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::DrawTime' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_SphereTraceSingleCollision, ReturnValue) == 0x000168, "Member 'DreamworldBlueprints_SphereTraceSingleCollision::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.StreamPlayerStartLevels
// 0x0010 (0x0010 - 0x0000)
struct DreamworldBlueprints_StreamPlayerStartLevels final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlush;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_StreamPlayerStartLevels) == 0x000008, "Wrong alignment on DreamworldBlueprints_StreamPlayerStartLevels");
static_assert(sizeof(DreamworldBlueprints_StreamPlayerStartLevels) == 0x000010, "Wrong size on DreamworldBlueprints_StreamPlayerStartLevels");
static_assert(offsetof(DreamworldBlueprints_StreamPlayerStartLevels, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_StreamPlayerStartLevels::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_StreamPlayerStartLevels, bFlush) == 0x000008, "Member 'DreamworldBlueprints_StreamPlayerStartLevels::bFlush' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.ValidateOnlineSession
// 0x0130 (0x0130 - 0x0000)
struct DreamworldBlueprints_ValidateOnlineSession final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlueprintSessionResult                Session;                                           // 0x0008(0x0120)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0128(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DreamworldBlueprints_ValidateOnlineSession) == 0x000008, "Wrong alignment on DreamworldBlueprints_ValidateOnlineSession");
static_assert(sizeof(DreamworldBlueprints_ValidateOnlineSession) == 0x000130, "Wrong size on DreamworldBlueprints_ValidateOnlineSession");
static_assert(offsetof(DreamworldBlueprints_ValidateOnlineSession, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_ValidateOnlineSession::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_ValidateOnlineSession, Session) == 0x000008, "Member 'DreamworldBlueprints_ValidateOnlineSession::Session' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_ValidateOnlineSession, ReturnValue) == 0x000128, "Member 'DreamworldBlueprints_ValidateOnlineSession::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DreamworldBlueprints.ValidateOnlineSessions
// 0x0038 (0x0038 - 0x0000)
struct DreamworldBlueprints_ValidateOnlineSessions final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBlueprintSessionResult>        Search;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBlueprintSessionResult>        Valid;                                             // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBlueprintSessionResult>        Invalid;                                           // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DreamworldBlueprints_ValidateOnlineSessions) == 0x000008, "Wrong alignment on DreamworldBlueprints_ValidateOnlineSessions");
static_assert(sizeof(DreamworldBlueprints_ValidateOnlineSessions) == 0x000038, "Wrong size on DreamworldBlueprints_ValidateOnlineSessions");
static_assert(offsetof(DreamworldBlueprints_ValidateOnlineSessions, WorldContextObject) == 0x000000, "Member 'DreamworldBlueprints_ValidateOnlineSessions::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_ValidateOnlineSessions, Search) == 0x000008, "Member 'DreamworldBlueprints_ValidateOnlineSessions::Search' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_ValidateOnlineSessions, Valid) == 0x000018, "Member 'DreamworldBlueprints_ValidateOnlineSessions::Valid' has a wrong offset!");
static_assert(offsetof(DreamworldBlueprints_ValidateOnlineSessions, Invalid) == 0x000028, "Member 'DreamworldBlueprints_ValidateOnlineSessions::Invalid' has a wrong offset!");

// Function UE4Dreamworld.DWCheatManager.CrashServer
// 0x0010 (0x0010 - 0x0000)
struct DWCheatManager_CrashServer final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DWCheatManager_CrashServer) == 0x000008, "Wrong alignment on DWCheatManager_CrashServer");
static_assert(sizeof(DWCheatManager_CrashServer) == 0x000010, "Wrong size on DWCheatManager_CrashServer");
static_assert(offsetof(DWCheatManager_CrashServer, Message) == 0x000000, "Member 'DWCheatManager_CrashServer::Message' has a wrong offset!");

// Function UE4Dreamworld.DWCheatManager.SimulateNetworkFailure
// 0x0018 (0x0018 - 0x0000)
struct DWCheatManager_SimulateNetworkFailure final
{
public:
	int32                                         ConnectionIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkFailure                               FailureType;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServer;                                           // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DWCheatManager_SimulateNetworkFailure) == 0x000008, "Wrong alignment on DWCheatManager_SimulateNetworkFailure");
static_assert(sizeof(DWCheatManager_SimulateNetworkFailure) == 0x000018, "Wrong size on DWCheatManager_SimulateNetworkFailure");
static_assert(offsetof(DWCheatManager_SimulateNetworkFailure, ConnectionIndex) == 0x000000, "Member 'DWCheatManager_SimulateNetworkFailure::ConnectionIndex' has a wrong offset!");
static_assert(offsetof(DWCheatManager_SimulateNetworkFailure, FailureType) == 0x000004, "Member 'DWCheatManager_SimulateNetworkFailure::FailureType' has a wrong offset!");
static_assert(offsetof(DWCheatManager_SimulateNetworkFailure, bServer) == 0x000005, "Member 'DWCheatManager_SimulateNetworkFailure::bServer' has a wrong offset!");
static_assert(offsetof(DWCheatManager_SimulateNetworkFailure, Message) == 0x000008, "Member 'DWCheatManager_SimulateNetworkFailure::Message' has a wrong offset!");

// Function UE4Dreamworld.DWCheatManager.SummonPersistent
// 0x0018 (0x0018 - 0x0000)
struct DWCheatManager_SummonPersistent final
{
public:
	class FString                                 ClassName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DWCheatManager_SummonPersistent) == 0x000008, "Wrong alignment on DWCheatManager_SummonPersistent");
static_assert(sizeof(DWCheatManager_SummonPersistent) == 0x000018, "Wrong size on DWCheatManager_SummonPersistent");
static_assert(offsetof(DWCheatManager_SummonPersistent, ClassName) == 0x000000, "Member 'DWCheatManager_SummonPersistent::ClassName' has a wrong offset!");
static_assert(offsetof(DWCheatManager_SummonPersistent, ReturnValue) == 0x000010, "Member 'DWCheatManager_SummonPersistent::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DWDebugLibrary.SaveScreenshot
// 0x0018 (0x0018 - 0x0000)
struct DWDebugLibrary_SaveScreenshot final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DWDebugLibrary_SaveScreenshot) == 0x000008, "Wrong alignment on DWDebugLibrary_SaveScreenshot");
static_assert(sizeof(DWDebugLibrary_SaveScreenshot) == 0x000018, "Wrong size on DWDebugLibrary_SaveScreenshot");
static_assert(offsetof(DWDebugLibrary_SaveScreenshot, WorldContextObject) == 0x000000, "Member 'DWDebugLibrary_SaveScreenshot::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DWDebugLibrary_SaveScreenshot, Filename) == 0x000008, "Member 'DWDebugLibrary_SaveScreenshot::Filename' has a wrong offset!");

// Function UE4Dreamworld.TsomTestDummy.GetFavoriteNumber
// 0x0004 (0x0004 - 0x0000)
struct TsomTestDummy_GetFavoriteNumber final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TsomTestDummy_GetFavoriteNumber) == 0x000004, "Wrong alignment on TsomTestDummy_GetFavoriteNumber");
static_assert(sizeof(TsomTestDummy_GetFavoriteNumber) == 0x000004, "Wrong size on TsomTestDummy_GetFavoriteNumber");
static_assert(offsetof(TsomTestDummy_GetFavoriteNumber, ReturnValue) == 0x000000, "Member 'TsomTestDummy_GetFavoriteNumber::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.DWReplicationGraph.AddDependentActor
// 0x0010 (0x0010 - 0x0000)
struct DWReplicationGraph_AddDependentActor final
{
public:
	class AActor*                                 Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Child;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DWReplicationGraph_AddDependentActor) == 0x000008, "Wrong alignment on DWReplicationGraph_AddDependentActor");
static_assert(sizeof(DWReplicationGraph_AddDependentActor) == 0x000010, "Wrong size on DWReplicationGraph_AddDependentActor");
static_assert(offsetof(DWReplicationGraph_AddDependentActor, Parent) == 0x000000, "Member 'DWReplicationGraph_AddDependentActor::Parent' has a wrong offset!");
static_assert(offsetof(DWReplicationGraph_AddDependentActor, Child) == 0x000008, "Member 'DWReplicationGraph_AddDependentActor::Child' has a wrong offset!");

// Function UE4Dreamworld.DWReplicationGraph.RemoveDependentActor
// 0x0010 (0x0010 - 0x0000)
struct DWReplicationGraph_RemoveDependentActor final
{
public:
	class AActor*                                 Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Child;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DWReplicationGraph_RemoveDependentActor) == 0x000008, "Wrong alignment on DWReplicationGraph_RemoveDependentActor");
static_assert(sizeof(DWReplicationGraph_RemoveDependentActor) == 0x000010, "Wrong size on DWReplicationGraph_RemoveDependentActor");
static_assert(offsetof(DWReplicationGraph_RemoveDependentActor, Parent) == 0x000000, "Member 'DWReplicationGraph_RemoveDependentActor::Parent' has a wrong offset!");
static_assert(offsetof(DWReplicationGraph_RemoveDependentActor, Child) == 0x000008, "Member 'DWReplicationGraph_RemoveDependentActor::Child' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.GatherWorldData
// 0x0008 (0x0008 - 0x0000)
struct SceneValidator_GatherWorldData final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidator_GatherWorldData) == 0x000008, "Wrong alignment on SceneValidator_GatherWorldData");
static_assert(sizeof(SceneValidator_GatherWorldData) == 0x000008, "Wrong size on SceneValidator_GatherWorldData");
static_assert(offsetof(SceneValidator_GatherWorldData, World) == 0x000000, "Member 'SceneValidator_GatherWorldData::World' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.GatherWorldSectionData
// 0x0048 (0x0048 - 0x0000)
struct SceneValidator_GatherWorldSectionData final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FValidationWorldSection                WorldSection;                                      // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidator_GatherWorldSectionData) == 0x000008, "Wrong alignment on SceneValidator_GatherWorldSectionData");
static_assert(sizeof(SceneValidator_GatherWorldSectionData) == 0x000048, "Wrong size on SceneValidator_GatherWorldSectionData");
static_assert(offsetof(SceneValidator_GatherWorldSectionData, World) == 0x000000, "Member 'SceneValidator_GatherWorldSectionData::World' has a wrong offset!");
static_assert(offsetof(SceneValidator_GatherWorldSectionData, WorldSection) == 0x000008, "Member 'SceneValidator_GatherWorldSectionData::WorldSection' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.GatherWorldSectionStats
// 0x0048 (0x0048 - 0x0000)
struct SceneValidator_GatherWorldSectionStats final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FValidationWorldSection                WorldSection;                                      // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidator_GatherWorldSectionStats) == 0x000008, "Wrong alignment on SceneValidator_GatherWorldSectionStats");
static_assert(sizeof(SceneValidator_GatherWorldSectionStats) == 0x000048, "Wrong size on SceneValidator_GatherWorldSectionStats");
static_assert(offsetof(SceneValidator_GatherWorldSectionStats, World) == 0x000000, "Member 'SceneValidator_GatherWorldSectionStats::World' has a wrong offset!");
static_assert(offsetof(SceneValidator_GatherWorldSectionStats, WorldSection) == 0x000008, "Member 'SceneValidator_GatherWorldSectionStats::WorldSection' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.GatherWorldStats
// 0x0008 (0x0008 - 0x0000)
struct SceneValidator_GatherWorldStats final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidator_GatherWorldStats) == 0x000008, "Wrong alignment on SceneValidator_GatherWorldStats");
static_assert(sizeof(SceneValidator_GatherWorldStats) == 0x000008, "Wrong size on SceneValidator_GatherWorldStats");
static_assert(offsetof(SceneValidator_GatherWorldStats, World) == 0x000000, "Member 'SceneValidator_GatherWorldStats::World' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.ValidateWorld
// 0x0002 (0x0002 - 0x0000)
struct SceneValidator_ValidateWorld final
{
public:
	bool                                          bSectionsPassedValidation;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidator_ValidateWorld) == 0x000001, "Wrong alignment on SceneValidator_ValidateWorld");
static_assert(sizeof(SceneValidator_ValidateWorld) == 0x000002, "Wrong size on SceneValidator_ValidateWorld");
static_assert(offsetof(SceneValidator_ValidateWorld, bSectionsPassedValidation) == 0x000000, "Member 'SceneValidator_ValidateWorld::bSectionsPassedValidation' has a wrong offset!");
static_assert(offsetof(SceneValidator_ValidateWorld, ReturnValue) == 0x000001, "Member 'SceneValidator_ValidateWorld::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.ValidateWorldSection
// 0x0048 (0x0048 - 0x0000)
struct SceneValidator_ValidateWorldSection final
{
public:
	struct FValidationWorldSection                WorldSection;                                      // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidator_ValidateWorldSection) == 0x000008, "Wrong alignment on SceneValidator_ValidateWorldSection");
static_assert(sizeof(SceneValidator_ValidateWorldSection) == 0x000048, "Wrong size on SceneValidator_ValidateWorldSection");
static_assert(offsetof(SceneValidator_ValidateWorldSection, WorldSection) == 0x000000, "Member 'SceneValidator_ValidateWorldSection::WorldSection' has a wrong offset!");
static_assert(offsetof(SceneValidator_ValidateWorldSection, ReturnValue) == 0x000040, "Member 'SceneValidator_ValidateWorldSection::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.WriteKeyToStats
// 0x0018 (0x0018 - 0x0000)
struct SceneValidator_WriteKeyToStats final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Data;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidator_WriteKeyToStats) == 0x000008, "Wrong alignment on SceneValidator_WriteKeyToStats");
static_assert(sizeof(SceneValidator_WriteKeyToStats) == 0x000018, "Wrong size on SceneValidator_WriteKeyToStats");
static_assert(offsetof(SceneValidator_WriteKeyToStats, Key) == 0x000000, "Member 'SceneValidator_WriteKeyToStats::Key' has a wrong offset!");
static_assert(offsetof(SceneValidator_WriteKeyToStats, Data) == 0x000010, "Member 'SceneValidator_WriteKeyToStats::Data' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.WriteToStats
// 0x0008 (0x0008 - 0x0000)
struct SceneValidator_WriteToStats final
{
public:
	class UStruct*                                Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidator_WriteToStats) == 0x000008, "Wrong alignment on SceneValidator_WriteToStats");
static_assert(sizeof(SceneValidator_WriteToStats) == 0x000008, "Wrong size on SceneValidator_WriteToStats");
static_assert(offsetof(SceneValidator_WriteToStats, Data) == 0x000000, "Member 'SceneValidator_WriteToStats::Data' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.GetValidationWorld
// 0x0008 (0x0008 - 0x0000)
struct SceneValidator_GetValidationWorld final
{
public:
	class UWorld*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidator_GetValidationWorld) == 0x000008, "Wrong alignment on SceneValidator_GetValidationWorld");
static_assert(sizeof(SceneValidator_GetValidationWorld) == 0x000008, "Wrong size on SceneValidator_GetValidationWorld");
static_assert(offsetof(SceneValidator_GetValidationWorld, ReturnValue) == 0x000000, "Member 'SceneValidator_GetValidationWorld::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.GetWorldSections
// 0x0018 (0x0018 - 0x0000)
struct SceneValidator_GetWorldSections final
{
public:
	TArray<struct FValidationWorldSection>        OutSections;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeEditor;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidator_GetWorldSections) == 0x000008, "Wrong alignment on SceneValidator_GetWorldSections");
static_assert(sizeof(SceneValidator_GetWorldSections) == 0x000018, "Wrong size on SceneValidator_GetWorldSections");
static_assert(offsetof(SceneValidator_GetWorldSections, OutSections) == 0x000000, "Member 'SceneValidator_GetWorldSections::OutSections' has a wrong offset!");
static_assert(offsetof(SceneValidator_GetWorldSections, bIncludeEditor) == 0x000010, "Member 'SceneValidator_GetWorldSections::bIncludeEditor' has a wrong offset!");

// Function UE4Dreamworld.SceneValidator.GetWorldSectionsForBox
// 0x0050 (0x0050 - 0x0000)
struct SceneValidator_GetWorldSectionsForBox final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x0038)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FValidationWorldSection>        OutSections;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeEditor;                                    // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutClamped;                                       // 0x0049(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidator_GetWorldSectionsForBox) == 0x000008, "Wrong alignment on SceneValidator_GetWorldSectionsForBox");
static_assert(sizeof(SceneValidator_GetWorldSectionsForBox) == 0x000050, "Wrong size on SceneValidator_GetWorldSectionsForBox");
static_assert(offsetof(SceneValidator_GetWorldSectionsForBox, Box) == 0x000000, "Member 'SceneValidator_GetWorldSectionsForBox::Box' has a wrong offset!");
static_assert(offsetof(SceneValidator_GetWorldSectionsForBox, OutSections) == 0x000038, "Member 'SceneValidator_GetWorldSectionsForBox::OutSections' has a wrong offset!");
static_assert(offsetof(SceneValidator_GetWorldSectionsForBox, bIncludeEditor) == 0x000048, "Member 'SceneValidator_GetWorldSectionsForBox::bIncludeEditor' has a wrong offset!");
static_assert(offsetof(SceneValidator_GetWorldSectionsForBox, bOutClamped) == 0x000049, "Member 'SceneValidator_GetWorldSectionsForBox::bOutClamped' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.AddValidationError
// 0x0050 (0x0050 - 0x0000)
struct SceneValidatorFunctionLibrary_AddValidationError final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          ContextObj;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   SectionBounds;                                     // 0x0018(0x0038)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidatorFunctionLibrary_AddValidationError) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_AddValidationError");
static_assert(sizeof(SceneValidatorFunctionLibrary_AddValidationError) == 0x000050, "Wrong size on SceneValidatorFunctionLibrary_AddValidationError");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationError, Message) == 0x000000, "Member 'SceneValidatorFunctionLibrary_AddValidationError::Message' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationError, ContextObj) == 0x000010, "Member 'SceneValidatorFunctionLibrary_AddValidationError::ContextObj' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationError, SectionBounds) == 0x000018, "Member 'SceneValidatorFunctionLibrary_AddValidationError::SectionBounds' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.AddValidationInfo
// 0x0050 (0x0050 - 0x0000)
struct SceneValidatorFunctionLibrary_AddValidationInfo final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          ContextObj;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   SectionBounds;                                     // 0x0018(0x0038)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidatorFunctionLibrary_AddValidationInfo) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_AddValidationInfo");
static_assert(sizeof(SceneValidatorFunctionLibrary_AddValidationInfo) == 0x000050, "Wrong size on SceneValidatorFunctionLibrary_AddValidationInfo");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationInfo, Message) == 0x000000, "Member 'SceneValidatorFunctionLibrary_AddValidationInfo::Message' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationInfo, ContextObj) == 0x000010, "Member 'SceneValidatorFunctionLibrary_AddValidationInfo::ContextObj' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationInfo, SectionBounds) == 0x000018, "Member 'SceneValidatorFunctionLibrary_AddValidationInfo::SectionBounds' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.AddValidationWarning
// 0x0050 (0x0050 - 0x0000)
struct SceneValidatorFunctionLibrary_AddValidationWarning final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          ContextObj;                                        // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   SectionBounds;                                     // 0x0018(0x0038)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidatorFunctionLibrary_AddValidationWarning) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_AddValidationWarning");
static_assert(sizeof(SceneValidatorFunctionLibrary_AddValidationWarning) == 0x000050, "Wrong size on SceneValidatorFunctionLibrary_AddValidationWarning");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationWarning, Message) == 0x000000, "Member 'SceneValidatorFunctionLibrary_AddValidationWarning::Message' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationWarning, ContextObj) == 0x000010, "Member 'SceneValidatorFunctionLibrary_AddValidationWarning::ContextObj' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_AddValidationWarning, SectionBounds) == 0x000018, "Member 'SceneValidatorFunctionLibrary_AddValidationWarning::SectionBounds' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.ConditionalBreakpoint
// 0x0001 (0x0001 - 0x0000)
struct SceneValidatorFunctionLibrary_ConditionalBreakpoint final
{
public:
	bool                                          bBreak;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidatorFunctionLibrary_ConditionalBreakpoint) == 0x000001, "Wrong alignment on SceneValidatorFunctionLibrary_ConditionalBreakpoint");
static_assert(sizeof(SceneValidatorFunctionLibrary_ConditionalBreakpoint) == 0x000001, "Wrong size on SceneValidatorFunctionLibrary_ConditionalBreakpoint");
static_assert(offsetof(SceneValidatorFunctionLibrary_ConditionalBreakpoint, bBreak) == 0x000000, "Member 'SceneValidatorFunctionLibrary_ConditionalBreakpoint::bBreak' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetAllObjectsOfClass
// 0x0028 (0x0028 - 0x0000)
struct SceneValidatorFunctionLibrary_GetAllObjectsOfClass final
{
public:
	TArray<class UObject*>                        OutObjects;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UClass*                                 Class_0;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeEditorOnly;                                // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidatorFunctionLibrary_GetAllObjectsOfClass) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_GetAllObjectsOfClass");
static_assert(sizeof(SceneValidatorFunctionLibrary_GetAllObjectsOfClass) == 0x000028, "Wrong size on SceneValidatorFunctionLibrary_GetAllObjectsOfClass");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetAllObjectsOfClass, OutObjects) == 0x000000, "Member 'SceneValidatorFunctionLibrary_GetAllObjectsOfClass::OutObjects' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetAllObjectsOfClass, Class_0) == 0x000010, "Member 'SceneValidatorFunctionLibrary_GetAllObjectsOfClass::Class_0' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetAllObjectsOfClass, World) == 0x000018, "Member 'SceneValidatorFunctionLibrary_GetAllObjectsOfClass::World' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetAllObjectsOfClass, bIncludeEditorOnly) == 0x000020, "Member 'SceneValidatorFunctionLibrary_GetAllObjectsOfClass::bIncludeEditorOnly' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetCollisionTransforms
// 0x0050 (0x0050 - 0x0000)
struct SceneValidatorFunctionLibrary_GetCollisionTransforms final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0008(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     OutCollisionTransforms;                            // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidatorFunctionLibrary_GetCollisionTransforms) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_GetCollisionTransforms");
static_assert(sizeof(SceneValidatorFunctionLibrary_GetCollisionTransforms) == 0x000050, "Wrong size on SceneValidatorFunctionLibrary_GetCollisionTransforms");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetCollisionTransforms, PrimitiveComponent) == 0x000000, "Member 'SceneValidatorFunctionLibrary_GetCollisionTransforms::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetCollisionTransforms, Bounds) == 0x000008, "Member 'SceneValidatorFunctionLibrary_GetCollisionTransforms::Bounds' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetCollisionTransforms, OutCollisionTransforms) == 0x000040, "Member 'SceneValidatorFunctionLibrary_GetCollisionTransforms::OutCollisionTransforms' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetNumCollisionTris
// 0x0048 (0x0048 - 0x0000)
struct SceneValidatorFunctionLibrary_GetNumCollisionTris final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0008(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidatorFunctionLibrary_GetNumCollisionTris) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_GetNumCollisionTris");
static_assert(sizeof(SceneValidatorFunctionLibrary_GetNumCollisionTris) == 0x000048, "Wrong size on SceneValidatorFunctionLibrary_GetNumCollisionTris");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetNumCollisionTris, PrimitiveComponent) == 0x000000, "Member 'SceneValidatorFunctionLibrary_GetNumCollisionTris::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetNumCollisionTris, Bounds) == 0x000008, "Member 'SceneValidatorFunctionLibrary_GetNumCollisionTris::Bounds' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetNumCollisionTris, ReturnValue) == 0x000040, "Member 'SceneValidatorFunctionLibrary_GetNumCollisionTris::ReturnValue' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.GetTriangleCount
// 0x0058 (0x0058 - 0x0000)
struct SceneValidatorFunctionLibrary_GetTriangleCount final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0008(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         NaniteTriangles;                                   // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Triangles;                                         // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         BodyCount;                                         // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidatorFunctionLibrary_GetTriangleCount) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_GetTriangleCount");
static_assert(sizeof(SceneValidatorFunctionLibrary_GetTriangleCount) == 0x000058, "Wrong size on SceneValidatorFunctionLibrary_GetTriangleCount");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetTriangleCount, PrimitiveComponent) == 0x000000, "Member 'SceneValidatorFunctionLibrary_GetTriangleCount::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetTriangleCount, Bounds) == 0x000008, "Member 'SceneValidatorFunctionLibrary_GetTriangleCount::Bounds' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetTriangleCount, NaniteTriangles) == 0x000040, "Member 'SceneValidatorFunctionLibrary_GetTriangleCount::NaniteTriangles' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetTriangleCount, Triangles) == 0x000048, "Member 'SceneValidatorFunctionLibrary_GetTriangleCount::Triangles' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_GetTriangleCount, BodyCount) == 0x000050, "Member 'SceneValidatorFunctionLibrary_GetTriangleCount::BodyCount' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.OverlapMultiByChannelForBox
// 0x0058 (0x0058 - 0x0000)
struct SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox final
{
public:
	TArray<struct FBoxOverlapResult>              OutOverlaps;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	const class UWorld*                           World;                                             // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0018(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ECollisionChannel                             Channel;                                           // 0x0050(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoxOverlapMobilityType                       MobilityType;                                      // 0x0051(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox");
static_assert(sizeof(SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox) == 0x000058, "Wrong size on SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox");
static_assert(offsetof(SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox, OutOverlaps) == 0x000000, "Member 'SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox::OutOverlaps' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox, World) == 0x000010, "Member 'SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox::World' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox, Box) == 0x000018, "Member 'SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox::Box' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox, Channel) == 0x000050, "Member 'SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox::Channel' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox, MobilityType) == 0x000051, "Member 'SceneValidatorFunctionLibrary_OverlapMultiByChannelForBox::MobilityType' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.SortArrayWithComparisonValues
// 0x0030 (0x0030 - 0x0000)
struct SceneValidatorFunctionLibrary_SortArrayWithComparisonValues final
{
public:
	TArray<int32>                                 inArray;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 ComparisonValues;                                  // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 OutArray;                                          // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneValidatorFunctionLibrary_SortArrayWithComparisonValues) == 0x000008, "Wrong alignment on SceneValidatorFunctionLibrary_SortArrayWithComparisonValues");
static_assert(sizeof(SceneValidatorFunctionLibrary_SortArrayWithComparisonValues) == 0x000030, "Wrong size on SceneValidatorFunctionLibrary_SortArrayWithComparisonValues");
static_assert(offsetof(SceneValidatorFunctionLibrary_SortArrayWithComparisonValues, inArray) == 0x000000, "Member 'SceneValidatorFunctionLibrary_SortArrayWithComparisonValues::inArray' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SortArrayWithComparisonValues, ComparisonValues) == 0x000010, "Member 'SceneValidatorFunctionLibrary_SortArrayWithComparisonValues::ComparisonValues' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SortArrayWithComparisonValues, OutArray) == 0x000020, "Member 'SceneValidatorFunctionLibrary_SortArrayWithComparisonValues::OutArray' has a wrong offset!");

// Function UE4Dreamworld.SceneValidatorFunctionLibrary.SweepSingleByChannelForBox
// 0x0170 (0x0170 - 0x0000)
struct SceneValidatorFunctionLibrary_SweepSingleByChannelForBox final
{
public:
	struct FHitResult                             OutHit;                                            // 0x0000(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	const class UWorld*                           World;                                             // 0x00E8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x00F0(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0108(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0120(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rot;                                               // 0x0140(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox) == 0x000010, "Wrong alignment on SceneValidatorFunctionLibrary_SweepSingleByChannelForBox");
static_assert(sizeof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox) == 0x000170, "Wrong size on SceneValidatorFunctionLibrary_SweepSingleByChannelForBox");
static_assert(offsetof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox, OutHit) == 0x000000, "Member 'SceneValidatorFunctionLibrary_SweepSingleByChannelForBox::OutHit' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox, World) == 0x0000E8, "Member 'SceneValidatorFunctionLibrary_SweepSingleByChannelForBox::World' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox, BoxExtent) == 0x0000F0, "Member 'SceneValidatorFunctionLibrary_SweepSingleByChannelForBox::BoxExtent' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox, Start) == 0x000108, "Member 'SceneValidatorFunctionLibrary_SweepSingleByChannelForBox::Start' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox, End) == 0x000120, "Member 'SceneValidatorFunctionLibrary_SweepSingleByChannelForBox::End' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox, Rot) == 0x000140, "Member 'SceneValidatorFunctionLibrary_SweepSingleByChannelForBox::Rot' has a wrong offset!");
static_assert(offsetof(SceneValidatorFunctionLibrary_SweepSingleByChannelForBox, TraceChannel) == 0x000160, "Member 'SceneValidatorFunctionLibrary_SweepSingleByChannelForBox::TraceChannel' has a wrong offset!");

}


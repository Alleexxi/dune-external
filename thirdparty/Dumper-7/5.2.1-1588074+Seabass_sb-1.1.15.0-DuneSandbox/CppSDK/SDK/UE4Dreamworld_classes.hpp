#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UE4Dreamworld

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UE4Dreamworld_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "PersistenceCore_structs.hpp"
#include "NetCore_structs.hpp"
#include "ReplicationGraph_classes.hpp"


namespace SDK
{

// Class UE4Dreamworld.ConditionalReplicationActor
// 0x0150 (0x04A0 - 0x0350)
class AConditionalReplicationActor final : public AActor
{
public:
	uint8                                         Pad_350[0x150];                                    // 0x0350(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalReplicationActor">();
	}
	static class AConditionalReplicationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConditionalReplicationActor>();
	}
};
static_assert(alignof(AConditionalReplicationActor) == 0x000008, "Wrong alignment on AConditionalReplicationActor");
static_assert(sizeof(AConditionalReplicationActor) == 0x0004A0, "Wrong size on AConditionalReplicationActor");

// Class UE4Dreamworld.ConditionalReplicationComponent
// 0x0150 (0x0278 - 0x0128)
class UConditionalReplicationComponent : public UActorComponent
{
public:
	uint8                                         Pad_128[0x150];                                    // 0x0128(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalReplicationComponent">();
	}
	static class UConditionalReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalReplicationComponent>();
	}
};
static_assert(alignof(UConditionalReplicationComponent) == 0x000008, "Wrong alignment on UConditionalReplicationComponent");
static_assert(sizeof(UConditionalReplicationComponent) == 0x000278, "Wrong size on UConditionalReplicationComponent");

// Class UE4Dreamworld.ConditionalReplicationObject
// 0x0150 (0x0180 - 0x0030)
class UConditionalReplicationObject final : public UObject
{
public:
	uint8                                         Pad_30[0x150];                                     // 0x0030(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionalReplicationObject">();
	}
	static class UConditionalReplicationObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionalReplicationObject>();
	}
};
static_assert(alignof(UConditionalReplicationObject) == 0x000008, "Wrong alignment on UConditionalReplicationObject");
static_assert(sizeof(UConditionalReplicationObject) == 0x000180, "Wrong size on UConditionalReplicationObject");

// Class UE4Dreamworld.DreamworldSettings
// 0x0000 (0x0030 - 0x0030)
class UDreamworldSettings final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamworldSettings">();
	}
	static class UDreamworldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamworldSettings>();
	}
};
static_assert(alignof(UDreamworldSettings) == 0x000008, "Wrong alignment on UDreamworldSettings");
static_assert(sizeof(UDreamworldSettings) == 0x000030, "Wrong size on UDreamworldSettings");

// Class UE4Dreamworld.PersistenceUtilsBpLibrary
// 0x0000 (0x0030 - 0x0030)
class UPersistenceUtilsBpLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FUniqueID GetActorUID(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistenceUtilsBpLibrary">();
	}
	static class UPersistenceUtilsBpLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistenceUtilsBpLibrary>();
	}
};
static_assert(alignof(UPersistenceUtilsBpLibrary) == 0x000008, "Wrong alignment on UPersistenceUtilsBpLibrary");
static_assert(sizeof(UPersistenceUtilsBpLibrary) == 0x000030, "Wrong size on UPersistenceUtilsBpLibrary");

// Class UE4Dreamworld.PersistenceComponent
// 0x0040 (0x0168 - 0x0128)
class UPersistenceComponent : public UActorComponent
{
public:
	bool                                          SkipSaving;                                        // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x1F];                                     // 0x0129(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          m_bRegisterForLookup;                              // 0x0148(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          m_bWasLoadedFromDB;                                // 0x0149(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A[0x16];                                     // 0x014A(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueID                              UID;                                               // 0x0160(0x0008)(Edit, Net, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistenceComponent">();
	}
	static class UPersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistenceComponent>();
	}
};
static_assert(alignof(UPersistenceComponent) == 0x000008, "Wrong alignment on UPersistenceComponent");
static_assert(sizeof(UPersistenceComponent) == 0x000168, "Wrong size on UPersistenceComponent");
static_assert(offsetof(UPersistenceComponent, SkipSaving) == 0x000128, "Member 'UPersistenceComponent::SkipSaving' has a wrong offset!");
static_assert(offsetof(UPersistenceComponent, m_bRegisterForLookup) == 0x000148, "Member 'UPersistenceComponent::m_bRegisterForLookup' has a wrong offset!");
static_assert(offsetof(UPersistenceComponent, m_bWasLoadedFromDB) == 0x000149, "Member 'UPersistenceComponent::m_bWasLoadedFromDB' has a wrong offset!");
static_assert(offsetof(UPersistenceComponent, UID) == 0x000160, "Member 'UPersistenceComponent::UID' has a wrong offset!");

// Class UE4Dreamworld.RootPersistenceComponent
// 0x0020 (0x0188 - 0x0168)
class URootPersistenceComponent : public UPersistenceComponent
{
public:
	uint8                                         Pad_168[0x20];                                     // 0x0168(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RootPersistenceComponent">();
	}
	static class URootPersistenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URootPersistenceComponent>();
	}
};
static_assert(alignof(URootPersistenceComponent) == 0x000008, "Wrong alignment on URootPersistenceComponent");
static_assert(sizeof(URootPersistenceComponent) == 0x000188, "Wrong size on URootPersistenceComponent");

// Class UE4Dreamworld.SceneValidatorConfig
// 0x0090 (0x00C0 - 0x0030)
class USceneValidatorConfig final : public UObject
{
public:
	TSubclassOf<class USceneValidatorManager>     SceneValidatorClass;                               // 0x0030(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CellSize;                                          // 0x0038(0x0018)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SceneValidatorWidget;                              // 0x0050(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FAutomaticMapValidationList> AutomaticMapValidationLists;             // 0x0070(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneValidatorConfig">();
	}
	static class USceneValidatorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneValidatorConfig>();
	}
};
static_assert(alignof(USceneValidatorConfig) == 0x000008, "Wrong alignment on USceneValidatorConfig");
static_assert(sizeof(USceneValidatorConfig) == 0x0000C0, "Wrong size on USceneValidatorConfig");
static_assert(offsetof(USceneValidatorConfig, SceneValidatorClass) == 0x000030, "Member 'USceneValidatorConfig::SceneValidatorClass' has a wrong offset!");
static_assert(offsetof(USceneValidatorConfig, CellSize) == 0x000038, "Member 'USceneValidatorConfig::CellSize' has a wrong offset!");
static_assert(offsetof(USceneValidatorConfig, SceneValidatorWidget) == 0x000050, "Member 'USceneValidatorConfig::SceneValidatorWidget' has a wrong offset!");
static_assert(offsetof(USceneValidatorConfig, AutomaticMapValidationLists) == 0x000070, "Member 'USceneValidatorConfig::AutomaticMapValidationLists' has a wrong offset!");

// Class UE4Dreamworld.SceneValidatorVisualizerProxy
// 0x0000 (0x0000 - 0x0000)
class ISceneValidatorVisualizerProxy final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneValidatorVisualizerProxy">();
	}
	static class ISceneValidatorVisualizerProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISceneValidatorVisualizerProxy>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISceneValidatorVisualizerProxy) == 0x000001, "Wrong alignment on ISceneValidatorVisualizerProxy");
static_assert(sizeof(ISceneValidatorVisualizerProxy) == 0x000001, "Wrong size on ISceneValidatorVisualizerProxy");

// Class UE4Dreamworld.StatsCollectorConfig
// 0x0030 (0x0060 - 0x0030)
class UStatsCollectorConfig final : public UObject
{
public:
	TArray<class FString>                         StatsToCollect;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         LLMStatsToCollect;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         LLMAggregateStatsToCollect;                        // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsCollectorConfig">();
	}
	static class UStatsCollectorConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsCollectorConfig>();
	}
};
static_assert(alignof(UStatsCollectorConfig) == 0x000008, "Wrong alignment on UStatsCollectorConfig");
static_assert(sizeof(UStatsCollectorConfig) == 0x000060, "Wrong size on UStatsCollectorConfig");
static_assert(offsetof(UStatsCollectorConfig, StatsToCollect) == 0x000030, "Member 'UStatsCollectorConfig::StatsToCollect' has a wrong offset!");
static_assert(offsetof(UStatsCollectorConfig, LLMStatsToCollect) == 0x000040, "Member 'UStatsCollectorConfig::LLMStatsToCollect' has a wrong offset!");
static_assert(offsetof(UStatsCollectorConfig, LLMAggregateStatsToCollect) == 0x000050, "Member 'UStatsCollectorConfig::LLMAggregateStatsToCollect' has a wrong offset!");

// Class UE4Dreamworld.MetricsReporter
// 0x0028 (0x0058 - 0x0030)
class UMetricsReporter : public UObject
{
public:
	class FString                                 m_ScopeName;                                       // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset(const class UWorld* World);
	void SetResetInterval(float Value);
	void Tick(const class UWorld* World);

	float GetResetInterval() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetricsReporter">();
	}
	static class UMetricsReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetricsReporter>();
	}
};
static_assert(alignof(UMetricsReporter) == 0x000008, "Wrong alignment on UMetricsReporter");
static_assert(sizeof(UMetricsReporter) == 0x000058, "Wrong size on UMetricsReporter");
static_assert(offsetof(UMetricsReporter, m_ScopeName) == 0x000030, "Member 'UMetricsReporter::m_ScopeName' has a wrong offset!");

// Class UE4Dreamworld.StatUnitReporter
// 0x0048 (0x00A0 - 0x0058)
class UStatUnitReporter final : public UMetricsReporter
{
public:
	uint8                                         Pad_58[0x48];                                      // 0x0058(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatUnitReporter">();
	}
	static class UStatUnitReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatUnitReporter>();
	}
};
static_assert(alignof(UStatUnitReporter) == 0x000008, "Wrong alignment on UStatUnitReporter");
static_assert(sizeof(UStatUnitReporter) == 0x0000A0, "Wrong size on UStatUnitReporter");

// Class UE4Dreamworld.StringEnumDataprovider
// 0x0008 (0x0038 - 0x0030)
class UStringEnumDataprovider : public UObject
{
public:
	class FName                                   m_TargetEnum;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StringEnumDataprovider">();
	}
	static class UStringEnumDataprovider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStringEnumDataprovider>();
	}
};
static_assert(alignof(UStringEnumDataprovider) == 0x000008, "Wrong alignment on UStringEnumDataprovider");
static_assert(sizeof(UStringEnumDataprovider) == 0x000038, "Wrong size on UStringEnumDataprovider");
static_assert(offsetof(UStringEnumDataprovider, m_TargetEnum) == 0x000030, "Member 'UStringEnumDataprovider::m_TargetEnum' has a wrong offset!");

// Class UE4Dreamworld.TickReporter
// 0x0018 (0x0070 - 0x0058)
class UTickReporter final : public UMetricsReporter
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickReporter">();
	}
	static class UTickReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickReporter>();
	}
};
static_assert(alignof(UTickReporter) == 0x000008, "Wrong alignment on UTickReporter");
static_assert(sizeof(UTickReporter) == 0x000070, "Wrong size on UTickReporter");

// Class UE4Dreamworld.CacheModule
// 0x0050 (0x03A0 - 0x0350)
class ACacheModule final : public AActor
{
public:
	TMap<class UObject*, float>                   CachedItems;                                       // 0x0350(0x0050)(NativeAccessSpecifierPrivate)

public:
	void CacheItem(class UObject* Asset, float KeepAliveTime);
	void Flush();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CacheModule">();
	}
	static class ACacheModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACacheModule>();
	}
};
static_assert(alignof(ACacheModule) == 0x000008, "Wrong alignment on ACacheModule");
static_assert(sizeof(ACacheModule) == 0x0003A0, "Wrong size on ACacheModule");
static_assert(offsetof(ACacheModule, CachedItems) == 0x000350, "Member 'ACacheModule::CachedItems' has a wrong offset!");

// Class UE4Dreamworld.QuadtreeComponent
// 0x0010 (0x0370 - 0x0360)
class UQuadtreeComponent final : public USceneComponent
{
public:
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TreeName;                                          // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnQuadTreeUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadtreeComponent">();
	}
	static class UQuadtreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuadtreeComponent>();
	}
};
static_assert(alignof(UQuadtreeComponent) == 0x000010, "Wrong alignment on UQuadtreeComponent");
static_assert(sizeof(UQuadtreeComponent) == 0x000370, "Wrong size on UQuadtreeComponent");
static_assert(offsetof(UQuadtreeComponent, TreeName) == 0x000368, "Member 'UQuadtreeComponent::TreeName' has a wrong offset!");

// Class UE4Dreamworld.QuadTreeFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UQuadTreeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetOverlappingActors(const class UObject* WorldContextObject, const class FName TreeName, const struct FVector& SpherePos, float SphereRadius, TSubclassOf<class AActor> ActorClass, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OverlappingActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadTreeFunctionLibrary">();
	}
	static class UQuadTreeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuadTreeFunctionLibrary>();
	}
};
static_assert(alignof(UQuadTreeFunctionLibrary) == 0x000008, "Wrong alignment on UQuadTreeFunctionLibrary");
static_assert(sizeof(UQuadTreeFunctionLibrary) == 0x000030, "Wrong size on UQuadTreeFunctionLibrary");

// Class UE4Dreamworld.BudgetingConfig
// 0x0038 (0x0068 - 0x0030)
class UBudgetingConfig final : public UObject
{
public:
	uint16                                        m_MaxUnlabeledCategoriesPerReport;                 // 0x0030(0x0002)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBudgetingBinding>              m_CategoryMappings;                                // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FBudgetingExcludeCategory>      m_ExcludePatterns;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         m_WorkerCategories;                                // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BudgetingConfig">();
	}
	static class UBudgetingConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBudgetingConfig>();
	}
};
static_assert(alignof(UBudgetingConfig) == 0x000008, "Wrong alignment on UBudgetingConfig");
static_assert(sizeof(UBudgetingConfig) == 0x000068, "Wrong size on UBudgetingConfig");
static_assert(offsetof(UBudgetingConfig, m_MaxUnlabeledCategoriesPerReport) == 0x000030, "Member 'UBudgetingConfig::m_MaxUnlabeledCategoriesPerReport' has a wrong offset!");
static_assert(offsetof(UBudgetingConfig, m_CategoryMappings) == 0x000038, "Member 'UBudgetingConfig::m_CategoryMappings' has a wrong offset!");
static_assert(offsetof(UBudgetingConfig, m_ExcludePatterns) == 0x000048, "Member 'UBudgetingConfig::m_ExcludePatterns' has a wrong offset!");
static_assert(offsetof(UBudgetingConfig, m_WorkerCategories) == 0x000058, "Member 'UBudgetingConfig::m_WorkerCategories' has a wrong offset!");

// Class UE4Dreamworld.BudgetKeeper
// 0x0000 (0x0030 - 0x0030)
class UBudgetKeeper final : public UBlueprintFunctionLibrary
{
public:
	static void CheckPerformanceBudgets(int32 FrameCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BudgetKeeper">();
	}
	static class UBudgetKeeper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBudgetKeeper>();
	}
};
static_assert(alignof(UBudgetKeeper) == 0x000008, "Wrong alignment on UBudgetKeeper");
static_assert(sizeof(UBudgetKeeper) == 0x000030, "Wrong size on UBudgetKeeper");

// Class UE4Dreamworld.DebugTeleportLocation
// 0x0000 (0x0378 - 0x0378)
class ADebugTeleportLocation final : public ANavigationObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTeleportLocation">();
	}
	static class ADebugTeleportLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugTeleportLocation>();
	}
};
static_assert(alignof(ADebugTeleportLocation) == 0x000008, "Wrong alignment on ADebugTeleportLocation");
static_assert(sizeof(ADebugTeleportLocation) == 0x000378, "Wrong size on ADebugTeleportLocation");

// Class UE4Dreamworld.FrameRateTracker
// 0x0028 (0x0080 - 0x0058)
class UFrameRateTracker : public UMetricsReporter
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAverageFps() const;
	float GetAverageFrameTime() const;
	float GetBestFps() const;
	float GetBestFrameTime() const;
	float GetElapsedTime() const;
	float GetWorstFps() const;
	float GetWorstFrameTime() const;
	int32 K2_GetFrameCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameRateTracker">();
	}
	static class UFrameRateTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrameRateTracker>();
	}
};
static_assert(alignof(UFrameRateTracker) == 0x000008, "Wrong alignment on UFrameRateTracker");
static_assert(sizeof(UFrameRateTracker) == 0x000080, "Wrong size on UFrameRateTracker");

// Class UE4Dreamworld.FrameRateReporter
// 0x0028 (0x00A8 - 0x0080)
class UFrameRateReporter final : public UFrameRateTracker
{
public:
	bool                                          Compact;                                           // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x27];                                      // 0x0081(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameRateReporter">();
	}
	static class UFrameRateReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrameRateReporter>();
	}
};
static_assert(alignof(UFrameRateReporter) == 0x000008, "Wrong alignment on UFrameRateReporter");
static_assert(sizeof(UFrameRateReporter) == 0x0000A8, "Wrong size on UFrameRateReporter");
static_assert(offsetof(UFrameRateReporter, Compact) == 0x000080, "Member 'UFrameRateReporter::Compact' has a wrong offset!");

// Class UE4Dreamworld.GameThreadMetricsReporter
// 0x0040 (0x0098 - 0x0058)
class UGameThreadMetricsReporter : public UMetricsReporter
{
public:
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameThreadMetricsReporter">();
	}
	static class UGameThreadMetricsReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameThreadMetricsReporter>();
	}
};
static_assert(alignof(UGameThreadMetricsReporter) == 0x000008, "Wrong alignment on UGameThreadMetricsReporter");
static_assert(sizeof(UGameThreadMetricsReporter) == 0x000098, "Wrong size on UGameThreadMetricsReporter");

// Class UE4Dreamworld.ApplyRadialDamageWithFalloffProxy
// 0x00C0 (0x00F8 - 0x0038)
class UApplyRadialDamageWithFalloffProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool AppliedDamage)> OnComplete;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0xB0];                                      // 0x0048(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UApplyRadialDamageWithFalloffProxy* ApplyRadialDamageAsync(const class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel);
	static class UApplyRadialDamageWithFalloffProxy* ApplyRadialDamageWithFalloffAsync(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel);
	static void BeginApplyRadialDamage(const class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel);
	static void BeginApplyRadialDamageWithFalloff(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplyRadialDamageWithFalloffProxy">();
	}
	static class UApplyRadialDamageWithFalloffProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplyRadialDamageWithFalloffProxy>();
	}
};
static_assert(alignof(UApplyRadialDamageWithFalloffProxy) == 0x000008, "Wrong alignment on UApplyRadialDamageWithFalloffProxy");
static_assert(sizeof(UApplyRadialDamageWithFalloffProxy) == 0x0000F8, "Wrong size on UApplyRadialDamageWithFalloffProxy");
static_assert(offsetof(UApplyRadialDamageWithFalloffProxy, OnComplete) == 0x000038, "Member 'UApplyRadialDamageWithFalloffProxy::OnComplete' has a wrong offset!");

// Class UE4Dreamworld.AsyncLineTraceByChannelProxy
// 0x0218 (0x0250 - 0x0038)
class alignas(0x10) UAsyncLineTraceByChannelProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FHitResult& OutHit, bool wasHit)> OnCompletion;       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x208];                                     // 0x0048(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncLineTraceByChannelProxy* AsyncLineTraceByChannel(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncLineTraceByChannelProxy">();
	}
	static class UAsyncLineTraceByChannelProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncLineTraceByChannelProxy>();
	}
};
static_assert(alignof(UAsyncLineTraceByChannelProxy) == 0x000010, "Wrong alignment on UAsyncLineTraceByChannelProxy");
static_assert(sizeof(UAsyncLineTraceByChannelProxy) == 0x000250, "Wrong size on UAsyncLineTraceByChannelProxy");
static_assert(offsetof(UAsyncLineTraceByChannelProxy, OnCompletion) == 0x000038, "Member 'UAsyncLineTraceByChannelProxy::OnCompletion' has a wrong offset!");

// Class UE4Dreamworld.DreamworldBlueprints
// 0x00E8 (0x0118 - 0x0030)
class UDreamworldBlueprints final : public UBlueprintFunctionLibrary
{
public:
	uint8                                         Pad_30[0xE8];                                      // 0x0030(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ChangeMaxRelevancyScaling(float Scaling);
	static void ClearUniqueID(class AActor* Actor);
	static class FString ClientGetPlayerId(class UObject* WorldContextObject);
	static class FString Conv_UniqueIDToString(const struct FUniqueID& UID);
	static class FText Conv_UUIDToText(const struct FUniqueID& Value, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
	static bool EqualEqual_UUIDUUID(const struct FUniqueID& A, const struct FUniqueID& B);
	static void GenerateBugReport();
	static class UObject* GetClassDefaultObject(class UClass* Class_0);
	static class FString GetConsoleUserIdOverride(const class FString& UserId, class APlayerController* Controller, class UObject* WorldContextObject);
	static void GetDreamworldVersion(class UObject* WorldContextObject, class FString* Branch, class FString* Project, class FString* configuration, class FString* Platform, int32* Revision, int32* base_revision, int32* Snapshot);
	static int32 GetNumStressClients(class UObject* WorldContextObject);
	static class FString GetPlayerId(class UObject* WorldContextObject, class APlayerState* PlayerState);
	static class FString GetServerName(class UObject* WorldContextObject);
	static bool IsDedicatedSession(class UObject* WorldContextObject);
	static bool IsDeveloperMode(class UObject* WorldContextObject);
	static bool IsDeveloperUniverse(class UObject* WorldContextObject);
	static bool IsInTrialMode();
	static bool IsSessionJoinable(class UObject* WorldContextObject, bool* bPublicJoinable, bool* bFriendJoinable, bool* bInviteOnly, bool* bAllowInvites);
	static bool IsStressClient();
	static bool IsValidUniqueID(const struct FUniqueID& UniqueID);
	static bool NotEqual_UUIDUUID(const struct FUniqueID& A, const struct FUniqueID& B);
	static bool PresenceSession(class UObject* WorldContextObject);
	static void SetUniqueID(class AActor* Actor, const struct FUniqueID& UID);
	static void ShowAccountPicker(class UObject* WorldContextObject);
	static bool SphereTraceSingleCollision(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ECollisionChannel CollisionChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static void StreamPlayerStartLevels(class UObject* WorldContextObject, bool bFlush);
	static bool ValidateOnlineSession(class UObject* WorldContextObject, const struct FBlueprintSessionResult& Session);
	static void ValidateOnlineSessions(class UObject* WorldContextObject, const TArray<struct FBlueprintSessionResult>& Search, TArray<struct FBlueprintSessionResult>* Valid, TArray<struct FBlueprintSessionResult>* Invalid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamworldBlueprints">();
	}
	static class UDreamworldBlueprints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamworldBlueprints>();
	}
};
static_assert(alignof(UDreamworldBlueprints) == 0x000008, "Wrong alignment on UDreamworldBlueprints");
static_assert(sizeof(UDreamworldBlueprints) == 0x000118, "Wrong size on UDreamworldBlueprints");

// Class UE4Dreamworld.DWCheatManager
// 0x0000 (0x0090 - 0x0090)
class UDWCheatManager : public UCheatManager
{
public:
	void CrashServer(const class FString& Message);
	void SimulateNetworkFailure(int32 ConnectionIndex, ENetworkFailure FailureType, bool bServer, const class FString& Message);
	class AActor* SummonPersistent(const class FString& ClassName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DWCheatManager">();
	}
	static class UDWCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDWCheatManager>();
	}
};
static_assert(alignof(UDWCheatManager) == 0x000008, "Wrong alignment on UDWCheatManager");
static_assert(sizeof(UDWCheatManager) == 0x000090, "Wrong size on UDWCheatManager");

// Class UE4Dreamworld.DWDebugLibrary
// 0x0000 (0x0030 - 0x0030)
class UDWDebugLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SaveScreenshot(class UObject* WorldContextObject, const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DWDebugLibrary">();
	}
	static class UDWDebugLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDWDebugLibrary>();
	}
};
static_assert(alignof(UDWDebugLibrary) == 0x000008, "Wrong alignment on UDWDebugLibrary");
static_assert(sizeof(UDWDebugLibrary) == 0x000030, "Wrong size on UDWDebugLibrary");

// Class UE4Dreamworld.DWGameInstance
// 0x0050 (0x0258 - 0x0208)
class UDWGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_208[0x50];                                     // 0x0208(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DWGameInstance">();
	}
	static class UDWGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDWGameInstance>();
	}
};
static_assert(alignof(UDWGameInstance) == 0x000008, "Wrong alignment on UDWGameInstance");
static_assert(sizeof(UDWGameInstance) == 0x000258, "Wrong size on UDWGameInstance");

// Class UE4Dreamworld.DWGenericLibrary
// 0x0000 (0x0030 - 0x0030)
class UDWGenericLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DWGenericLibrary">();
	}
	static class UDWGenericLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDWGenericLibrary>();
	}
};
static_assert(alignof(UDWGenericLibrary) == 0x000008, "Wrong alignment on UDWGenericLibrary");
static_assert(sizeof(UDWGenericLibrary) == 0x000030, "Wrong size on UDWGenericLibrary");

// Class UE4Dreamworld.DWWorldSettings
// 0x0038 (0x05F8 - 0x05C0)
class ADWWorldSettings : public AWorldSettings
{
public:
	TSoftClassPtr<class UClass>                   GameplaySchedulerClass;                            // 0x05C0(0x0030)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DWWorldSettings">();
	}
	static class ADWWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADWWorldSettings>();
	}
};
static_assert(alignof(ADWWorldSettings) == 0x000008, "Wrong alignment on ADWWorldSettings");
static_assert(sizeof(ADWWorldSettings) == 0x0005F8, "Wrong size on ADWWorldSettings");
static_assert(offsetof(ADWWorldSettings, GameplaySchedulerClass) == 0x0005C0, "Member 'ADWWorldSettings::GameplaySchedulerClass' has a wrong offset!");

// Class UE4Dreamworld.TsomTestDummy
// 0x0000 (0x0030 - 0x0030)
class UTsomTestDummy final : public UObject
{
public:
	int32 GetFavoriteNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TsomTestDummy">();
	}
	static class UTsomTestDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTsomTestDummy>();
	}
};
static_assert(alignof(UTsomTestDummy) == 0x000008, "Wrong alignment on UTsomTestDummy");
static_assert(sizeof(UTsomTestDummy) == 0x000030, "Wrong size on UTsomTestDummy");

// Class UE4Dreamworld.TestObject
// 0x0000 (0x0030 - 0x0030)
class UTestObject final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestObject">();
	}
	static class UTestObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestObject>();
	}
};
static_assert(alignof(UTestObject) == 0x000008, "Wrong alignment on UTestObject");
static_assert(sizeof(UTestObject) == 0x000030, "Wrong size on UTestObject");

// Class UE4Dreamworld.TestActor
// 0x0000 (0x0350 - 0x0350)
class ATestActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestActor">();
	}
	static class ATestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestActor>();
	}
};
static_assert(alignof(ATestActor) == 0x000008, "Wrong alignment on ATestActor");
static_assert(sizeof(ATestActor) == 0x000350, "Wrong size on ATestActor");

// Class UE4Dreamworld.WorldPersistenceSubsystem
// 0x01D8 (0x0210 - 0x0038)
class UWorldPersistenceSubsystem : public UWorldSubsystem
{
public:
	uint8                                         Pad_38[0x1BC];                                     // 0x0038(0x01BC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDirtySaveDelay;                                 // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPersistenceEnabled;                             // 0x0200(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_201[0xF];                                      // 0x0201(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldPersistenceSubsystem">();
	}
	static class UWorldPersistenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldPersistenceSubsystem>();
	}
};
static_assert(alignof(UWorldPersistenceSubsystem) == 0x000008, "Wrong alignment on UWorldPersistenceSubsystem");
static_assert(sizeof(UWorldPersistenceSubsystem) == 0x000210, "Wrong size on UWorldPersistenceSubsystem");
static_assert(offsetof(UWorldPersistenceSubsystem, MinDirtySaveDelay) == 0x0001F4, "Member 'UWorldPersistenceSubsystem::MinDirtySaveDelay' has a wrong offset!");
static_assert(offsetof(UWorldPersistenceSubsystem, bIsPersistenceEnabled) == 0x000200, "Member 'UWorldPersistenceSubsystem::bIsPersistenceEnabled' has a wrong offset!");

// Class UE4Dreamworld.ReplicationGraphNode_DynamicActorList
// 0x0000 (0x00D8 - 0x00D8)
class UReplicationGraphNode_DynamicActorList : public UReplicationGraphNode_ActorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicationGraphNode_DynamicActorList">();
	}
	static class UReplicationGraphNode_DynamicActorList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicationGraphNode_DynamicActorList>();
	}
};
static_assert(alignof(UReplicationGraphNode_DynamicActorList) == 0x000008, "Wrong alignment on UReplicationGraphNode_DynamicActorList");
static_assert(sizeof(UReplicationGraphNode_DynamicActorList) == 0x0000D8, "Wrong size on UReplicationGraphNode_DynamicActorList");

// Class UE4Dreamworld.ReplicationGraphNode_ReplicatedProxy
// 0x0000 (0x00D8 - 0x00D8)
class UReplicationGraphNode_ReplicatedProxy final : public UReplicationGraphNode_DynamicActorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicationGraphNode_ReplicatedProxy">();
	}
	static class UReplicationGraphNode_ReplicatedProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicationGraphNode_ReplicatedProxy>();
	}
};
static_assert(alignof(UReplicationGraphNode_ReplicatedProxy) == 0x000008, "Wrong alignment on UReplicationGraphNode_ReplicatedProxy");
static_assert(sizeof(UReplicationGraphNode_ReplicatedProxy) == 0x0000D8, "Wrong size on UReplicationGraphNode_ReplicatedProxy");

// Class UE4Dreamworld.DWReplicationGraph
// 0x00C0 (0x0780 - 0x06C0)
#pragma pack(push, 0x1)
class alignas(0x40) UDWReplicationGraph : public UReplicationGraph
{
public:
	uint8                                         Pad_698[0x98];                                     // 0x0698(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UReplicationGraphNode_ActorList*        AlwaysRelevantNode;                                // 0x0730(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReplicationGraphNode_DynamicActorList* ProxyNode;                                         // 0x0738(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsWithoutNetConnection;                        // 0x0740(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static void AddDependentActor(class AActor* Parent, class AActor* Child);
	static void RemoveDependentActor(class AActor* Parent, class AActor* Child);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DWReplicationGraph">();
	}
	static class UDWReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDWReplicationGraph>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDWReplicationGraph) == 0x000040, "Wrong alignment on UDWReplicationGraph");
static_assert(sizeof(UDWReplicationGraph) == 0x000780, "Wrong size on UDWReplicationGraph");
static_assert(offsetof(UDWReplicationGraph, AlwaysRelevantNode) == 0x000730, "Member 'UDWReplicationGraph::AlwaysRelevantNode' has a wrong offset!");
static_assert(offsetof(UDWReplicationGraph, ProxyNode) == 0x000738, "Member 'UDWReplicationGraph::ProxyNode' has a wrong offset!");
static_assert(offsetof(UDWReplicationGraph, ActorsWithoutNetConnection) == 0x000740, "Member 'UDWReplicationGraph::ActorsWithoutNetConnection' has a wrong offset!");

// Class UE4Dreamworld.SceneValidator
// 0x0040 (0x0070 - 0x0030)
class USceneValidator : public UObject
{
public:
	class USceneValidatorManager*                 Manager;                                           // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 ValidationWorld;                                   // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IterateGrid;                                       // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConsiderEditorOnlyActorsForBounds;                 // 0x0069(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GatherWorldData(class UWorld* World);
	void GatherWorldSectionData(class UWorld* World, const struct FValidationWorldSection& WorldSection);
	void GatherWorldSectionStats(class UWorld* World, const struct FValidationWorldSection& WorldSection);
	void GatherWorldStats(class UWorld* World);
	bool ValidateWorld(bool bSectionsPassedValidation);
	bool ValidateWorldSection(const struct FValidationWorldSection& WorldSection);
	void WriteKeyToStats(const class FString& Key, int32 Data);
	void WriteToStats(class UStruct* Data);

	class UWorld* GetValidationWorld() const;
	void GetWorldSections(TArray<struct FValidationWorldSection>* OutSections, bool bIncludeEditor) const;
	void GetWorldSectionsForBox(const struct FBox& Box, TArray<struct FValidationWorldSection>* OutSections, bool bIncludeEditor, bool* bOutClamped) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneValidator">();
	}
	static class USceneValidator* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneValidator>();
	}
};
static_assert(alignof(USceneValidator) == 0x000008, "Wrong alignment on USceneValidator");
static_assert(sizeof(USceneValidator) == 0x000070, "Wrong size on USceneValidator");
static_assert(offsetof(USceneValidator, Manager) == 0x000030, "Member 'USceneValidator::Manager' has a wrong offset!");
static_assert(offsetof(USceneValidator, ValidationWorld) == 0x000060, "Member 'USceneValidator::ValidationWorld' has a wrong offset!");
static_assert(offsetof(USceneValidator, IterateGrid) == 0x000068, "Member 'USceneValidator::IterateGrid' has a wrong offset!");
static_assert(offsetof(USceneValidator, ConsiderEditorOnlyActorsForBounds) == 0x000069, "Member 'USceneValidator::ConsiderEditorOnlyActorsForBounds' has a wrong offset!");

// Class UE4Dreamworld.SceneValidatorFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class USceneValidatorFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddValidationError(const class FString& Message, const class UObject* ContextObj, const struct FBox& SectionBounds);
	static void AddValidationInfo(const class FString& Message, const class UObject* ContextObj, const struct FBox& SectionBounds);
	static void AddValidationWarning(const class FString& Message, const class UObject* ContextObj, const struct FBox& SectionBounds);
	static void ConditionalBreakpoint(bool bBreak);
	static void GetAllObjectsOfClass(TArray<class UObject*>* OutObjects, class UClass* Class_0, class UWorld* World, bool bIncludeEditorOnly);
	static void GetCollisionTransforms(class UPrimitiveComponent* PrimitiveComponent, const struct FBox& Bounds, TArray<struct FTransform>* OutCollisionTransforms);
	static int32 GetNumCollisionTris(class UPrimitiveComponent* PrimitiveComponent, const struct FBox& Bounds);
	static void GetTriangleCount(class UPrimitiveComponent* PrimitiveComponent, const struct FBox& Bounds, int64* NaniteTriangles, int64* Triangles, int64* BodyCount);
	static void OverlapMultiByChannelForBox(TArray<struct FBoxOverlapResult>* OutOverlaps, const class UWorld* World, const struct FBox& Box, const ECollisionChannel Channel, const EBoxOverlapMobilityType MobilityType);
	static void SortArrayWithComparisonValues(const TArray<int32>& inArray, const TArray<int32>& ComparisonValues, TArray<int32>* OutArray);
	static void SweepSingleByChannelForBox(struct FHitResult* OutHit, const class UWorld* World, const struct FVector& BoxExtent, const struct FVector& Start, const struct FVector& End, const struct FQuat& Rot, ECollisionChannel TraceChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneValidatorFunctionLibrary">();
	}
	static class USceneValidatorFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneValidatorFunctionLibrary>();
	}
};
static_assert(alignof(USceneValidatorFunctionLibrary) == 0x000008, "Wrong alignment on USceneValidatorFunctionLibrary");
static_assert(sizeof(USceneValidatorFunctionLibrary) == 0x000030, "Wrong size on USceneValidatorFunctionLibrary");

// Class UE4Dreamworld.SceneValidatorManager
// 0x0150 (0x0180 - 0x0030)
class USceneValidatorManager : public UObject
{
public:
	TArray<TSubclassOf<class USceneValidator>>    SceneValidatorClasses;                             // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x140];                                     // 0x0040(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneValidatorManager">();
	}
	static class USceneValidatorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneValidatorManager>();
	}
};
static_assert(alignof(USceneValidatorManager) == 0x000008, "Wrong alignment on USceneValidatorManager");
static_assert(sizeof(USceneValidatorManager) == 0x000180, "Wrong size on USceneValidatorManager");
static_assert(offsetof(USceneValidatorManager, SceneValidatorClasses) == 0x000030, "Member 'USceneValidatorManager::SceneValidatorClasses' has a wrong offset!");

// Class UE4Dreamworld.PingReporter
// 0x0028 (0x0080 - 0x0058)
class UPingReporter final : public UMetricsReporter
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingReporter">();
	}
	static class UPingReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingReporter>();
	}
};
static_assert(alignof(UPingReporter) == 0x000008, "Wrong alignment on UPingReporter");
static_assert(sizeof(UPingReporter) == 0x000080, "Wrong size on UPingReporter");

// Class UE4Dreamworld.DWLocalPlayer
// 0x00A8 (0x03A0 - 0x02F8)
class UDWLocalPlayer : public ULocalPlayer
{
public:
	uint8                                         Pad_2F8[0xA8];                                     // 0x02F8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DWLocalPlayer">();
	}
	static class UDWLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDWLocalPlayer>();
	}
};
static_assert(alignof(UDWLocalPlayer) == 0x000008, "Wrong alignment on UDWLocalPlayer");
static_assert(sizeof(UDWLocalPlayer) == 0x0003A0, "Wrong size on UDWLocalPlayer");

}


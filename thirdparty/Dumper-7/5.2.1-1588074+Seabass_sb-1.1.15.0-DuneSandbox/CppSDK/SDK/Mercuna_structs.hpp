#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mercuna

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum Mercuna.EMercunaNavigationLinkDirection
// NumValues: 0x0004
enum class EMercunaNavigationLinkDirection : uint8
{
	BothWays                                 = 0,
	LeftToRight                              = 1,
	RightToLeft                              = 2,
	EMercunaNavigationLinkDirection_MAX      = 3,
};

// Enum Mercuna.EMercunaGridType
// NumValues: 0x0005
enum class EMercunaGridType : uint32
{
	None                                     = 0,
	Ground                                   = 1,
	Surface                                  = 2,
	Both                                     = 3,
	EMercunaGridType_MAX                     = 4,
};

// Enum Mercuna.EMercunaPathEvent
// NumValues: 0x0004
enum class EMercunaPathEvent : uint8
{
	Ready                                    = 0,
	Updated                                  = 1,
	Invalid                                  = 2,
	EMercunaPathEvent_MAX                    = 3,
};

// Enum Mercuna.EMercunaMoveResult
// NumValues: 0x0006
enum class EMercunaMoveResult : uint8
{
	Success                                  = 0,
	Failed                                   = 1,
	Cancelled                                = 2,
	Blocked                                  = 3,
	Invalid                                  = 4,
	EMercunaMoveResult_MAX                   = 5,
};

// Enum Mercuna.EMercunaAvoidanceMode
// NumValues: 0x0004
enum class EMercunaAvoidanceMode : uint8
{
	None                                     = 0,
	ORCA                                     = 1,
	ContextualSteering                       = 2,
	EMercunaAvoidanceMode_MAX                = 3,
};

// Enum Mercuna.EMercunaMoveInForwardDirection
// NumValues: 0x0004
enum class EMercunaMoveInForwardDirection : uint8
{
	Always                                   = 0,
	Prefer                                   = 1,
	Independent                              = 2,
	EMercunaMoveInForwardDirection_MAX       = 3,
};

// Enum Mercuna.EMercunaPointDistribution
// NumValues: 0x0003
enum class EMercunaPointDistribution : uint8
{
	Uniform                                  = 0,
	Random                                   = 1,
	EMercunaPointDistribution_MAX            = 2,
};

// Enum Mercuna.EMercunaProjectionType
// NumValues: 0x0004
enum class EMercunaProjectionType : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	UpOrDown                                 = 2,
	EMercunaProjectionType_MAX               = 3,
};

// Enum Mercuna.EMercunaNavLinkQueryMode
// NumValues: 0x0004
enum class EMercunaNavLinkQueryMode : uint8
{
	All                                      = 0,
	CurrentGrid                              = 1,
	None                                     = 2,
	EMercunaNavLinkQueryMode_MAX             = 3,
};

// Enum Mercuna.EMercunaAutoNavLinkTraversalType
// NumValues: 0x0003
enum class EMercunaAutoNavLinkTraversalType : uint8
{
	OneWay                                   = 0,
	Bidirectional                            = 1,
	EMercunaAutoNavLinkTraversalType_MAX     = 2,
};

// Enum Mercuna.EMercunaInvokerVolumeType
// NumValues: 0x0003
enum class EMercunaInvokerVolumeType : uint8
{
	Always                                   = 0,
	OnOverlap                                = 1,
	EMercunaInvokerVolumeType_MAX            = 2,
};

// Enum Mercuna.EMercunaLevelOfDetail
// NumValues: 0x0006
enum class EMercunaLevelOfDetail : uint8
{
	Full                                     = 0,
	Half                                     = 1,
	Quarter                                  = 2,
	Eighth                                   = 3,
	Sixteenth                                = 4,
	EMercunaLevelOfDetail_MAX                = 5,
};

// Enum Mercuna.EMercunaObstacleType
// NumValues: 0x0004
enum class EMercunaObstacleType : uint8
{
	Sphere                                   = 0,
	Box                                      = 1,
	Cylinder                                 = 2,
	EMercunaObstacleType_MAX                 = 3,
};

// Enum Mercuna.EMercunaObstacleMovementType
// NumValues: 0x0005
enum class EMercunaObstacleMovementType : uint8
{
	ThreeDimensional                         = 0,
	Character                                = 1,
	Vehicle                                  = 2,
	None                                     = 3,
	EMercunaObstacleMovementType_MAX         = 4,
};

// Enum Mercuna.EMercunaObstacleReaction
// NumValues: 0x0003
enum class EMercunaObstacleReaction : uint8
{
	Avoid                                    = 0,
	DoNotAvoid                               = 1,
	EMercunaObstacleReaction_MAX             = 2,
};

// Enum Mercuna.EMerOctreeDebugDrawMode
// NumValues: 0x0008
enum class EMerOctreeDebugDrawMode : uint8
{
	DISABLED                                 = 0,
	UNNAVIGABLE                              = 1,
	NAVIGABLE                                = 2,
	CROSS_SECTION                            = 3,
	REACHABLE                                = 4,
	PATHFIND                                 = 5,
	REGION                                   = 6,
	EMerOctreeDebugDrawMode_MAX              = 7,
};

// Enum Mercuna.EMerGridDebugDrawMode
// NumValues: 0x0005
enum class EMerGridDebugDrawMode : uint8
{
	DISABLED                                 = 0,
	GRID                                     = 1,
	POLYMESH                                 = 2,
	QUERY                                    = 3,
	EMerGridDebugDrawMode_MAX                = 4,
};

// Enum Mercuna.EMerGridDebugDrawSubmode
// NumValues: 0x000D
enum class EMerGridDebugDrawSubmode : uint8
{
	NAVIGABLE                                = 0,
	SURFACE_TYPE                             = 1,
	USAGE_TYPE                               = 2,
	ORIENTATIONS                             = 3,
	NAVLINKS                                 = 4,
	SURFACE_NORMALS                          = 5,
	POLYGONS                                 = 6,
	CONNECTIONS                              = 7,
	QUERY_COST                               = 8,
	QUERY_HEURISTIC                          = 9,
	QUERY_TOTAL                              = 10,
	QUERY_DISTANCE_FIELD                     = 11,
	EMerGridDebugDrawSubmode_MAX             = 12,
};

// Enum Mercuna.EMercunaModifierVolumeShape
// NumValues: 0x0005
enum class EMercunaModifierVolumeShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Cylinder                                 = 2,
	Prism                                    = 3,
	EMercunaModifierVolumeShape_MAX          = 4,
};

// Enum Mercuna.EMercunaAvoidanceWhenStationary
// NumValues: 0x0004
enum class EMercunaAvoidanceWhenStationary : uint8
{
	None                                     = 0,
	CollisionOnly                            = 1,
	Full                                     = 2,
	EMercunaAvoidanceWhenStationary_MAX      = 3,
};

// Enum Mercuna.EMerNavigationTrajectory
// NumValues: 0x0005
enum class EMerNavigationTrajectory : uint8
{
	Trajectory                               = 0,
	Avoiding                                 = 1,
	NavLink                                  = 2,
	None                                     = 3,
	EMerNavigationTrajectory_MAX             = 4,
};

// Enum Mercuna.EMercunaNavigationExclusionType
// NumValues: 0x0004
enum class EMercunaNavigationExclusionType : uint8
{
	Navigation                               = 0,
	AutoLinks                                = 1,
	All                                      = 2,
	EMercunaNavigationExclusionType_MAX      = 3,
};

// Enum Mercuna.EMercunaMoveGoal
// NumValues: 0x0004
enum class EMercunaMoveGoal : uint8
{
	Actor                                    = 0,
	Vector                                   = 1,
	None                                     = 2,
	EMercunaMoveGoal_MAX                     = 3,
};

// Enum Mercuna.EMercunaNavGraphType
// NumValues: 0x0005
enum class EMercunaNavGraphType : uint8
{
	ThreeDimensional                         = 0,
	Ground                                   = 1,
	Surface                                  = 2,
	Invalid                                  = 3,
	EMercunaNavGraphType_MAX                 = 4,
};

// Enum Mercuna.EMercunaGroundAgentCategory
// NumValues: 0x0004
enum class EMercunaGroundAgentCategory : uint8
{
	Character                                = 0,
	Animal                                   = 1,
	Vehicle                                  = 2,
	EMercunaGroundAgentCategory_MAX          = 3,
};

// Enum Mercuna.EMercunaGroundAgentShape
// NumValues: 0x0003
enum class EMercunaGroundAgentShape : uint8
{
	Rectangle                                = 0,
	Circle                                   = 1,
	EMercunaGroundAgentShape_MAX             = 2,
};

// Enum Mercuna.EMercunaTurnInPlace
// NumValues: 0x0004
enum class EMercunaTurnInPlace : uint8
{
	Never                                    = 0,
	PreferNotTo                              = 1,
	Allowed                                  = 2,
	EMercunaTurnInPlace_MAX                  = 3,
};

// Enum Mercuna.EMercunaProjectionDirection
// NumValues: 0x0004
enum class EMercunaProjectionDirection : uint8
{
	Down                                     = 0,
	Up                                       = 1,
	Closest                                  = 2,
	EMercunaProjectionDirection_MAX          = 3,
};

// Enum Mercuna.EMercunaNavGraphVolumeOrientation
// NumValues: 0x0004
enum class EMercunaNavGraphVolumeOrientation : uint8
{
	LinkedRotation                           = 0,
	RotateVolumesToGraphs                    = 1,
	NoRotation                               = 2,
	EMercunaNavGraphVolumeOrientation_MAX    = 3,
};

// ScriptStruct Mercuna.MercunaGroundNavigationConfiguration
// 0x001C (0x001C - 0x0000)
struct FMercunaGroundNavigationConfiguration final
{
public:
	bool                                          StopAtDestination;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAvoidanceTime;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAvoidanceWhenStationary               AvoidanceWhenStationary;                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopePenalty;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TractionEstimate;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAheadDistance;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShrinkCapsuleDuringAutoJumps;                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaGroundNavigationConfiguration) == 0x000004, "Wrong alignment on FMercunaGroundNavigationConfiguration");
static_assert(sizeof(FMercunaGroundNavigationConfiguration) == 0x00001C, "Wrong size on FMercunaGroundNavigationConfiguration");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, StopAtDestination) == 0x000000, "Member 'FMercunaGroundNavigationConfiguration::StopAtDestination' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, MinAvoidanceTime) == 0x000004, "Member 'FMercunaGroundNavigationConfiguration::MinAvoidanceTime' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, AvoidanceWhenStationary) == 0x000008, "Member 'FMercunaGroundNavigationConfiguration::AvoidanceWhenStationary' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, SlopePenalty) == 0x00000C, "Member 'FMercunaGroundNavigationConfiguration::SlopePenalty' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, TractionEstimate) == 0x000010, "Member 'FMercunaGroundNavigationConfiguration::TractionEstimate' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, LookAheadDistance) == 0x000014, "Member 'FMercunaGroundNavigationConfiguration::LookAheadDistance' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, ShrinkCapsuleDuringAutoJumps) == 0x000018, "Member 'FMercunaGroundNavigationConfiguration::ShrinkCapsuleDuringAutoJumps' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavUsageTypes
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FMercunaNavUsageTypes final
{
public:
	uint8                                         bUsageType0 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType1 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType2 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType3 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType4 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType5 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType6 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType7 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType8 : 1;                                   // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType9 : 1;                                   // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType10 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType11 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType12 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType13 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType14 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType15 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType16 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType17 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType18 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType19 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType20 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType21 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType22 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType23 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType24 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType25 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType26 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType27 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType28 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType29 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType30 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType31 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FMercunaNavUsageTypes) == 0x000004, "Wrong alignment on FMercunaNavUsageTypes");
static_assert(sizeof(FMercunaNavUsageTypes) == 0x000004, "Wrong size on FMercunaNavUsageTypes");

// ScriptStruct Mercuna.MercunaTrackRequest
// 0x0030 (0x0030 - 0x0000)
struct FMercunaTrackRequest final
{
public:
	class AActor*                                 TrackActor;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaTrackRequest) == 0x000008, "Wrong alignment on FMercunaTrackRequest");
static_assert(sizeof(FMercunaTrackRequest) == 0x000030, "Wrong size on FMercunaTrackRequest");
static_assert(offsetof(FMercunaTrackRequest, TrackActor) == 0x000000, "Member 'FMercunaTrackRequest::TrackActor' has a wrong offset!");

// ScriptStruct Mercuna.MercunaAgentType
// 0x000C (0x000C - 0x0000)
struct FMercunaAgentType
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaGridType                              GridType;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaAgentType) == 0x000004, "Wrong alignment on FMercunaAgentType");
static_assert(sizeof(FMercunaAgentType) == 0x00000C, "Wrong size on FMercunaAgentType");
static_assert(offsetof(FMercunaAgentType, Name) == 0x000000, "Member 'FMercunaAgentType::Name' has a wrong offset!");
static_assert(offsetof(FMercunaAgentType, GridType) == 0x000008, "Member 'FMercunaAgentType::GridType' has a wrong offset!");

// ScriptStruct Mercuna.MercunaSupportedAgentTypes
// 0x00A8 (0x00A8 - 0x0000)
struct FMercunaSupportedAgentTypes final
{
public:
	TSet<struct FMercunaAgentType>                AgentTypes;                                        // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	EMercunaGridType                              GridType;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FMercunaAgentType, int32>         Types;                                             // 0x0058(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMercunaSupportedAgentTypes) == 0x000008, "Wrong alignment on FMercunaSupportedAgentTypes");
static_assert(sizeof(FMercunaSupportedAgentTypes) == 0x0000A8, "Wrong size on FMercunaSupportedAgentTypes");
static_assert(offsetof(FMercunaSupportedAgentTypes, AgentTypes) == 0x000000, "Member 'FMercunaSupportedAgentTypes::AgentTypes' has a wrong offset!");
static_assert(offsetof(FMercunaSupportedAgentTypes, GridType) == 0x000050, "Member 'FMercunaSupportedAgentTypes::GridType' has a wrong offset!");
static_assert(offsetof(FMercunaSupportedAgentTypes, Types) == 0x000058, "Member 'FMercunaSupportedAgentTypes::Types' has a wrong offset!");

// ScriptStruct Mercuna.MercunaContextualSteeringActorParameters
// 0x0010 (0x0010 - 0x0000)
struct FMercunaContextualSteeringActorParameters final
{
public:
	float                                         RepulsionDistance;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepulsionWeight;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CohesionDistance;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CohesionWeight;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaContextualSteeringActorParameters) == 0x000004, "Wrong alignment on FMercunaContextualSteeringActorParameters");
static_assert(sizeof(FMercunaContextualSteeringActorParameters) == 0x000010, "Wrong size on FMercunaContextualSteeringActorParameters");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, RepulsionDistance) == 0x000000, "Member 'FMercunaContextualSteeringActorParameters::RepulsionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, RepulsionWeight) == 0x000004, "Member 'FMercunaContextualSteeringActorParameters::RepulsionWeight' has a wrong offset!");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, CohesionDistance) == 0x000008, "Member 'FMercunaContextualSteeringActorParameters::CohesionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, CohesionWeight) == 0x00000C, "Member 'FMercunaContextualSteeringActorParameters::CohesionWeight' has a wrong offset!");

// ScriptStruct Mercuna.MercunaModifier
// 0x0008 (0x0008 - 0x0000)
struct FMercunaModifier final
{
public:
	float                                         CostMultiplier;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaNavUsageTypes                  UsageTypes;                                        // 0x0004(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaModifier) == 0x000004, "Wrong alignment on FMercunaModifier");
static_assert(sizeof(FMercunaModifier) == 0x000008, "Wrong size on FMercunaModifier");
static_assert(offsetof(FMercunaModifier, CostMultiplier) == 0x000000, "Member 'FMercunaModifier::CostMultiplier' has a wrong offset!");
static_assert(offsetof(FMercunaModifier, UsageTypes) == 0x000004, "Member 'FMercunaModifier::UsageTypes' has a wrong offset!");

// ScriptStruct Mercuna.Mercuna2DAgentProperties
// 0x00B8 (0x00B8 - 0x0000)
struct FMercuna2DAgentProperties
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepHeight;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightClearance;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleChange;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FSoftObjectPath>                  NavigableMaterials;                                // 0x0018(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  UnnavigableMaterials;                              // 0x0068(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercuna2DAgentProperties) == 0x000008, "Wrong alignment on FMercuna2DAgentProperties");
static_assert(sizeof(FMercuna2DAgentProperties) == 0x0000B8, "Wrong size on FMercuna2DAgentProperties");
static_assert(offsetof(FMercuna2DAgentProperties, StepHeight) == 0x000008, "Member 'FMercuna2DAgentProperties::StepHeight' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, HeightClearance) == 0x00000C, "Member 'FMercuna2DAgentProperties::HeightClearance' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, MaxAngleChange) == 0x000010, "Member 'FMercuna2DAgentProperties::MaxAngleChange' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, NavigableMaterials) == 0x000018, "Member 'FMercuna2DAgentProperties::NavigableMaterials' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, UnnavigableMaterials) == 0x000068, "Member 'FMercuna2DAgentProperties::UnnavigableMaterials' has a wrong offset!");

// ScriptStruct Mercuna.MercunaSurfaceAgentProperties
// 0x0008 (0x00C0 - 0x00B8)
struct FMercunaSurfaceAgentProperties final : public FMercuna2DAgentProperties
{
public:
	float                                         PawnRadius;                                        // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaSurfaceAgentProperties) == 0x000008, "Wrong alignment on FMercunaSurfaceAgentProperties");
static_assert(sizeof(FMercunaSurfaceAgentProperties) == 0x0000C0, "Wrong size on FMercunaSurfaceAgentProperties");
static_assert(offsetof(FMercunaSurfaceAgentProperties, PawnRadius) == 0x0000B8, "Member 'FMercunaSurfaceAgentProperties::PawnRadius' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavigationLink
// 0x00E0 (0x00E0 - 0x0000)
struct FMercunaNavigationLink final
{
public:
	struct FTransform                             Left;                                              // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Right;                                             // 0x0060(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavigationLinkDirection               Direction;                                         // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDistanceAsCost;                                // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftToRightCost;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightToLeftCost;                                   // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftAutoCompletionDistance;                        // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAutoCompletionDistance;                       // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftEntryAngle;                                    // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightEntryAngle;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaNavigationLink) == 0x000010, "Wrong alignment on FMercunaNavigationLink");
static_assert(sizeof(FMercunaNavigationLink) == 0x0000E0, "Wrong size on FMercunaNavigationLink");
static_assert(offsetof(FMercunaNavigationLink, Left) == 0x000000, "Member 'FMercunaNavigationLink::Left' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, Right) == 0x000060, "Member 'FMercunaNavigationLink::Right' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, Direction) == 0x0000C0, "Member 'FMercunaNavigationLink::Direction' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, bUseDistanceAsCost) == 0x0000C1, "Member 'FMercunaNavigationLink::bUseDistanceAsCost' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, LeftToRightCost) == 0x0000C4, "Member 'FMercunaNavigationLink::LeftToRightCost' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, RightToLeftCost) == 0x0000C8, "Member 'FMercunaNavigationLink::RightToLeftCost' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, LeftAutoCompletionDistance) == 0x0000CC, "Member 'FMercunaNavigationLink::LeftAutoCompletionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, RightAutoCompletionDistance) == 0x0000D0, "Member 'FMercunaNavigationLink::RightAutoCompletionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, LeftEntryAngle) == 0x0000D4, "Member 'FMercunaNavigationLink::LeftEntryAngle' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, RightEntryAngle) == 0x0000D8, "Member 'FMercunaNavigationLink::RightEntryAngle' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavInvoker
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FMercunaNavInvoker final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaNavInvoker) == 0x000004, "Wrong alignment on FMercunaNavInvoker");
static_assert(sizeof(FMercunaNavInvoker) == 0x00001C, "Wrong size on FMercunaNavInvoker");

// ScriptStruct Mercuna.MercunaPawnUsageFlags
// 0x0008 (0x0008 - 0x0000)
struct FMercunaPawnUsageFlags final
{
public:
	struct FMercunaNavUsageTypes                  RequiredUsageFlags;                                // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FMercunaNavUsageTypes                  AllowedUsageFlags;                                 // 0x0004(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaPawnUsageFlags) == 0x000004, "Wrong alignment on FMercunaPawnUsageFlags");
static_assert(sizeof(FMercunaPawnUsageFlags) == 0x000008, "Wrong size on FMercunaPawnUsageFlags");
static_assert(offsetof(FMercunaPawnUsageFlags, RequiredUsageFlags) == 0x000000, "Member 'FMercunaPawnUsageFlags::RequiredUsageFlags' has a wrong offset!");
static_assert(offsetof(FMercunaPawnUsageFlags, AllowedUsageFlags) == 0x000004, "Member 'FMercunaPawnUsageFlags::AllowedUsageFlags' has a wrong offset!");

// ScriptStruct Mercuna.MercunaMoveRequest
// 0x0060 (0x0060 - 0x0000)
struct FMercunaMoveRequest
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaMoveRequest) == 0x000008, "Wrong alignment on FMercunaMoveRequest");
static_assert(sizeof(FMercunaMoveRequest) == 0x000060, "Wrong size on FMercunaMoveRequest");
static_assert(offsetof(FMercunaMoveRequest, GoalActor) == 0x000008, "Member 'FMercunaMoveRequest::GoalActor' has a wrong offset!");

// ScriptStruct Mercuna.MercunaMoveRequest2D
// 0x0018 (0x0078 - 0x0060)
struct FMercunaMoveRequest2D : public FMercunaMoveRequest
{
public:
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaMoveRequest2D) == 0x000008, "Wrong alignment on FMercunaMoveRequest2D");
static_assert(sizeof(FMercunaMoveRequest2D) == 0x000078, "Wrong size on FMercunaMoveRequest2D");

// ScriptStruct Mercuna.MercunaMoveRequest3D
// 0x0008 (0x0068 - 0x0060)
struct FMercunaMoveRequest3D final : public FMercunaMoveRequest
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaMoveRequest3D) == 0x000008, "Wrong alignment on FMercunaMoveRequest3D");
static_assert(sizeof(FMercunaMoveRequest3D) == 0x000068, "Wrong size on FMercunaMoveRequest3D");

// ScriptStruct Mercuna.Mercuna3DNavigationConfiguration
// 0x001C (0x001C - 0x0000)
struct FMercuna3DNavigationConfiguration final
{
public:
	float                                         MaxPitch;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRoll;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaMoveInForwardDirection                MoveInForwardDirection;                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopAtDestination;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAvoidanceWhenStationary               AvoidanceWhenStationary;                           // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightChangePenalty;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SmoothPaths;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAheadTime;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAnticipationTime;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercuna3DNavigationConfiguration) == 0x000004, "Wrong alignment on FMercuna3DNavigationConfiguration");
static_assert(sizeof(FMercuna3DNavigationConfiguration) == 0x00001C, "Wrong size on FMercuna3DNavigationConfiguration");
static_assert(offsetof(FMercuna3DNavigationConfiguration, MaxPitch) == 0x000000, "Member 'FMercuna3DNavigationConfiguration::MaxPitch' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, MaxRoll) == 0x000004, "Member 'FMercuna3DNavigationConfiguration::MaxRoll' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, MoveInForwardDirection) == 0x000008, "Member 'FMercuna3DNavigationConfiguration::MoveInForwardDirection' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, StopAtDestination) == 0x000009, "Member 'FMercuna3DNavigationConfiguration::StopAtDestination' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, AvoidanceWhenStationary) == 0x00000A, "Member 'FMercuna3DNavigationConfiguration::AvoidanceWhenStationary' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, HeightChangePenalty) == 0x00000C, "Member 'FMercuna3DNavigationConfiguration::HeightChangePenalty' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, SmoothPaths) == 0x000010, "Member 'FMercuna3DNavigationConfiguration::SmoothPaths' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, LookAheadTime) == 0x000014, "Member 'FMercuna3DNavigationConfiguration::LookAheadTime' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, RollAnticipationTime) == 0x000018, "Member 'FMercuna3DNavigationConfiguration::RollAnticipationTime' has a wrong offset!");

// ScriptStruct Mercuna.MercunaMoveRequestGround
// 0x0000 (0x0078 - 0x0078)
struct FMercunaMoveRequestGround final : public FMercunaMoveRequest2D
{
};
static_assert(alignof(FMercunaMoveRequestGround) == 0x000008, "Wrong alignment on FMercunaMoveRequestGround");
static_assert(sizeof(FMercunaMoveRequestGround) == 0x000078, "Wrong size on FMercunaMoveRequestGround");

// ScriptStruct Mercuna.MercunaGroundNavigationSteeringParameters
// 0x0020 (0x0020 - 0x0000)
struct FMercunaGroundNavigationSteeringParameters final
{
public:
	bool                                          bKinematicPathfinding;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurningRadius;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTurningRadius;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThrottleAcceleration;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrakeDeceleration;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaGroundNavigationSteeringParameters) == 0x000004, "Wrong alignment on FMercunaGroundNavigationSteeringParameters");
static_assert(sizeof(FMercunaGroundNavigationSteeringParameters) == 0x000020, "Wrong size on FMercunaGroundNavigationSteeringParameters");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, bKinematicPathfinding) == 0x000000, "Member 'FMercunaGroundNavigationSteeringParameters::bKinematicPathfinding' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxSpeed) == 0x000004, "Member 'FMercunaGroundNavigationSteeringParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxAcceleration) == 0x000008, "Member 'FMercunaGroundNavigationSteeringParameters::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, IdealTurningRadius) == 0x00000C, "Member 'FMercunaGroundNavigationSteeringParameters::IdealTurningRadius' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MinTurningRadius) == 0x000010, "Member 'FMercunaGroundNavigationSteeringParameters::MinTurningRadius' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxThrottleAcceleration) == 0x000014, "Member 'FMercunaGroundNavigationSteeringParameters::MaxThrottleAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxBrakeDeceleration) == 0x000018, "Member 'FMercunaGroundNavigationSteeringParameters::MaxBrakeDeceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, GroundFriction) == 0x00001C, "Member 'FMercunaGroundNavigationSteeringParameters::GroundFriction' has a wrong offset!");

// ScriptStruct Mercuna.MercunaGroundNavigationDynamicSteeringParameters
// 0x0010 (0x0010 - 0x0000)
struct FMercunaGroundNavigationDynamicSteeringParameters final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrakingDeceleration;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerToWeightRatio;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaGroundNavigationDynamicSteeringParameters) == 0x000004, "Wrong alignment on FMercunaGroundNavigationDynamicSteeringParameters");
static_assert(sizeof(FMercunaGroundNavigationDynamicSteeringParameters) == 0x000010, "Wrong size on FMercunaGroundNavigationDynamicSteeringParameters");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, MaxSpeed) == 0x000000, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, MaxAcceleration) == 0x000004, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, MaxBrakingDeceleration) == 0x000008, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::MaxBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, PowerToWeightRatio) == 0x00000C, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::PowerToWeightRatio' has a wrong offset!");

// ScriptStruct Mercuna.MercunaAutoNavLinkIdentifier
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FMercunaAutoNavLinkIdentifier final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaAutoNavLinkIdentifier) == 0x000008, "Wrong alignment on FMercunaAutoNavLinkIdentifier");
static_assert(sizeof(FMercunaAutoNavLinkIdentifier) == 0x000028, "Wrong size on FMercunaAutoNavLinkIdentifier");

// ScriptStruct Mercuna.MercunaAutoNavLink
// 0x00A0 (0x00A0 - 0x0000)
struct FMercunaAutoNavLink final
{
public:
	struct FMercunaAutoNavLinkIdentifier          Identifier;                                        // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAutoNavLinkTraversalType              TraversalType;                                     // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaNavUsageTypes                  UsageTypes;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartHalfRail;                                     // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndHalfRail;                                       // 0x0078(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cost;                                              // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMin;                                         // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMax;                                         // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaAutoNavLink) == 0x000008, "Wrong alignment on FMercunaAutoNavLink");
static_assert(sizeof(FMercunaAutoNavLink) == 0x0000A0, "Wrong size on FMercunaAutoNavLink");
static_assert(offsetof(FMercunaAutoNavLink, Identifier) == 0x000000, "Member 'FMercunaAutoNavLink::Identifier' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, bEnabled) == 0x000028, "Member 'FMercunaAutoNavLink::bEnabled' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, TraversalType) == 0x000029, "Member 'FMercunaAutoNavLink::TraversalType' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, UsageTypes) == 0x00002C, "Member 'FMercunaAutoNavLink::UsageTypes' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, Start) == 0x000030, "Member 'FMercunaAutoNavLink::Start' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, StartHalfRail) == 0x000048, "Member 'FMercunaAutoNavLink::StartHalfRail' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, End) == 0x000060, "Member 'FMercunaAutoNavLink::End' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, EndHalfRail) == 0x000078, "Member 'FMercunaAutoNavLink::EndHalfRail' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, Cost) == 0x000090, "Member 'FMercunaAutoNavLink::Cost' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, HeightMin) == 0x000094, "Member 'FMercunaAutoNavLink::HeightMin' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, HeightMax) == 0x000098, "Member 'FMercunaAutoNavLink::HeightMax' has a wrong offset!");

// ScriptStruct Mercuna.MercunaAutoNavLinkForUpdate
// 0x0038 (0x0038 - 0x0000)
struct FMercunaAutoNavLinkForUpdate final
{
public:
	struct FMercunaAutoNavLinkIdentifier          Identifier;                                        // 0x0000(0x0028)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAutoNavLinkTraversalType              TraversalType;                                     // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaNavUsageTypes                  UsageTypes;                                        // 0x002C(0x0004)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Cost;                                              // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaAutoNavLinkForUpdate) == 0x000008, "Wrong alignment on FMercunaAutoNavLinkForUpdate");
static_assert(sizeof(FMercunaAutoNavLinkForUpdate) == 0x000038, "Wrong size on FMercunaAutoNavLinkForUpdate");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, Identifier) == 0x000000, "Member 'FMercunaAutoNavLinkForUpdate::Identifier' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, bEnabled) == 0x000028, "Member 'FMercunaAutoNavLinkForUpdate::bEnabled' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, TraversalType) == 0x000029, "Member 'FMercunaAutoNavLinkForUpdate::TraversalType' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, UsageTypes) == 0x00002C, "Member 'FMercunaAutoNavLinkForUpdate::UsageTypes' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, Cost) == 0x000030, "Member 'FMercunaAutoNavLinkForUpdate::Cost' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavMeshEdge
// 0x0030 (0x0030 - 0x0000)
struct FMercunaNavMeshEdge final
{
public:
	struct FVector                                EdgeStart;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EdgeEnd;                                           // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaNavMeshEdge) == 0x000008, "Wrong alignment on FMercunaNavMeshEdge");
static_assert(sizeof(FMercunaNavMeshEdge) == 0x000030, "Wrong size on FMercunaNavMeshEdge");
static_assert(offsetof(FMercunaNavMeshEdge, EdgeStart) == 0x000000, "Member 'FMercunaNavMeshEdge::EdgeStart' has a wrong offset!");
static_assert(offsetof(FMercunaNavMeshEdge, EdgeEnd) == 0x000018, "Member 'FMercunaNavMeshEdge::EdgeEnd' has a wrong offset!");

// ScriptStruct Mercuna.MercunaGroundAgentType
// 0x0000 (0x000C - 0x000C)
struct FMercunaGroundAgentType final : public FMercunaAgentType
{
};
static_assert(alignof(FMercunaGroundAgentType) == 0x000004, "Wrong alignment on FMercunaGroundAgentType");
static_assert(sizeof(FMercunaGroundAgentType) == 0x00000C, "Wrong size on FMercunaGroundAgentType");

// ScriptStruct Mercuna.MercunaSurfaceAgentType
// 0x0000 (0x000C - 0x000C)
struct FMercunaSurfaceAgentType final : public FMercunaAgentType
{
};
static_assert(alignof(FMercunaSurfaceAgentType) == 0x000004, "Wrong alignment on FMercunaSurfaceAgentType");
static_assert(sizeof(FMercunaSurfaceAgentType) == 0x00000C, "Wrong size on FMercunaSurfaceAgentType");

// ScriptStruct Mercuna.MercunaGroundAgentProperties
// 0x0030 (0x00E8 - 0x00B8)
struct FMercunaGroundAgentProperties final : public FMercuna2DAgentProperties
{
public:
	EMercunaGroundAgentCategory                   Category;                                          // 0x00B8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaGroundAgentShape                      Shape;                                             // 0x00B9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PawnWidth;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnLength;                                        // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAngle;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLaunchSpeed;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxImpactSpeed;                                    // 0x00CC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLaunchAngle;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLaunchOrLandAngle;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPerpendicularLaunchAngle;                       // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpCostMultiplier;                                // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LedgeMarginFraction;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaGroundAgentProperties) == 0x000008, "Wrong alignment on FMercunaGroundAgentProperties");
static_assert(sizeof(FMercunaGroundAgentProperties) == 0x0000E8, "Wrong size on FMercunaGroundAgentProperties");
static_assert(offsetof(FMercunaGroundAgentProperties, Category) == 0x0000B8, "Member 'FMercunaGroundAgentProperties::Category' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, Shape) == 0x0000B9, "Member 'FMercunaGroundAgentProperties::Shape' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, PawnWidth) == 0x0000BC, "Member 'FMercunaGroundAgentProperties::PawnWidth' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, PawnLength) == 0x0000C0, "Member 'FMercunaGroundAgentProperties::PawnLength' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxSlopeAngle) == 0x0000C4, "Member 'FMercunaGroundAgentProperties::MaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxLaunchSpeed) == 0x0000C8, "Member 'FMercunaGroundAgentProperties::MaxLaunchSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxImpactSpeed) == 0x0000CC, "Member 'FMercunaGroundAgentProperties::MaxImpactSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MinLaunchAngle) == 0x0000D0, "Member 'FMercunaGroundAgentProperties::MinLaunchAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxLaunchOrLandAngle) == 0x0000D4, "Member 'FMercunaGroundAgentProperties::MaxLaunchOrLandAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxPerpendicularLaunchAngle) == 0x0000D8, "Member 'FMercunaGroundAgentProperties::MaxPerpendicularLaunchAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, JumpCostMultiplier) == 0x0000DC, "Member 'FMercunaGroundAgentProperties::JumpCostMultiplier' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, LedgeMarginFraction) == 0x0000E0, "Member 'FMercunaGroundAgentProperties::LedgeMarginFraction' has a wrong offset!");

// ScriptStruct Mercuna.MerOctreeEditorSettings
// 0x0030 (0x0030 - 0x0000)
struct FMerOctreeEditorSettings final
{
public:
	struct FLinearColor                           NavigableColor;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HighCostColor;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnnavigableColor;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMerOctreeEditorSettings) == 0x000004, "Wrong alignment on FMerOctreeEditorSettings");
static_assert(sizeof(FMerOctreeEditorSettings) == 0x000030, "Wrong size on FMerOctreeEditorSettings");
static_assert(offsetof(FMerOctreeEditorSettings, NavigableColor) == 0x000000, "Member 'FMerOctreeEditorSettings::NavigableColor' has a wrong offset!");
static_assert(offsetof(FMerOctreeEditorSettings, HighCostColor) == 0x000010, "Member 'FMerOctreeEditorSettings::HighCostColor' has a wrong offset!");
static_assert(offsetof(FMerOctreeEditorSettings, UnnavigableColor) == 0x000020, "Member 'FMerOctreeEditorSettings::UnnavigableColor' has a wrong offset!");

// ScriptStruct Mercuna.MerGridEditorSettings
// 0x0028 (0x0028 - 0x0000)
struct FMerGridEditorSettings final
{
public:
	struct FLinearColor                           NavigableColor;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AutoJumpLinkColor;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalOffset;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMerGridEditorSettings) == 0x000004, "Wrong alignment on FMerGridEditorSettings");
static_assert(sizeof(FMerGridEditorSettings) == 0x000028, "Wrong size on FMerGridEditorSettings");
static_assert(offsetof(FMerGridEditorSettings, NavigableColor) == 0x000000, "Member 'FMerGridEditorSettings::NavigableColor' has a wrong offset!");
static_assert(offsetof(FMerGridEditorSettings, AutoJumpLinkColor) == 0x000010, "Member 'FMerGridEditorSettings::AutoJumpLinkColor' has a wrong offset!");
static_assert(offsetof(FMerGridEditorSettings, VerticalOffset) == 0x000020, "Member 'FMerGridEditorSettings::VerticalOffset' has a wrong offset!");
static_assert(offsetof(FMerGridEditorSettings, LineThickness) == 0x000024, "Member 'FMerGridEditorSettings::LineThickness' has a wrong offset!");

}


#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InfiniteGameWorlds

#include "Basic.hpp"

#include "UE4Dreamworld_classes.hpp"
#include "InfiniteGameWorlds_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "ReplicationGraph_classes.hpp"
#include "IgwCore_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Class InfiniteGameWorlds.IgwReplicationGraph
// 0x0000 (0x0780 - 0x0780)
class UIgwReplicationGraph : public UDWReplicationGraph
{
public:
	class US2sAlwaysReplicate_Node*               S2sAlwaysReplicateNode;                            // 0x0750(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class US2sAlwaysReplicateSameMap_Node*        S2sAlwaysReplicateSameMapNode;                     // 0x0758(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIgwReplicationGraphNode_GridSpatialization2D* GridNode;                                   // 0x0760(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AS2sController*                         S2sController;                                     // 0x0768(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_770[0x10];                                     // 0x0770(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwReplicationGraph">();
	}
	static class UIgwReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwReplicationGraph>();
	}
};
static_assert(alignof(UIgwReplicationGraph) == 0x000040, "Wrong alignment on UIgwReplicationGraph");
static_assert(sizeof(UIgwReplicationGraph) == 0x000780, "Wrong size on UIgwReplicationGraph");
static_assert(offsetof(UIgwReplicationGraph, S2sAlwaysReplicateNode) == 0x000750, "Member 'UIgwReplicationGraph::S2sAlwaysReplicateNode' has a wrong offset!");
static_assert(offsetof(UIgwReplicationGraph, S2sAlwaysReplicateSameMapNode) == 0x000758, "Member 'UIgwReplicationGraph::S2sAlwaysReplicateSameMapNode' has a wrong offset!");
static_assert(offsetof(UIgwReplicationGraph, GridNode) == 0x000760, "Member 'UIgwReplicationGraph::GridNode' has a wrong offset!");
static_assert(offsetof(UIgwReplicationGraph, S2sController) == 0x000768, "Member 'UIgwReplicationGraph::S2sController' has a wrong offset!");

// Class InfiniteGameWorlds.S2sReplicationGraph
// 0x0000 (0x0780 - 0x0780)
class US2sReplicationGraph final : public UIgwReplicationGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sReplicationGraph">();
	}
	static class US2sReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<US2sReplicationGraph>();
	}
};
static_assert(alignof(US2sReplicationGraph) == 0x000040, "Wrong alignment on US2sReplicationGraph");
static_assert(sizeof(US2sReplicationGraph) == 0x000780, "Wrong size on US2sReplicationGraph");

// Class InfiniteGameWorlds.S2sAlwaysReplicate_Node
// 0x0010 (0x0068 - 0x0058)
class US2sAlwaysReplicate_Node : public UReplicationGraphNode
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sAlwaysReplicate_Node">();
	}
	static class US2sAlwaysReplicate_Node* GetDefaultObj()
	{
		return GetDefaultObjImpl<US2sAlwaysReplicate_Node>();
	}
};
static_assert(alignof(US2sAlwaysReplicate_Node) == 0x000008, "Wrong alignment on US2sAlwaysReplicate_Node");
static_assert(sizeof(US2sAlwaysReplicate_Node) == 0x000068, "Wrong size on US2sAlwaysReplicate_Node");

// Class InfiniteGameWorlds.S2sAlwaysReplicateSameMap_Node
// 0x0000 (0x0068 - 0x0068)
class US2sAlwaysReplicateSameMap_Node final : public US2sAlwaysReplicate_Node
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sAlwaysReplicateSameMap_Node">();
	}
	static class US2sAlwaysReplicateSameMap_Node* GetDefaultObj()
	{
		return GetDefaultObjImpl<US2sAlwaysReplicateSameMap_Node>();
	}
};
static_assert(alignof(US2sAlwaysReplicateSameMap_Node) == 0x000008, "Wrong alignment on US2sAlwaysReplicateSameMap_Node");
static_assert(sizeof(US2sAlwaysReplicateSameMap_Node) == 0x000068, "Wrong size on US2sAlwaysReplicateSameMap_Node");

// Class InfiniteGameWorlds.DestinationMapProvider
// 0x0020 (0x0370 - 0x0350)
class ADestinationMapProvider final : public AActor
{
public:
	struct FSoftObjectPath                        Destination;                                       // 0x0350(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestinationMapProvider">();
	}
	static class ADestinationMapProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADestinationMapProvider>();
	}
};
static_assert(alignof(ADestinationMapProvider) == 0x000008, "Wrong alignment on ADestinationMapProvider");
static_assert(sizeof(ADestinationMapProvider) == 0x000370, "Wrong size on ADestinationMapProvider");
static_assert(offsetof(ADestinationMapProvider, Destination) == 0x000350, "Member 'ADestinationMapProvider::Destination' has a wrong offset!");

// Class InfiniteGameWorlds.IgwWorldComposition
// 0x0058 (0x0170 - 0x0118)
class UIgwWorldComposition : public UWorldComposition
{
public:
	uint8                                         Pad_118[0x58];                                     // 0x0118(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwWorldComposition">();
	}
	static class UIgwWorldComposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwWorldComposition>();
	}
};
static_assert(alignof(UIgwWorldComposition) == 0x000008, "Wrong alignment on UIgwWorldComposition");
static_assert(sizeof(UIgwWorldComposition) == 0x000170, "Wrong size on UIgwWorldComposition");

// Class InfiniteGameWorlds.HandlesLeavingGameInterface
// 0x0000 (0x0000 - 0x0000)
class IHandlesLeavingGameInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandlesLeavingGameInterface">();
	}
	static class IHandlesLeavingGameInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHandlesLeavingGameInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHandlesLeavingGameInterface) == 0x000001, "Wrong alignment on IHandlesLeavingGameInterface");
static_assert(sizeof(IHandlesLeavingGameInterface) == 0x000001, "Wrong size on IHandlesLeavingGameInterface");

// Class InfiniteGameWorlds.UniverseTimeComponent
// 0x0040 (0x0168 - 0x0128)
class UUniverseTimeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFarmTime                              m_RepFarmTime;                                     // 0x0138(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x18];                                     // 0x0150(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FarmTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniverseTimeComponent">();
	}
	static class UUniverseTimeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniverseTimeComponent>();
	}
};
static_assert(alignof(UUniverseTimeComponent) == 0x000008, "Wrong alignment on UUniverseTimeComponent");
static_assert(sizeof(UUniverseTimeComponent) == 0x000168, "Wrong size on UUniverseTimeComponent");
static_assert(offsetof(UUniverseTimeComponent, m_RepFarmTime) == 0x000138, "Member 'UUniverseTimeComponent::m_RepFarmTime' has a wrong offset!");

// Class InfiniteGameWorlds.IgwWorldPartitioner
// 0x0038 (0x0068 - 0x0030)
class UIgwWorldPartitioner : public UWorldPartitioner
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwWorldPartitioner">();
	}
	static class UIgwWorldPartitioner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwWorldPartitioner>();
	}
};
static_assert(alignof(UIgwWorldPartitioner) == 0x000008, "Wrong alignment on UIgwWorldPartitioner");
static_assert(sizeof(UIgwWorldPartitioner) == 0x000068, "Wrong size on UIgwWorldPartitioner");

// Class InfiniteGameWorlds.IgwGameModeBase
// 0x0000 (0x0450 - 0x0450)
class AIgwGameModeBase : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwGameModeBase">();
	}
	static class AIgwGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwGameModeBase>();
	}
};
static_assert(alignof(AIgwGameModeBase) == 0x000010, "Wrong alignment on AIgwGameModeBase");
static_assert(sizeof(AIgwGameModeBase) == 0x000450, "Wrong size on AIgwGameModeBase");

// Class InfiniteGameWorlds.S2sActor
// 0x0020 (0x0370 - 0x0350)
class AS2sActor final : public AActor
{
public:
	int32                                         Something;                                         // 0x0350(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AS2sActor*                              LocalActor;                                        // 0x0358(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sActor">();
	}
	static class AS2sActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AS2sActor>();
	}
};
static_assert(alignof(AS2sActor) == 0x000008, "Wrong alignment on AS2sActor");
static_assert(sizeof(AS2sActor) == 0x000370, "Wrong size on AS2sActor");
static_assert(offsetof(AS2sActor, Something) == 0x000350, "Member 'AS2sActor::Something' has a wrong offset!");
static_assert(offsetof(AS2sActor, LocalActor) == 0x000358, "Member 'AS2sActor::LocalActor' has a wrong offset!");

// Class InfiniteGameWorlds.S2sNetReplicationGraphConnection
// 0x0000 (0x0418 - 0x0418)
class US2sNetReplicationGraphConnection final : public UNetReplicationGraphConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sNetReplicationGraphConnection">();
	}
	static class US2sNetReplicationGraphConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<US2sNetReplicationGraphConnection>();
	}
};
static_assert(alignof(US2sNetReplicationGraphConnection) == 0x000008, "Wrong alignment on US2sNetReplicationGraphConnection");
static_assert(sizeof(US2sNetReplicationGraphConnection) == 0x000418, "Wrong size on US2sNetReplicationGraphConnection");

// Class InfiniteGameWorlds.S2sCheatManager
// 0x0010 (0x0040 - 0x0030)
class US2sCheatManager : public UObject
{
public:
	TArray<class FName>                           ServerExecAllOnly;                                 // 0x0030(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	void ReceiveEndPlay();
	void ReceiveInitCheatManager();
	void SetSoftBorderEnabled(const bool Enabled);
	void SetSoftBorderMargin(const float Margin);

	void PrintActorFindSystemState() const;
	void PrintActorPersistenceOwnership() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sCheatManager">();
	}
	static class US2sCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<US2sCheatManager>();
	}
};
static_assert(alignof(US2sCheatManager) == 0x000008, "Wrong alignment on US2sCheatManager");
static_assert(sizeof(US2sCheatManager) == 0x000040, "Wrong size on US2sCheatManager");
static_assert(offsetof(US2sCheatManager, ServerExecAllOnly) == 0x000030, "Member 'US2sCheatManager::ServerExecAllOnly' has a wrong offset!");

// Class InfiniteGameWorlds.ServerMapData
// 0x0150 (0x0180 - 0x0030)
class UServerMapData : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerDataArray                       PlayerPositions;                                   // 0x0048(0x0138)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_PlayerPositions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerMapData">();
	}
	static class UServerMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerMapData>();
	}
};
static_assert(alignof(UServerMapData) == 0x000008, "Wrong alignment on UServerMapData");
static_assert(sizeof(UServerMapData) == 0x000180, "Wrong size on UServerMapData");
static_assert(offsetof(UServerMapData, PlayerPositions) == 0x000048, "Member 'UServerMapData::PlayerPositions' has a wrong offset!");

// Class InfiniteGameWorlds.IgwReplicationGraphNode_GridSpatialization2D
// 0x0010 (0x02A0 - 0x0290)
class UIgwReplicationGraphNode_GridSpatialization2D final : public UReplicationGraphNode_GridSpatialization2D
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwReplicationGraphNode_GridSpatialization2D">();
	}
	static class UIgwReplicationGraphNode_GridSpatialization2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwReplicationGraphNode_GridSpatialization2D>();
	}
};
static_assert(alignof(UIgwReplicationGraphNode_GridSpatialization2D) == 0x000008, "Wrong alignment on UIgwReplicationGraphNode_GridSpatialization2D");
static_assert(sizeof(UIgwReplicationGraphNode_GridSpatialization2D) == 0x0002A0, "Wrong size on UIgwReplicationGraphNode_GridSpatialization2D");

// Class InfiniteGameWorlds.IGWStreamingTilesGenerator
// 0x0020 (0x0050 - 0x0030)
class UIGWStreamingTilesGenerator : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGWStreamingTilesGenerator">();
	}
	static class UIGWStreamingTilesGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGWStreamingTilesGenerator>();
	}
};
static_assert(alignof(UIGWStreamingTilesGenerator) == 0x000008, "Wrong alignment on UIGWStreamingTilesGenerator");
static_assert(sizeof(UIGWStreamingTilesGenerator) == 0x000050, "Wrong size on UIGWStreamingTilesGenerator");

// Class InfiniteGameWorlds.S2sDataRelay
// 0x0000 (0x0350 - 0x0350)
class AS2sDataRelay final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sDataRelay">();
	}
	static class AS2sDataRelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<AS2sDataRelay>();
	}
};
static_assert(alignof(AS2sDataRelay) == 0x000008, "Wrong alignment on AS2sDataRelay");
static_assert(sizeof(AS2sDataRelay) == 0x000350, "Wrong size on AS2sDataRelay");

// Class InfiniteGameWorlds.IGWStreamingTilesGenerator_Grid
// 0x0008 (0x0058 - 0x0050)
class UIGWStreamingTilesGenerator_Grid final : public UIGWStreamingTilesGenerator
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGWStreamingTilesGenerator_Grid">();
	}
	static class UIGWStreamingTilesGenerator_Grid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGWStreamingTilesGenerator_Grid>();
	}
};
static_assert(alignof(UIGWStreamingTilesGenerator_Grid) == 0x000008, "Wrong alignment on UIGWStreamingTilesGenerator_Grid");
static_assert(sizeof(UIGWStreamingTilesGenerator_Grid) == 0x000058, "Wrong size on UIGWStreamingTilesGenerator_Grid");

// Class InfiniteGameWorlds.ActorDebugInfo
// 0x0050 (0x0080 - 0x0030)
class UActorDebugInfo : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Location;                                          // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FActorGlobalID GetActorGlobalID() const;
	struct FVector GetLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDebugInfo">();
	}
	static class UActorDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDebugInfo>();
	}
};
static_assert(alignof(UActorDebugInfo) == 0x000008, "Wrong alignment on UActorDebugInfo");
static_assert(sizeof(UActorDebugInfo) == 0x000080, "Wrong size on UActorDebugInfo");
static_assert(offsetof(UActorDebugInfo, Actor) == 0x000040, "Member 'UActorDebugInfo::Actor' has a wrong offset!");
static_assert(offsetof(UActorDebugInfo, Location) == 0x000048, "Member 'UActorDebugInfo::Location' has a wrong offset!");

// Class InfiniteGameWorlds.S2sController
// 0x0FC0 (0x1310 - 0x0350)
class AS2sController : public AActor
{
public:
	uint8                                         Pad_350[0x20];                                     // 0x0350(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FS2sControllerTickFunction             S2sControllerTick;                                 // 0x0370(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FS2sControllerPostUpdateWorkTickFunction S2sControllerPostUpdateWorkTick;                 // 0x03D0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EIGWDebugLevel                                ServerDebugLevel;                                  // 0x0430(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorFindSystemComponent*              ActorFindSystem;                                   // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUniverseTimeComponent*                 UniverseTimeComponent;                             // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIgwDebugComponent*                     IgwDebugComponent;                                 // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLevelArrayRepl                        LoadedLevels;                                      // 0x0450(0x0018)(Edit, Net, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	struct FServerID                              ServerID;                                          // 0x0468(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             WorldOffset;                                       // 0x0478(0x000C)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             WorldCompositionShift;                             // 0x0484(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        MapName;                                           // 0x0490(0x0020)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPartitionDefinitionRepl               PartitionDefinition;                               // 0x04B0(0x0068)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGuid                                  FarmSessionID;                                     // 0x0518(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxNetCullDistanceSquared;                         // 0x0528(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AS2sController*                         MainController;                                    // 0x0530(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIGWSubsystem*                          IGWSubsystem;                                      // 0x0538(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPeerServerData                        LocalAddress;                                      // 0x0540(0x00D0)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	struct FServerDataArray                       PeerServers;                                       // 0x0610(0x0138)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FServerID>                      SortedServerList;                                  // 0x0748(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	struct FServerIndices                         ServerIndices;                                     // 0x0758(0x00B0)(Net, RepNotify, NativeAccessSpecifierPrivate)
	class UNetConnection*                         ClientConnection;                                  // 0x0808(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNetConnection*                         ServerConnection;                                  // 0x0810(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UServerMapData*                         ServerMapData;                                     // 0x0818(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ES2SServerState                               m_ServerState;                                     // 0x0820(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_821[0x3];                                      // 0x0821(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_FarmSize;                                        // 0x0824(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FElectionData                          m_ElectionData;                                    // 0x0828(0x0020)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_848[0x14];                                     // 0x0848(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapElectionData                       m_MapElectionData;                                 // 0x085C(0x0028)(Edit, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_884[0x14];                                     // 0x0884(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFarmConnectionReady;                              // 0x0898(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_899[0xF];                                      // 0x0899(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdGUIDs                      UniqueNetIdMap;                                    // 0x08A8(0x0058)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, class APlayerController*> PlayerControllerMap;                     // 0x0900(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_950[0x60];                                     // 0x0950(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UIgwNetDriver*                          ServerNetDriver;                                   // 0x09B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIgwNetDriver*                          ClientNetDriver;                                   // 0x09B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C0[0x10];                                     // 0x09C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ServerNetDriverName;                               // 0x09D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientNetDriverName;                               // 0x09D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIgwWorldPartitioner*                   WorldPartitioner;                                  // 0x09E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class US2sCheatManager*                       CheatManager;                                      // 0x09E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class US2sCheatManager>           CheatClass;                                        // 0x09F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TWeakObjectPtr<class UNetConnection>, class AS2sController*> ServerControllerMap;           // 0x09F8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_A48[0x140];                                    // 0x0A48(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	class UIgwWorldComposition*                   m_IgwWorldComposition;                             // 0x0B88(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UIgwWorldPartitioner>       WorldPartitionerClass;                             // 0x0B90(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UIgwServerConnectionComponent> ConnectionComponentClass;                       // 0x0B98(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UServerDebugInfo>           ServerDebugInfoClass;                              // 0x0BA0(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UServerMapData>             ServerMapDataClass;                                // 0x0BA8(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BB0[0xC8];                                     // 0x0BB0(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FServerBoundaries                      ServerBoundaries;                                  // 0x0C78(0x00F8)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D70[0x1F8];                                    // 0x0D70(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerPingInterval;                                // 0x0F68(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F6C[0x74];                                     // 0x0F6C(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActorDebugMap                         PlayerDebugMap;                                    // 0x0FE0(0x0180)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1160[0x8];                                     // 0x1160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_RemotePlayersInFarm;                             // 0x1168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitForIndexStartSeconds;                          // 0x116C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1170[0x8];                                     // 0x1170(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReadyForGameplay;                               // 0x1178(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1179[0x127];                                   // 0x1179(0x0127)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFarmHealthTickFunction                FarmHealthTick;                                    // 0x12A0(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         m_FarmHealthInterval;                              // 0x1300(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1304[0xC];                                     // 0x1304(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientAuthorityTransferConfirmed(uint32 ActorNetGuid, const struct FActorStatePacket& StatePacket);
	void ClientEndPCAuthorityTransfer(class APlayerController* PC);
	void ClientFlushAuthorityTransfer();
	void ClientNotifyActorsToLoad(const TArray<struct FUniqueID>& PersistenceIDs);
	void ClientOnAuthorityTransferRejected(class APlayerController* PC);
	void ClientOnProxyAuthorityTransferStart(class AActor* Actor, const struct FAuthorityTransferParams& TransferParams);
	void ClientReplicateIgwObject(const class FName ObjectName, TSubclassOf<class UIgwObject> Class_0);
	void ClientSetControllerPawn(const struct FUniqueNetIdRepl& UniqueNetId, class APawn* Pawn);
	void ClientStartPCAuthorityTransfer(class APlayerController* PC, bool bSpectator);
	void CloseS2S(const class FString& Connection, int32 Direction);
	void EnableCheats();
	void OnRep_ElectionData();
	void OnRep_FarmSessionID();
	void OnRep_FarmSize();
	void OnRep_LoadedLevels();
	void OnRep_LocalAddress();
	void OnRep_MapElectionData();
	void OnRep_MapName(const struct FSoftObjectPath& OldMapName);
	void OnRep_PartitionDefinition();
	void OnRep_PeerServers();
	void OnRep_PlayerDebugMap();
	void OnRep_ServerBoundaries();
	void OnRep_ServerID();
	void OnRep_ServerIndices();
	void OnRep_ServerState();
	void OnRep_UniqueNetIdMap(const struct FUniqueNetIdGUIDs& OldFUniqueNetIdGUIDs);
	void OnRep_WorldCompositionShift();
	void OnRep_WorldOffset();
	void PerfCapture(int32 NumSeconds);
	void PingServers();
	void ServerFailAuthorityTransfer(const TArray<uint32>& ActorNetGuids);
	void ServerGrabActorAuthority(class AActor* Actor);
	void ServerInitiateTeleportTo(class AActor* Actor, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bIsATest, bool bNoCheck);
	void ServerRequestPlayerAuthorityTransfer(class APlayerController* PC, const TArray<class APlayerController*>& RelevantPlayers);
	void ServerSetControllerActive(class APlayerController* PC, bool bActive, bool bSpectator);
	void ServerStartAuthorityTransfer(class AActor* Actor, const struct FAuthorityTransferParams& TransferParams);

	void ServerExecRPC(const class FString& Msg) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S2sController">();
	}
	static class AS2sController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AS2sController>();
	}
};
static_assert(alignof(AS2sController) == 0x000010, "Wrong alignment on AS2sController");
static_assert(sizeof(AS2sController) == 0x001310, "Wrong size on AS2sController");
static_assert(offsetof(AS2sController, S2sControllerTick) == 0x000370, "Member 'AS2sController::S2sControllerTick' has a wrong offset!");
static_assert(offsetof(AS2sController, S2sControllerPostUpdateWorkTick) == 0x0003D0, "Member 'AS2sController::S2sControllerPostUpdateWorkTick' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerDebugLevel) == 0x000430, "Member 'AS2sController::ServerDebugLevel' has a wrong offset!");
static_assert(offsetof(AS2sController, ActorFindSystem) == 0x000438, "Member 'AS2sController::ActorFindSystem' has a wrong offset!");
static_assert(offsetof(AS2sController, UniverseTimeComponent) == 0x000440, "Member 'AS2sController::UniverseTimeComponent' has a wrong offset!");
static_assert(offsetof(AS2sController, IgwDebugComponent) == 0x000448, "Member 'AS2sController::IgwDebugComponent' has a wrong offset!");
static_assert(offsetof(AS2sController, LoadedLevels) == 0x000450, "Member 'AS2sController::LoadedLevels' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerID) == 0x000468, "Member 'AS2sController::ServerID' has a wrong offset!");
static_assert(offsetof(AS2sController, WorldOffset) == 0x000478, "Member 'AS2sController::WorldOffset' has a wrong offset!");
static_assert(offsetof(AS2sController, WorldCompositionShift) == 0x000484, "Member 'AS2sController::WorldCompositionShift' has a wrong offset!");
static_assert(offsetof(AS2sController, MapName) == 0x000490, "Member 'AS2sController::MapName' has a wrong offset!");
static_assert(offsetof(AS2sController, PartitionDefinition) == 0x0004B0, "Member 'AS2sController::PartitionDefinition' has a wrong offset!");
static_assert(offsetof(AS2sController, FarmSessionID) == 0x000518, "Member 'AS2sController::FarmSessionID' has a wrong offset!");
static_assert(offsetof(AS2sController, MaxNetCullDistanceSquared) == 0x000528, "Member 'AS2sController::MaxNetCullDistanceSquared' has a wrong offset!");
static_assert(offsetof(AS2sController, MainController) == 0x000530, "Member 'AS2sController::MainController' has a wrong offset!");
static_assert(offsetof(AS2sController, IGWSubsystem) == 0x000538, "Member 'AS2sController::IGWSubsystem' has a wrong offset!");
static_assert(offsetof(AS2sController, LocalAddress) == 0x000540, "Member 'AS2sController::LocalAddress' has a wrong offset!");
static_assert(offsetof(AS2sController, PeerServers) == 0x000610, "Member 'AS2sController::PeerServers' has a wrong offset!");
static_assert(offsetof(AS2sController, SortedServerList) == 0x000748, "Member 'AS2sController::SortedServerList' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerIndices) == 0x000758, "Member 'AS2sController::ServerIndices' has a wrong offset!");
static_assert(offsetof(AS2sController, ClientConnection) == 0x000808, "Member 'AS2sController::ClientConnection' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerConnection) == 0x000810, "Member 'AS2sController::ServerConnection' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerMapData) == 0x000818, "Member 'AS2sController::ServerMapData' has a wrong offset!");
static_assert(offsetof(AS2sController, m_ServerState) == 0x000820, "Member 'AS2sController::m_ServerState' has a wrong offset!");
static_assert(offsetof(AS2sController, m_FarmSize) == 0x000824, "Member 'AS2sController::m_FarmSize' has a wrong offset!");
static_assert(offsetof(AS2sController, m_ElectionData) == 0x000828, "Member 'AS2sController::m_ElectionData' has a wrong offset!");
static_assert(offsetof(AS2sController, m_MapElectionData) == 0x00085C, "Member 'AS2sController::m_MapElectionData' has a wrong offset!");
static_assert(offsetof(AS2sController, bFarmConnectionReady) == 0x000898, "Member 'AS2sController::bFarmConnectionReady' has a wrong offset!");
static_assert(offsetof(AS2sController, UniqueNetIdMap) == 0x0008A8, "Member 'AS2sController::UniqueNetIdMap' has a wrong offset!");
static_assert(offsetof(AS2sController, PlayerControllerMap) == 0x000900, "Member 'AS2sController::PlayerControllerMap' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerNetDriver) == 0x0009B0, "Member 'AS2sController::ServerNetDriver' has a wrong offset!");
static_assert(offsetof(AS2sController, ClientNetDriver) == 0x0009B8, "Member 'AS2sController::ClientNetDriver' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerNetDriverName) == 0x0009D0, "Member 'AS2sController::ServerNetDriverName' has a wrong offset!");
static_assert(offsetof(AS2sController, ClientNetDriverName) == 0x0009D8, "Member 'AS2sController::ClientNetDriverName' has a wrong offset!");
static_assert(offsetof(AS2sController, WorldPartitioner) == 0x0009E0, "Member 'AS2sController::WorldPartitioner' has a wrong offset!");
static_assert(offsetof(AS2sController, CheatManager) == 0x0009E8, "Member 'AS2sController::CheatManager' has a wrong offset!");
static_assert(offsetof(AS2sController, CheatClass) == 0x0009F0, "Member 'AS2sController::CheatClass' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerControllerMap) == 0x0009F8, "Member 'AS2sController::ServerControllerMap' has a wrong offset!");
static_assert(offsetof(AS2sController, m_IgwWorldComposition) == 0x000B88, "Member 'AS2sController::m_IgwWorldComposition' has a wrong offset!");
static_assert(offsetof(AS2sController, WorldPartitionerClass) == 0x000B90, "Member 'AS2sController::WorldPartitionerClass' has a wrong offset!");
static_assert(offsetof(AS2sController, ConnectionComponentClass) == 0x000B98, "Member 'AS2sController::ConnectionComponentClass' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerDebugInfoClass) == 0x000BA0, "Member 'AS2sController::ServerDebugInfoClass' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerMapDataClass) == 0x000BA8, "Member 'AS2sController::ServerMapDataClass' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerBoundaries) == 0x000C78, "Member 'AS2sController::ServerBoundaries' has a wrong offset!");
static_assert(offsetof(AS2sController, ServerPingInterval) == 0x000F68, "Member 'AS2sController::ServerPingInterval' has a wrong offset!");
static_assert(offsetof(AS2sController, PlayerDebugMap) == 0x000FE0, "Member 'AS2sController::PlayerDebugMap' has a wrong offset!");
static_assert(offsetof(AS2sController, m_RemotePlayersInFarm) == 0x001168, "Member 'AS2sController::m_RemotePlayersInFarm' has a wrong offset!");
static_assert(offsetof(AS2sController, WaitForIndexStartSeconds) == 0x00116C, "Member 'AS2sController::WaitForIndexStartSeconds' has a wrong offset!");
static_assert(offsetof(AS2sController, bIsReadyForGameplay) == 0x001178, "Member 'AS2sController::bIsReadyForGameplay' has a wrong offset!");
static_assert(offsetof(AS2sController, FarmHealthTick) == 0x0012A0, "Member 'AS2sController::FarmHealthTick' has a wrong offset!");
static_assert(offsetof(AS2sController, m_FarmHealthInterval) == 0x001300, "Member 'AS2sController::m_FarmHealthInterval' has a wrong offset!");

// Class InfiniteGameWorlds.ActorFindSystemComponent
// 0x0100 (0x0228 - 0x0128)
class UActorFindSystemComponent final : public UActorComponent
{
public:
	struct FActorGIDDataMap                       ActorDataMap;                                      // 0x0128(0x00A0)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x60];                                     // 0x01C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActorDataMap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorFindSystemComponent">();
	}
	static class UActorFindSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorFindSystemComponent>();
	}
};
static_assert(alignof(UActorFindSystemComponent) == 0x000008, "Wrong alignment on UActorFindSystemComponent");
static_assert(sizeof(UActorFindSystemComponent) == 0x000228, "Wrong size on UActorFindSystemComponent");
static_assert(offsetof(UActorFindSystemComponent, ActorDataMap) == 0x000128, "Member 'UActorFindSystemComponent::ActorDataMap' has a wrong offset!");

// Class InfiniteGameWorlds.IgwActorChannel
// 0x0008 (0x0340 - 0x0338)
class UIgwActorChannel final : public UActorChannel
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwActorChannel">();
	}
	static class UIgwActorChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwActorChannel>();
	}
};
static_assert(alignof(UIgwActorChannel) == 0x000008, "Wrong alignment on UIgwActorChannel");
static_assert(sizeof(UIgwActorChannel) == 0x000340, "Wrong size on UIgwActorChannel");

// Class InfiniteGameWorlds.IgwDebugClient
// 0x0000 (0x0410 - 0x0410)
class AIgwDebugClient : public AOnlineBeaconClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwDebugClient">();
	}
	static class AIgwDebugClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwDebugClient>();
	}
};
static_assert(alignof(AIgwDebugClient) == 0x000010, "Wrong alignment on AIgwDebugClient");
static_assert(sizeof(AIgwDebugClient) == 0x000410, "Wrong size on AIgwDebugClient");

// Class InfiniteGameWorlds.IgwDebugHost
// 0x0000 (0x0488 - 0x0488)
class AIgwDebugHost final : public AOnlineBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwDebugHost">();
	}
	static class AIgwDebugHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwDebugHost>();
	}
};
static_assert(alignof(AIgwDebugHost) == 0x000008, "Wrong alignment on AIgwDebugHost");
static_assert(sizeof(AIgwDebugHost) == 0x000488, "Wrong size on AIgwDebugHost");

// Class InfiniteGameWorlds.IgwDebugHostObject
// 0x0000 (0x0378 - 0x0378)
class AIgwDebugHostObject : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwDebugHostObject">();
	}
	static class AIgwDebugHostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwDebugHostObject>();
	}
};
static_assert(alignof(AIgwDebugHostObject) == 0x000008, "Wrong alignment on AIgwDebugHostObject");
static_assert(sizeof(AIgwDebugHostObject) == 0x000378, "Wrong size on AIgwDebugHostObject");

// Class InfiniteGameWorlds.IgwDebugComponent
// 0x0228 (0x0350 - 0x0128)
class UIgwDebugComponent : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActorDebugMap                         Actors;                                            // 0x0130(0x0180)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         ListenPort;                                        // 0x02B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x6C];                                     // 0x02B4(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UActorDebugInfo>            ActorDebugInfoClass;                               // 0x0320(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AIgwDebugHostObject>        IgwDebugHostObjectClass;                           // 0x0328(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AOnlineBeaconClient>        IgwDebugClientClass;                               // 0x0330(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnlineBeaconHost*                      IgwDebugHost;                                      // 0x0338(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnlineBeaconHostObject*                IgwDebugHostObject;                                // 0x0340(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Actors(const struct FActorDebugMap& OldActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwDebugComponent">();
	}
	static class UIgwDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwDebugComponent>();
	}
};
static_assert(alignof(UIgwDebugComponent) == 0x000010, "Wrong alignment on UIgwDebugComponent");
static_assert(sizeof(UIgwDebugComponent) == 0x000350, "Wrong size on UIgwDebugComponent");
static_assert(offsetof(UIgwDebugComponent, Actors) == 0x000130, "Member 'UIgwDebugComponent::Actors' has a wrong offset!");
static_assert(offsetof(UIgwDebugComponent, ListenPort) == 0x0002B0, "Member 'UIgwDebugComponent::ListenPort' has a wrong offset!");
static_assert(offsetof(UIgwDebugComponent, ActorDebugInfoClass) == 0x000320, "Member 'UIgwDebugComponent::ActorDebugInfoClass' has a wrong offset!");
static_assert(offsetof(UIgwDebugComponent, IgwDebugHostObjectClass) == 0x000328, "Member 'UIgwDebugComponent::IgwDebugHostObjectClass' has a wrong offset!");
static_assert(offsetof(UIgwDebugComponent, IgwDebugClientClass) == 0x000330, "Member 'UIgwDebugComponent::IgwDebugClientClass' has a wrong offset!");
static_assert(offsetof(UIgwDebugComponent, IgwDebugHost) == 0x000338, "Member 'UIgwDebugComponent::IgwDebugHost' has a wrong offset!");
static_assert(offsetof(UIgwDebugComponent, IgwDebugHostObject) == 0x000340, "Member 'UIgwDebugComponent::IgwDebugHostObject' has a wrong offset!");

// Class InfiniteGameWorlds.IgwDebugWidget
// 0x0080 (0x0308 - 0x0288)
class UIgwDebugWidget final : public UUserWidget
{
public:
	class UIgwServerGridView*                     ServerGridView;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UComboBoxString*                        MapSelectCombo;                                    // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x70];                                     // 0x0298(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class APawn* GetPawnOrSpectator(class APlayerController* PC);

	ESlateVisibility GetMapComboVisibility();
	void OnMapChanged(const class FString& SelectedItem, ESelectInfo SelectionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwDebugWidget">();
	}
	static class UIgwDebugWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwDebugWidget>();
	}
};
static_assert(alignof(UIgwDebugWidget) == 0x000008, "Wrong alignment on UIgwDebugWidget");
static_assert(sizeof(UIgwDebugWidget) == 0x000308, "Wrong size on UIgwDebugWidget");
static_assert(offsetof(UIgwDebugWidget, ServerGridView) == 0x000288, "Member 'UIgwDebugWidget::ServerGridView' has a wrong offset!");
static_assert(offsetof(UIgwDebugWidget, MapSelectCombo) == 0x000290, "Member 'UIgwDebugWidget::MapSelectCombo' has a wrong offset!");

// Class InfiniteGameWorlds.IgwServerGridView
// 0x00E8 (0x0370 - 0x0288)
class UIgwServerGridView final : public UUserWidget
{
public:
	float                                         ZoomLevel;                                         // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CurrentMap;                                        // 0x0290(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 CurrentWorld;                                      // 0x02B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ScrollablePanel;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MouseBox;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MainPanel;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           PlayerBox;                                         // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        Pawns;                                             // 0x02D8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FServerID>                      CurrentServerList;                                 // 0x02E8(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<struct FServerID, class UIgwServerItem*> ServerWidgets;                                     // 0x02F8(0x0050)(BlueprintVisible, ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       PawnBrush;                                         // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GridPositionOffset;                                // 0x0350(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hover;                                             // 0x0360(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UIgwServerItem>             ServerItemWidgetClass;                             // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool HasServerData();
	struct FVector2D MouseToWorld(const struct FGeometry& Geometry, const struct FPointerEvent& PointerEvent);
	struct FVector2D PositionToWorld(const struct FGeometry& Geometry, const struct FVector2D& position);
	void Rebuild();
	void ScrollGrid(const struct FVector2D& Offset);
	struct FVector2D WorldToLocal(const struct FVector& WorldLocation);
	void ZoomIn(float Amount);
	void ZoomOut(float Amount);

	void DrawPawns(struct FPaintContext& Context) const;
	struct FSoftObjectPath GetCurrentMap() const;
	float GetZoomLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwServerGridView">();
	}
	static class UIgwServerGridView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwServerGridView>();
	}
};
static_assert(alignof(UIgwServerGridView) == 0x000008, "Wrong alignment on UIgwServerGridView");
static_assert(sizeof(UIgwServerGridView) == 0x000370, "Wrong size on UIgwServerGridView");
static_assert(offsetof(UIgwServerGridView, ZoomLevel) == 0x000288, "Member 'UIgwServerGridView::ZoomLevel' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, CurrentMap) == 0x000290, "Member 'UIgwServerGridView::CurrentMap' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, CurrentWorld) == 0x0002B0, "Member 'UIgwServerGridView::CurrentWorld' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, ScrollablePanel) == 0x0002B8, "Member 'UIgwServerGridView::ScrollablePanel' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, MouseBox) == 0x0002C0, "Member 'UIgwServerGridView::MouseBox' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, MainPanel) == 0x0002C8, "Member 'UIgwServerGridView::MainPanel' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, PlayerBox) == 0x0002D0, "Member 'UIgwServerGridView::PlayerBox' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, Pawns) == 0x0002D8, "Member 'UIgwServerGridView::Pawns' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, CurrentServerList) == 0x0002E8, "Member 'UIgwServerGridView::CurrentServerList' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, ServerWidgets) == 0x0002F8, "Member 'UIgwServerGridView::ServerWidgets' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, PawnBrush) == 0x000348, "Member 'UIgwServerGridView::PawnBrush' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, GridPositionOffset) == 0x000350, "Member 'UIgwServerGridView::GridPositionOffset' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, Hover) == 0x000360, "Member 'UIgwServerGridView::Hover' has a wrong offset!");
static_assert(offsetof(UIgwServerGridView, ServerItemWidgetClass) == 0x000368, "Member 'UIgwServerGridView::ServerItemWidgetClass' has a wrong offset!");

// Class InfiniteGameWorlds.IgwServerItem
// 0x00A0 (0x0328 - 0x0288)
class UIgwServerItem final : public UUserWidget
{
public:
	class UIgwServerGridView*                     GridViewWidget;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_C2S;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PlayerCount;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_S2S;                                          // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ServerFps;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ServerId;                                     // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ServerIndex;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_WorldOffset;                                  // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_S2STraffic;                                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x40];                                     // 0x02D0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FServerID                              ServerID;                                          // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       LevelBrush;                                        // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeTextFontSize(class UTextBlock* Widget, int32 BaseSize);
	void SetSize(const struct FVector2D& NewSize);

	void GetServerIdentifier(class FText* OutServerIdentifier) const;
	void GetServerIdText(class FText* OutServerId, const int32 MaxLength) const;
	float GetZoomLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwServerItem">();
	}
	static class UIgwServerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwServerItem>();
	}
};
static_assert(alignof(UIgwServerItem) == 0x000008, "Wrong alignment on UIgwServerItem");
static_assert(sizeof(UIgwServerItem) == 0x000328, "Wrong size on UIgwServerItem");
static_assert(offsetof(UIgwServerItem, GridViewWidget) == 0x000288, "Member 'UIgwServerItem::GridViewWidget' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_C2S) == 0x000290, "Member 'UIgwServerItem::Text_C2S' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_PlayerCount) == 0x000298, "Member 'UIgwServerItem::Text_PlayerCount' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_S2S) == 0x0002A0, "Member 'UIgwServerItem::Text_S2S' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_ServerFps) == 0x0002A8, "Member 'UIgwServerItem::Text_ServerFps' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_ServerId) == 0x0002B0, "Member 'UIgwServerItem::Text_ServerId' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_ServerIndex) == 0x0002B8, "Member 'UIgwServerItem::Text_ServerIndex' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_WorldOffset) == 0x0002C0, "Member 'UIgwServerItem::Text_WorldOffset' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, Text_S2STraffic) == 0x0002C8, "Member 'UIgwServerItem::Text_S2STraffic' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, ServerID) == 0x000310, "Member 'UIgwServerItem::ServerID' has a wrong offset!");
static_assert(offsetof(UIgwServerItem, LevelBrush) == 0x000320, "Member 'UIgwServerItem::LevelBrush' has a wrong offset!");

// Class InfiniteGameWorlds.IgwDebugFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UIgwDebugFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckArtificialBorder(const struct FVector& GlobalLocation, float Radius, int32 CellSize);
	static struct FBox2D GetActiveWorldBoundaries(const class UObject* WorldContext, const struct FSoftObjectPath& MapName);
	static void GetConnectedServers(const class UObject* WorldContext, int32* MainServerIndex, struct FUniqueID* MainPartitionId, class FString* MainServerAddress, TSet<struct FServerID>* CurrentServers);
	static int32 GetDimensionIndex(const class UObject* WorldContext, const struct FServerID& ServerID);
	static class UActorDebugInfo* GetFarmActorInfo(const class UObject* WorldContext, const struct FActorGlobalID& GID);
	static TArray<struct FActorGlobalID> GetFarmActorList(const class UObject* WorldContext);
	static TArray<struct FSoftObjectPath> GetFarmMaps(const class UObject* WorldContext);
	static int32 GetFarmNumActors(const class UObject* WorldContext);
	static void GetHumanReadableServerTraffic(const class UObject* WorldContext, const struct FServerID& ServerID, class FString* InBytesStr, class FString* OutBytesStr);
	static EIGWDebugLevel GetIGWDebugLevel(const class UObject* WorldContext);
	static int32 GetNumConnectedServers(const class UObject* WorldContext);
	static int32 GetNumStandByServers(const class UObject* WorldContext);
	static int32 GetPlayersConnectedToServer(const class UObject* WorldContext, const struct FServerID& ServerID);
	static int32 GetPlayersInServer(const class UObject* WorldContext, const struct FServerID& ServerID);
	static int32 GetS2SReplicatedActors(const class UObject* WorldContext, const struct FServerID& ServerID);
	static void GetS2SState(const class UObject* WorldContext, const struct FServerID& ServerID, int32* NumOut, int32* NumIn);
	static struct FBox2D GetServerBoundaries(const class UObject* WorldContext, const struct FServerID& ServerID);
	static float GetServerCPU(const class UObject* WorldContext, const struct FServerID& ServerID);
	static float GetServerFps(const class UObject* WorldContext, const struct FServerID& ServerID);
	static TArray<struct FServerID> GetServerIDs(const class UObject* WorldContext, bool bIncludeStandBy);
	static int32 GetServerIndex(const class UObject* WorldContext, const struct FServerID& ServerID);
	static TArray<class FName> GetServerLevels(const class UObject* WorldContext, const struct FServerID& ServerID);
	static class FString GetServerMainAddress(const class UObject* WorldContext, bool AddressWithPort);
	static struct FPartitionDefinition GetServerPartitionDefinition(const class UObject* WorldContext, const struct FServerID& ServerID);
	static void GetServerTraffic(const class UObject* WorldContext, const struct FServerID& ServerID, int32* InBytes, int32* OutBytes);
	static struct FIntVector GetServerWorldOffset(const class UObject* WorldContext, const struct FServerID& ServerID);
	static struct FBox2D GetWorldBoundaries(const class UObject* WorldContext, const struct FSoftObjectPath& MapName);
	static struct FVector2D GetWorldSize(const class UObject* WorldContext, const struct FSoftObjectPath& MapName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwDebugFunctionLibrary">();
	}
	static class UIgwDebugFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwDebugFunctionLibrary>();
	}
};
static_assert(alignof(UIgwDebugFunctionLibrary) == 0x000008, "Wrong alignment on UIgwDebugFunctionLibrary");
static_assert(sizeof(UIgwDebugFunctionLibrary) == 0x000030, "Wrong size on UIgwDebugFunctionLibrary");

// Class InfiniteGameWorlds.IgwFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UIgwFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int64 Conv_PartitionDefinitionToInt64(const struct FPartitionDefinition& Value);
	static class FString Conv_PartitionDefinitionToString(const struct FPartitionDefinition& Value);
	static class UActorComponent* GetActorComponentFromIgwActorComponentPointer(const struct FIgwActorComponentPointer& Ptr);
	static class AActor* GetActorFromIgwActorPointer(const struct FIgwActorPointer& Ptr);
	static struct FServerID GetActorServerID(const class UObject* WorldContext, class AActor* Actor);
	static int32 GetActorServerIndex(const class UObject* WorldContext, class AActor* Actor);
	static void GetC2SState(const class UObject* WorldContext, const struct FServerID& ServerID, int32* OutLatency, class FString* OutLastError);
	static class AS2sController* GetClientControllerForActor(const class AActor* Actor);
	static struct FServerID GetCurrentServerID(const class UObject* WorldContext);
	static struct FVector2D GetPlayerAbsoluteLocation(const class UObject* WorldContext);
	static struct FSlateColor GetServerColor(const class UObject* WorldContext, const struct FServerID& ServerID);
	static struct FServerID GetServerID(const class UObject* WorldContext);
	static struct FServerID GetServerIDFromLocation(const class UObject* WorldContext, const struct FVector& LocalLocation, bool* bOutIsOwnServer);
	static bool IsActorWithinServerBoundaries(const class AActor* Actor);
	static bool IsLocationWithinServerBoundaries(const class UObject* WorldContext, const struct FVector& LocalLocation);
	static struct FActorGlobalID MakeActorGlobalID(const class AActor* Actor);
	static struct FIgwActorComponentPointer MakeIgwActorComponentPointer(class UActorComponent* Ptr);
	static struct FIgwActorPointer MakeIgwActorPointer(class AActor* Ptr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwFunctionLibrary">();
	}
	static class UIgwFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwFunctionLibrary>();
	}
};
static_assert(alignof(UIgwFunctionLibrary) == 0x000008, "Wrong alignment on UIgwFunctionLibrary");
static_assert(sizeof(UIgwFunctionLibrary) == 0x000030, "Wrong size on UIgwFunctionLibrary");

// Class InfiniteGameWorlds.IgwGameState
// 0x0000 (0x03E0 - 0x03E0)
class AIgwGameState : public AGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwGameState">();
	}
	static class AIgwGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwGameState>();
	}
};
static_assert(alignof(AIgwGameState) == 0x000008, "Wrong alignment on AIgwGameState");
static_assert(sizeof(AIgwGameState) == 0x0003E0, "Wrong size on AIgwGameState");

// Class InfiniteGameWorlds.IgwIpConnectionInfo
// 0x0008 (0x0050 - 0x0048)
class UIgwIpConnectionInfo final : public UNetConnectionInfo
{
public:
	class AS2sController*                         Controller;                                        // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwIpConnectionInfo">();
	}
	static class UIgwIpConnectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwIpConnectionInfo>();
	}
};
static_assert(alignof(UIgwIpConnectionInfo) == 0x000008, "Wrong alignment on UIgwIpConnectionInfo");
static_assert(sizeof(UIgwIpConnectionInfo) == 0x000050, "Wrong size on UIgwIpConnectionInfo");
static_assert(offsetof(UIgwIpConnectionInfo, Controller) == 0x000048, "Member 'UIgwIpConnectionInfo::Controller' has a wrong offset!");

// Class InfiniteGameWorlds.IgwLevelBounds
// 0x0000 (0x0360 - 0x0360)
class AIgwLevelBounds final : public ALevelBounds
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwLevelBounds">();
	}
	static class AIgwLevelBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwLevelBounds>();
	}
};
static_assert(alignof(AIgwLevelBounds) == 0x000008, "Wrong alignment on AIgwLevelBounds");
static_assert(sizeof(AIgwLevelBounds) == 0x000360, "Wrong size on AIgwLevelBounds");

// Class InfiniteGameWorlds.IgwLevelScriptActor
// 0x0000 (0x0358 - 0x0358)
class AIgwLevelScriptActor : public ALevelScriptActor
{
public:
	void ReceiveLevelGainsAuthority();
	void ReceiveLevelLosesAuthority();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwLevelScriptActor">();
	}
	static class AIgwLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwLevelScriptActor>();
	}
};
static_assert(alignof(AIgwLevelScriptActor) == 0x000008, "Wrong alignment on AIgwLevelScriptActor");
static_assert(sizeof(AIgwLevelScriptActor) == 0x000358, "Wrong size on AIgwLevelScriptActor");

// Class InfiniteGameWorlds.IgwLevelStreamingVolume
// 0x0000 (0x03A0 - 0x03A0)
class AIgwLevelStreamingVolume final : public ALevelStreamingVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwLevelStreamingVolume">();
	}
	static class AIgwLevelStreamingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgwLevelStreamingVolume>();
	}
};
static_assert(alignof(AIgwLevelStreamingVolume) == 0x000008, "Wrong alignment on AIgwLevelStreamingVolume");
static_assert(sizeof(AIgwLevelStreamingVolume) == 0x0003A0, "Wrong size on AIgwLevelStreamingVolume");

// Class InfiniteGameWorlds.IgwIpConnection
// 0x0000 (0x20E8 - 0x20E8)
class UIgwIpConnection : public UIpConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwIpConnection">();
	}
	static class UIgwIpConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwIpConnection>();
	}
};
static_assert(alignof(UIgwIpConnection) == 0x000008, "Wrong alignment on UIgwIpConnection");
static_assert(sizeof(UIgwIpConnection) == 0x0020E8, "Wrong size on UIgwIpConnection");

// Class InfiniteGameWorlds.IgwNetDriver
// 0x00C0 (0x0CC0 - 0x0C00)
class UIgwNetDriver final : public UIpNetDriver
{
public:
	class AS2sController*                         ServerController;                                  // 0x0BD0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetConnection*                         ActiveConnection;                                  // 0x0BD8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE0[0xE0];                                     // 0x0BE0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwNetDriver">();
	}
	static class UIgwNetDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwNetDriver>();
	}
};
static_assert(alignof(UIgwNetDriver) == 0x000040, "Wrong alignment on UIgwNetDriver");
static_assert(sizeof(UIgwNetDriver) == 0x000CC0, "Wrong size on UIgwNetDriver");
static_assert(offsetof(UIgwNetDriver, ServerController) == 0x000BD0, "Member 'UIgwNetDriver::ServerController' has a wrong offset!");
static_assert(offsetof(UIgwNetDriver, ActiveConnection) == 0x000BD8, "Member 'UIgwNetDriver::ActiveConnection' has a wrong offset!");

// Class InfiniteGameWorlds.IgwObject
// 0x0018 (0x0048 - 0x0030)
class UIgwObject : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FServerID>                      Servers;                                           // 0x0038(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void ClientFlushAuthorityTransfer(const struct FActorStatePacket& StatePacket);
	void ClientForceReplication();
	void MulticastTransferringTo(const struct FServerID& ServerID);
	void OnRep_Servers();
	void ServerAddServer(const struct FServerID& ServerID);
	void ServerRemoveServer(const struct FServerID& ServerID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwObject">();
	}
	static class UIgwObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwObject>();
	}
};
static_assert(alignof(UIgwObject) == 0x000008, "Wrong alignment on UIgwObject");
static_assert(sizeof(UIgwObject) == 0x000048, "Wrong size on UIgwObject");
static_assert(offsetof(UIgwObject, Servers) == 0x000038, "Member 'UIgwObject::Servers' has a wrong offset!");

// Class InfiniteGameWorlds.IgwFloatingObject
// 0x0000 (0x0048 - 0x0048)
class UIgwFloatingObject : public UIgwObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwFloatingObject">();
	}
	static class UIgwFloatingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwFloatingObject>();
	}
};
static_assert(alignof(UIgwFloatingObject) == 0x000008, "Wrong alignment on UIgwFloatingObject");
static_assert(sizeof(UIgwFloatingObject) == 0x000048, "Wrong size on UIgwFloatingObject");

// Class InfiniteGameWorlds.IgwResilientFloatingObject
// 0x0000 (0x0048 - 0x0048)
class UIgwResilientFloatingObject : public UIgwFloatingObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwResilientFloatingObject">();
	}
	static class UIgwResilientFloatingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwResilientFloatingObject>();
	}
};
static_assert(alignof(UIgwResilientFloatingObject) == 0x000008, "Wrong alignment on UIgwResilientFloatingObject");
static_assert(sizeof(UIgwResilientFloatingObject) == 0x000048, "Wrong size on UIgwResilientFloatingObject");

// Class InfiniteGameWorlds.ActorFollowingIgwObject
// 0x0010 (0x0058 - 0x0048)
class UActorFollowingIgwObject : public UIgwObject
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorFollowingIgwObject">();
	}
	static class UActorFollowingIgwObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorFollowingIgwObject>();
	}
};
static_assert(alignof(UActorFollowingIgwObject) == 0x000008, "Wrong alignment on UActorFollowingIgwObject");
static_assert(sizeof(UActorFollowingIgwObject) == 0x000058, "Wrong size on UActorFollowingIgwObject");

// Class InfiniteGameWorlds.IgwObjectFollowingComponent
// 0x0010 (0x0138 - 0x0128)
class UIgwObjectFollowingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwObjectFollowingComponent">();
	}
	static class UIgwObjectFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwObjectFollowingComponent>();
	}
};
static_assert(alignof(UIgwObjectFollowingComponent) == 0x000008, "Wrong alignment on UIgwObjectFollowingComponent");
static_assert(sizeof(UIgwObjectFollowingComponent) == 0x000138, "Wrong size on UIgwObjectFollowingComponent");

// Class InfiniteGameWorlds.AuthorityActorFollowingIgwObject
// 0x0018 (0x0070 - 0x0058)
class UAuthorityActorFollowingIgwObject : public UActorFollowingIgwObject
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthorityActorFollowingIgwObject">();
	}
	static class UAuthorityActorFollowingIgwObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthorityActorFollowingIgwObject>();
	}
};
static_assert(alignof(UAuthorityActorFollowingIgwObject) == 0x000008, "Wrong alignment on UAuthorityActorFollowingIgwObject");
static_assert(sizeof(UAuthorityActorFollowingIgwObject) == 0x000070, "Wrong size on UAuthorityActorFollowingIgwObject");

// Class InfiniteGameWorlds.FloatingActorFollowingIgwObject
// 0x0000 (0x0058 - 0x0058)
class UFloatingActorFollowingIgwObject : public UActorFollowingIgwObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatingActorFollowingIgwObject">();
	}
	static class UFloatingActorFollowingIgwObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatingActorFollowingIgwObject>();
	}
};
static_assert(alignof(UFloatingActorFollowingIgwObject) == 0x000008, "Wrong alignment on UFloatingActorFollowingIgwObject");
static_assert(sizeof(UFloatingActorFollowingIgwObject) == 0x000058, "Wrong size on UFloatingActorFollowingIgwObject");

// Class InfiniteGameWorlds.IgwServerConnectionComponent
// 0x04B8 (0x05E0 - 0x0128)
class alignas(0x10) UIgwServerConnectionComponent : public UActorComponent
{
public:
	class AS2sController*                         ServerController;                                  // 0x0128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APawn>                   RemotePawn;                                        // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerFPS;                                         // 0x0138(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerCPU;                                         // 0x013C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIGWDebugLevel                                DebugLevel;                                        // 0x0140(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FServerGridLevelMap                    ServerGridLevelMap;                                // 0x0148(0x0300)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FIGWServerArray                        Servers;                                           // 0x0448(0x0138)(Edit, Net, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_580[0x10];                                     // 0x0580(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_SelectedDimension;                               // 0x0590(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_594[0xC];                                      // 0x0594(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentWorldOffset;                                // 0x05A0(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x28];                                     // 0x05B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Disconnected();
	TArray<class FString> GetServers();
	struct FVector GetWorldOffset();
	void OnRep_CurrentWorldOffset(const struct FVector& OldOffset);
	void OnRep_ServerCPU();
	void OnRep_ServerFPS();
	void OnRep_ServerGridLevelMap();
	void OnRep_Servers();
	void ServerSetDebugLevel(int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwServerConnectionComponent">();
	}
	static class UIgwServerConnectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwServerConnectionComponent>();
	}
};
static_assert(alignof(UIgwServerConnectionComponent) == 0x000010, "Wrong alignment on UIgwServerConnectionComponent");
static_assert(sizeof(UIgwServerConnectionComponent) == 0x0005E0, "Wrong size on UIgwServerConnectionComponent");
static_assert(offsetof(UIgwServerConnectionComponent, ServerController) == 0x000128, "Member 'UIgwServerConnectionComponent::ServerController' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, RemotePawn) == 0x000130, "Member 'UIgwServerConnectionComponent::RemotePawn' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, ServerFPS) == 0x000138, "Member 'UIgwServerConnectionComponent::ServerFPS' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, ServerCPU) == 0x00013C, "Member 'UIgwServerConnectionComponent::ServerCPU' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, DebugLevel) == 0x000140, "Member 'UIgwServerConnectionComponent::DebugLevel' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, ServerGridLevelMap) == 0x000148, "Member 'UIgwServerConnectionComponent::ServerGridLevelMap' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, Servers) == 0x000448, "Member 'UIgwServerConnectionComponent::Servers' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, m_SelectedDimension) == 0x000590, "Member 'UIgwServerConnectionComponent::m_SelectedDimension' has a wrong offset!");
static_assert(offsetof(UIgwServerConnectionComponent, CurrentWorldOffset) == 0x0005A0, "Member 'UIgwServerConnectionComponent::CurrentWorldOffset' has a wrong offset!");

// Class InfiniteGameWorlds.IGWSubsystem
// 0x0080 (0x00B8 - 0x0038)
class UIGWSubsystem : public UWorldSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FServerID                              ServerID;                                          // 0x0040(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  FarmSessionID;                                     // 0x0050(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 FarmName;                                          // 0x0060(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AS2sController*                         ServerController;                                  // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AS2sController>             S2sControllerClass;                                // 0x0078(0x0008)(ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x4];                                       // 0x0080(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoServerSwitch;                                 // 0x0084(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bServerDataDebug;                                  // 0x0085(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoDiscovery;                                    // 0x0086(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EConnectFarm                                  ConnectFarm;                                       // 0x0087(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSoftBorder;                                       // 0x0088(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoftBorderMargin;                                  // 0x008C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ImmediateAuthorityTransferMargin;                  // 0x0090(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        MaxAuthorityTransferredActorsPerFrame;             // 0x0094(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MaxAuthorityTransferredActorsEnabled;              // 0x0098(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoadedLandscapeMargin;                             // 0x009C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IGWSubsystem">();
	}
	static class UIGWSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIGWSubsystem>();
	}
};
static_assert(alignof(UIGWSubsystem) == 0x000008, "Wrong alignment on UIGWSubsystem");
static_assert(sizeof(UIGWSubsystem) == 0x0000B8, "Wrong size on UIGWSubsystem");
static_assert(offsetof(UIGWSubsystem, ServerID) == 0x000040, "Member 'UIGWSubsystem::ServerID' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, FarmSessionID) == 0x000050, "Member 'UIGWSubsystem::FarmSessionID' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, FarmName) == 0x000060, "Member 'UIGWSubsystem::FarmName' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, ServerController) == 0x000070, "Member 'UIGWSubsystem::ServerController' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, S2sControllerClass) == 0x000078, "Member 'UIGWSubsystem::S2sControllerClass' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, bAutoServerSwitch) == 0x000084, "Member 'UIGWSubsystem::bAutoServerSwitch' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, bServerDataDebug) == 0x000085, "Member 'UIGWSubsystem::bServerDataDebug' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, bAutoDiscovery) == 0x000086, "Member 'UIGWSubsystem::bAutoDiscovery' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, ConnectFarm) == 0x000087, "Member 'UIGWSubsystem::ConnectFarm' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, bSoftBorder) == 0x000088, "Member 'UIGWSubsystem::bSoftBorder' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, SoftBorderMargin) == 0x00008C, "Member 'UIGWSubsystem::SoftBorderMargin' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, ImmediateAuthorityTransferMargin) == 0x000090, "Member 'UIGWSubsystem::ImmediateAuthorityTransferMargin' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, MaxAuthorityTransferredActorsPerFrame) == 0x000094, "Member 'UIGWSubsystem::MaxAuthorityTransferredActorsPerFrame' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, MaxAuthorityTransferredActorsEnabled) == 0x000098, "Member 'UIGWSubsystem::MaxAuthorityTransferredActorsEnabled' has a wrong offset!");
static_assert(offsetof(UIGWSubsystem, LoadedLandscapeMargin) == 0x00009C, "Member 'UIGWSubsystem::LoadedLandscapeMargin' has a wrong offset!");

// Class InfiniteGameWorlds.IgwWorldPartitioner_Grid
// 0x0070 (0x00D8 - 0x0068)
class UIgwWorldPartitioner_Grid : public UIgwWorldPartitioner
{
public:
	class UIGWStreamingTilesGenerator*            StreamingTileGenerator;                            // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManageEntireWorld;                                // 0x0070(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x5F];                                      // 0x0071(0x005F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              GridSize;                                          // 0x00D0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgwWorldPartitioner_Grid">();
	}
	static class UIgwWorldPartitioner_Grid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgwWorldPartitioner_Grid>();
	}
};
static_assert(alignof(UIgwWorldPartitioner_Grid) == 0x000008, "Wrong alignment on UIgwWorldPartitioner_Grid");
static_assert(sizeof(UIgwWorldPartitioner_Grid) == 0x0000D8, "Wrong size on UIgwWorldPartitioner_Grid");
static_assert(offsetof(UIgwWorldPartitioner_Grid, StreamingTileGenerator) == 0x000068, "Member 'UIgwWorldPartitioner_Grid::StreamingTileGenerator' has a wrong offset!");
static_assert(offsetof(UIgwWorldPartitioner_Grid, bManageEntireWorld) == 0x000070, "Member 'UIgwWorldPartitioner_Grid::bManageEntireWorld' has a wrong offset!");
static_assert(offsetof(UIgwWorldPartitioner_Grid, GridSize) == 0x0000D0, "Member 'UIgwWorldPartitioner_Grid::GridSize' has a wrong offset!");

// Class InfiniteGameWorlds.PlayerDebugInfo
// 0x0138 (0x01B8 - 0x0080)
class UPlayerDebugInfo final : public UActorDebugInfo
{
public:
	struct FServerIDArray                         ReplicatedServers;                                 // 0x0080(0x0138)(Net, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDebugInfo">();
	}
	static class UPlayerDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDebugInfo>();
	}
};
static_assert(alignof(UPlayerDebugInfo) == 0x000008, "Wrong alignment on UPlayerDebugInfo");
static_assert(sizeof(UPlayerDebugInfo) == 0x0001B8, "Wrong size on UPlayerDebugInfo");
static_assert(offsetof(UPlayerDebugInfo, ReplicatedServers) == 0x000080, "Member 'UPlayerDebugInfo::ReplicatedServers' has a wrong offset!");

// Class InfiniteGameWorlds.ServerDebugInfo
// 0x0270 (0x02A0 - 0x0030)
#pragma pack(push, 0x1)
class alignas(0x10) UServerDebugInfo : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelArrayRepl                        Levels;                                            // 0x0038(0x0018)(Net, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        MapName;                                           // 0x0050(0x0020)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActorDebugMap                         PlayerDebugMap;                                    // 0x0070(0x0180)(Net, NativeAccessSpecifierPrivate)
	struct FServerDebugData                       ServerDebugData;                                   // 0x01F0(0x00A0)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ServerDebugData(const struct FServerDebugData& OldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerDebugInfo">();
	}
	static class UServerDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerDebugInfo>();
	}
};
#pragma pack(pop)
static_assert(alignof(UServerDebugInfo) == 0x000010, "Wrong alignment on UServerDebugInfo");
static_assert(sizeof(UServerDebugInfo) == 0x0002A0, "Wrong size on UServerDebugInfo");
static_assert(offsetof(UServerDebugInfo, Levels) == 0x000038, "Member 'UServerDebugInfo::Levels' has a wrong offset!");
static_assert(offsetof(UServerDebugInfo, MapName) == 0x000050, "Member 'UServerDebugInfo::MapName' has a wrong offset!");
static_assert(offsetof(UServerDebugInfo, PlayerDebugMap) == 0x000070, "Member 'UServerDebugInfo::PlayerDebugMap' has a wrong offset!");
static_assert(offsetof(UServerDebugInfo, ServerDebugData) == 0x0001F0, "Member 'UServerDebugInfo::ServerDebugData' has a wrong offset!");

}

